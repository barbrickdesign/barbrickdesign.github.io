<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>BarbrickDesign ‚Äî Claim Your SOL</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description" content="BarbrickDesign ‚Äî recover SOL, inspect holdings, and showcase projects." />
  <style>
    :root{
      --bg:#071018; --panel:#0f131a; --muted:#9fb6c8; --text:#eaf1fb;
      --accent:#66fcf1; --good:#3be477; --warn:#fbbf24; --bad:#ff6b6b;
      --stroke:rgba(255,255,255,0.06);
    }
    *{box-sizing:border-box}
    html,body{margin:0;height:100%;font-family:Inter,system-ui,Roboto,Arial;background:radial-gradient(1200px 600px at 20% -20%, rgba(102,252,241,0.03), transparent),var(--bg);color:var(--text)}
    a{color:var(--accent);text-decoration:none}
    .wrap{max-width:1150px;margin:0 auto;padding:18px}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .card{background:linear-gradient(180deg,#0f131a,#0d1114);border:1px solid var(--stroke);border-radius:12px;padding:14px}
    .btn{background:#121827;color:var(--text);border:1px solid rgba(255,255,255,0.04);padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:700}
    .btn.ghost{background:transparent;border-color:var(--stroke)}
    .mono{font-family:ui-monospace,Menlo,Consolas}
    .small{font-size:13px;color:var(--muted)}
    .title{font-size:18px;font-weight:800}
    #projectsGrid{display:grid;gap:10px}
    @media(min-width:900px){ #projectsGrid{grid-template-columns:repeat(2,1fr)} }
    .project{display:flex;justify-content:space-between;gap:10px;align-items:center;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
    .value-pill{padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);font-weight:700}
    #debugPanel{position:fixed;bottom:0;left:0;right:0;background:#061218;border-top:1px solid #0b2130;color:#9bd;font-family:ui-monospace,Menlo,Consolas;padding:8px;max-height:360px;overflow:auto;z-index:9999}
    #debugLog{white-space:pre-wrap}
    .timestamp{font-size:12px;color:var(--muted);margin-top:6px}
    .links { display:flex;gap:8px;align-items:center }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.8/lib/index.iife.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/spl-token@0.3.11/dist/browser/spl-token.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
</head>
<body>
  <div class="wrap">
    <header style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
      <div style="display:flex;align-items:center;gap:12px">
        <div id="glyphContainer" title="Open 3D world" style="width:72px;height:72px;border-radius:12px;"></div>
        <div>
          <div class="title mono">BarbrickDesign</div>
          <div class="small">Recover SOL, map project value, and empower contributors</div>
        </div>
      </div>

      <div style="display:flex;align-items:flex-end;gap:16px">
        <div style="text-align:right">
          <div class="small">Total Projects Value</div>
          <div id="projectsTotal" style="font-weight:800">$0</div>
        </div>

        <div style="display:flex;flex-direction:column;align-items:flex-end">
          <button id="connectBtn" class="btn">Connect Wallet</button>
          <div id="walletStatus" class="mono small" style="margin-top:6px">Wallet: not connected</div>
        </div>
      </div>
    </header>

    <main style="margin-top:14px">
      <section class="card" aria-live="polite">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <div style="font-weight:800">Recover SOL</div>
            <div class="small">Scan wallet, close empty token accounts, prepare manual sells, and export a recovery report. All on-chain actions require your wallet approval.</div>
          </div>
          <div style="text-align:right">
            <div class="small">Estimated refund</div>
            <div id="refundEstimateBig" style="font-weight:800">0.00000 SOL</div>
          </div>
        </div>
      </section>

      <div style="display:grid;grid-template-columns:1fr 420px;gap:12px;margin-top:12px">
        <div class="card">
          <div style="display:flex;gap:8px;align-items:center">
            <button id="scanBtn" class="btn">Scan & Analyze</button>
            <button id="recoverBtn" class="btn">Close Empty Accounts</button>
            <button id="exportReport" class="btn">Export Recovery Report</button>
          </div>

          <div id="holdingsPanel" style="margin-top:12px" class="small"><div class="small">No wallet connected.</div></div>
        </div>

        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div style="font-weight:800">Projects</div>
            <div class="small">Full GitHub repo list with timestamps and initial USD proxy values</div>
          </div>

          <div id="projectsArea" style="margin-top:10px">
            <div id="projectsGrid"><div class="small">Loading projects‚Ä¶</div></div>
          </div>
        </div>
      </div>

      <section class="card" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:800">Counterparty Flow</div>
          <div class="small">Top receivers from recent parsed transactions</div>
        </div>
        <div id="counterpartyPanel" style="margin-top:10px" class="small">No data yet.</div>
      </section>

      <section class="card" style="margin-top:12px">
        <div style="font-weight:800">Session Feed</div>
        <div id="feed" style="margin-top:8px" class="small"></div>
      </section>
    </main>

    <footer style="margin-top:14px" class="small">¬© BarbrickDesign 2025 ¬∑ All actions require explicit wallet approval.</footer>
  </div>

  <div id="debugPanel" role="region" aria-label="Debug Log">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <strong>üîç Debug Log</strong>
      <div>
        <button id="dbgClear" class="btn" style="margin-right:8px">Clear</button>
        <button id="dbgHide" class="btn">Hide</button>
      </div>
    </div>
    <div id="debugLog" style="margin-top:8px"></div>
  </div>

  <script>
  // Final consolidated working index.html
  // Configuration
  const RPC_POOL = [
    'https://rpc.ankr.com/solana',
    'https://api.mainnet-beta.solana.com',
    'https://solana-api.projectserum.com',
    'https://ssc-dao.genesysgo.net'
  ];
  const SCAN_PROXY_URL = null; // optional serverless scan endpoint
  const VAL_PROXY_URL = null;  // optional valuation proxy (USAspending)

  const STARS_USD_MULT = 12;
  const RENT_PER_EMPTY_ACCOUNT_SOL = 0.00204;
  const FEE_WALLET = new solanaWeb3.PublicKey('5hSWosj58ki4A6hSfQrvteQU5QvyCWmhHn4AuqgaQzqr');

  let currentRpcIndex = 0;
  let connection = new solanaWeb3.Connection(RPC_POOL[currentRpcIndex], 'confirmed');
  let wallet = null;
  let holdings = [];
  let emptyTokenAccounts = [];
  let sessionFeed = [];

  // Debug helpers
  function logDebug(...parts){
    const el = document.getElementById('debugLog');
    const t = new Date().toLocaleTimeString();
    const line = document.createElement('div');
    line.textContent = '[' + t + '] ' + parts.map(p => (typeof p === 'object' ? JSON.stringify(p) : String(p))).join(' ');
    if(el){ el.appendChild(line); el.scrollTop = el.scrollHeight; }
    console.log(...parts);
  }
  document.getElementById('dbgClear').addEventListener('click', ()=> document.getElementById('debugLog').innerHTML = '');
  document.getElementById('dbgHide').addEventListener('click', (e)=>{ const d=document.getElementById('debugLog'); const hidden=d.style.display==='none'; d.style.display = hidden ? 'block' : 'none'; e.target.textContent = hidden ? 'Hide' : 'Show'; });

  function setStatus(msg, kind='info'){
    const el = document.getElementById('walletStatus');
    if(!el) return;
    el.textContent = wallet ? (wallet.toBase58 ? wallet.toBase58().slice(0,8) + '...' : String(wallet)) : msg;
    el.style.color = kind === 'error' ? '#ff6b6b' : kind === 'warn' ? '#fbbf24' : '#9fb6c8';
  }
  function toSol(n){ return (Math.round(n*100000)/100000).toFixed(5); }
  function safePubkey(p){ try{ if(!p) return null; if(p instanceof solanaWeb3.PublicKey) return p; if(p.publicKey && p.publicKey instanceof solanaWeb3.PublicKey) return p.publicKey; return new solanaWeb3.PublicKey(p); }catch{return null;} }

  // Non-blocking glyph
  (function initGlyph(){
    const c = document.getElementById('glyphContainer'); if(!c) return;
    c.addEventListener('click', ()=> window.open('https://barbrickdesign.github.io/city-3d/dist/index.html','_blank'));
    try{
      const w=72,h=72; const canvas=document.createElement('canvas'); canvas.width=w*devicePixelRatio; canvas.height=h*devicePixelRatio; canvas.style.width=w+'px'; canvas.style.height=h+'px'; c.appendChild(canvas);
      const renderer = new THREE.WebGLRenderer({ canvas, alpha:true, antialias:true }); renderer.setPixelRatio(devicePixelRatio||1); renderer.setSize(w,h,false);
      const scene = new THREE.Scene(); scene.add(new THREE.HemisphereLight(0xffffff,0x444444,0.6));
      const dir = new THREE.DirectionalLight(0xffffff,0.9); dir.position.set(5,10,7.5); scene.add(dir);
      const camera = new THREE.PerspectiveCamera(45,w/h,0.1,50); camera.position.set(0,0,6);
      const geom = new THREE.IcosahedronGeometry(1.2,1);
      const mat = new THREE.MeshStandardMaterial({ color:0x66fcf1, metalness:0.25, roughness:0.18 });
      const mesh = new THREE.Mesh(geom, mat); scene.add(mesh);
      (function animate(){ mesh.rotation.y += 0.012; renderer.render(scene, camera); requestAnimationFrame(animate); })();
    }catch(e){ c.textContent='3D'; logDebug('glyph init failed', e); }
  })();

  // Simple retry
  async function retry(fn, attempts=3, delay=300){
    let last;
    for(let i=0;i<attempts;i++){ try{ return await fn(); }catch(e){ last=e; await new Promise(r=>setTimeout(r, delay*(i+1))); } }
    throw last;
  }

  // RPC-safe token accounts
  async function fetchParsedTokenAccountsOwnerSafe(owner){
    if(SCAN_PROXY_URL){
      try{
        const res = await fetch(SCAN_PROXY_URL, { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify({ address: owner.toBase58(), tokenAccounts: true }) });
        if(res.ok){ const j = await res.json(); return j.tokenAccounts || j.parsed || []; }
        logDebug('scan proxy token non-ok', res.status);
      }catch(e){ logDebug('scan proxy token failed', e); }
    }
    for(let i=0;i<RPC_POOL.length;i++){
      const idx = (currentRpcIndex + i) % RPC_POOL.length;
      const rpc = RPC_POOL[idx];
      try{
        const conn = new solanaWeb3.Connection(rpc, 'confirmed');
        const resp = await conn.getParsedTokenAccountsByOwner(owner, { programId: splToken.TOKEN_PROGRAM_ID });
        if(resp && resp.value){ currentRpcIndex = idx; connection = conn; logDebug('getParsedTokenAccountsByOwner ok via', rpc); return resp.value; }
      }catch(e){ logDebug('getParsedTokenAccountsByOwner failed on', rpc, e); }
    }
    try{
      const raw = await connection.getTokenAccountsByOwner(owner, { programId: splToken.TOKEN_PROGRAM_ID });
      if(raw && raw.value) return raw.value.map(v=>({ pubkey: v.pubkey, account: v.account }));
    }catch(e){ logDebug('getTokenAccountsByOwner fallback failed', e); }
    return [];
  }

  // RPC-safe parsed transactions
  async function fetchParsedTxsOwnerSafe(owner, limit=200){
    if(SCAN_PROXY_URL){
      try{
        const res = await fetch(SCAN_PROXY_URL, { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify({ address: owner.toBase58(), transactions: true }) });
        if(res.ok){ const j = await res.json(); return j.transactions || []; }
        logDebug('scan proxy tx non-ok', res.status);
      }catch(e){ logDebug('scan proxy tx failed', e); }
    }
    for(let i=0;i<RPC_POOL.length;i++){
      const idx = (currentRpcIndex + i) % RPC_POOL.length;
      const rpc = RPC_POOL[idx];
      try{
        const conn = new solanaWeb3.Connection(rpc, 'confirmed');
        const sigInfos = await conn.getSignaturesForAddress(owner, { limit });
        const sigs = (sigInfos || []).map(s => s.signature);
        const parsed = [];
        for(let k=0;k<sigs.length;k+=20){
          const chunk = sigs.slice(k,k+20);
          const resolved = await Promise.all(chunk.map(sig => conn.getParsedTransaction(sig,'confirmed').catch(()=>null)));
          parsed.push(...resolved.filter(Boolean));
          await new Promise(r=>setTimeout(r,120));
        }
        currentRpcIndex = idx; connection = conn; logDebug('fetched parsed txs via', rpc); return parsed;
      }catch(e){ logDebug('fetchParsedTxs failed on', rpc, e); }
    }
    return [];
  }

  // Connect flow (tolerant)
  (function connectGuard(){
    let connecting=false, lastClick=0;
    async function waitProvider(timeout=2500){
      const start = Date.now();
      while(Date.now()-start < timeout){ if(window.solana) return window.solana; await new Promise(r=>setTimeout(r,120)); }
      return window.solana || null;
    }
    async function providerConnect(provider){
      if(typeof provider.connect === 'function'){ try{ return await provider.connect({ onlyIfTrusted:false }); }catch(e){ logDebug('provider.connect err', e); } }
      if(typeof provider.request === 'function'){ try{ return await provider.request({ method:'connect' }); }catch(e){ logDebug('provider.request(connect) err', e); } }
      throw new Error('Provider has no connect method');
    }
    async function connect(){
      const now = Date.now(); if(now - lastClick < 600){ logDebug('connect suppressed: debounce'); return; } lastClick = now;
      if(connecting){ logDebug('connect suppressed: in-flight'); return; }
      connecting = true;
      const btn = document.getElementById('connectBtn'); btn.disabled = true; btn.textContent = 'Connecting‚Ä¶'; setStatus('connecting','info');
      try{
        const provider = await waitProvider();
        if(!provider){ setStatus('No wallet injected','warn'); logDebug('no provider'); connecting=false; btn.disabled=false; btn.textContent='Connect Wallet'; return; }
        logDebug('provider.connect()');
        const resp = await providerConnect(provider);
        const pub = (resp && resp.publicKey) ? resp.publicKey : (provider.publicKey || null);
        if(!pub) throw new Error('No publicKey returned');
        wallet = pub;
        document.getElementById('walletStatus').textContent = 'Wallet: ' + wallet.toBase58().slice(0,8) + '...';
        logDebug('connected', wallet.toBase58());
        const nonce = Math.floor(Math.random()*1e9).toString();
        const message = `BarbrickDesign sign-in\nnonce:${nonce}\naddress:${wallet.toBase58()}`;
        const msg = new TextEncoder().encode(message);
        setStatus('requesting signature','info');
        let signed = null;
        try{ if(typeof provider.signMessage === 'function') signed = await provider.signMessage(msg,'utf8'); else if(typeof provider.request === 'function') signed = await provider.request({ method:'signMessage', params:{ message:Array.from(msg) } }); }catch(e){ logDebug('sign error', e); }
        if(signed && (signed.signature || signed.length)){ const sigBytes = signed.signature || signed; const sigBuf = sigBytes instanceof Uint8Array ? sigBytes : Uint8Array.from(sigBytes); const pubBytes = wallet.toBytes ? wallet.toBytes() : new solanaWeb3.PublicKey(wallet).toBytes(); const ok = nacl.sign.detached.verify(msg, sigBuf, pubBytes); logDebug('signature verified?', ok); } else logDebug('no signature (non-fatal)');
        setStatus('connected','success');
        await renderProjects();
        if(typeof scanAllHoldingsAndHistoryImproved === 'function') await scanAllHoldingsAndHistoryImproved();
      }catch(e){ logDebug('connect error', e && (e.message || e)); setStatus('Connection failed','error'); }
      connecting=false; btn.disabled=false; btn.textContent='Connect Wallet';
    }
    document.getElementById('connectBtn').addEventListener('click', connect);
  })();

  // Projects loader
  async function fetchAllGithubRepos(user, perPage=100, maxPages=20){
    const out=[];
    for(let page=1; page<=maxPages; page++){
      try{ const url = `https://api.github.com/users/${encodeURIComponent(user)}/repos?per_page=${perPage}&page=${page}&type=owner&sort=updated`; const r = await fetch(url); if(!r.ok){ logDebug('GitHub API non-ok', r.status); break; } const j = await r.json(); if(!Array.isArray(j) || j.length===0) break; out.push(...j); if(j.length < perPage) break; }catch(e){ logDebug('fetchAllGithubRepos error', e); break; }
    }
    return out;
  }

  async function renderProjects(){
    const grid = document.getElementById('projectsGrid'); grid.innerHTML = '<div class="small">Loading projects‚Ä¶</div>';
    try{
      const repos = await fetchAllGithubRepos('barbrickdesign', 100, 20);
      if(!repos || repos.length===0){ grid.innerHTML = '<div class="small">No projects found.</div>'; document.getElementById('projectsTotal').textContent='$0'; return; }
      grid.innerHTML=''; let total=0;
      repos.forEach(repo=>{
        const created = repo.created_at ? new Date(repo.created_at).toLocaleString() : '‚Äî';
        const updated = repo.updated_at ? new Date(repo.updated_at).toLocaleString() : '‚Äî';
        const usd = Math.max(1, (repo.stargazers_count||0) * STARS_USD_MULT);
        total += usd;
        const site = `https://barbrickdesign.github.io/${repo.name}/index.html`;
        const div = document.createElement('div'); div.className = 'project';
        div.innerHTML = `<div style="flex:1"><div style="font-weight:800">${repo.name}</div><div class="small">${repo.description || 'No description'}</div><div class="timestamp">Created: ${created} ‚Ä¢ Updated: ${updated}</div><div class="links" style="margin-top:6px"><a class="btn ghost" href="${repo.html_url}" target="_blank">Repo</a><a class="btn ghost" href="${site}" target="_blank">Site</a></div></div><div style="text-align:right"><div class="value-pill">$${Number(usd).toLocaleString()}</div></div>`;
        grid.appendChild(div);
      });
      document.getElementById('projectsTotal').textContent = '$' + Number(total).toLocaleString();
      logDebug('projects loaded');
    }catch(e){ logDebug('renderProjects error', e); grid.innerHTML = '<div class="small">Failed to load projects.</div>'; }
  }

  // Scanning
  async function scanAllHoldingsAndHistoryImproved(){
    setStatus('Starting scan...','info');
    try{
      if(!wallet){ setStatus('Connect wallet first','warn'); logDebug('scan aborted: no wallet'); return; }
      const owner = safePubkey(wallet); if(!owner){ setStatus('Invalid wallet','error'); logDebug('invalid wallet', wallet); return; }

      logDebug('scan: fetching token accounts for', owner.toBase58());
      const parsedAccounts = await fetchParsedTokenAccountsOwnerSafe(owner);
      logDebug('token accounts count', parsedAccounts.length);

      const empty = []; const mintMap = {};
      parsedAccounts.forEach(acc=>{
        try{
          const info = acc.account?.data?.parsed?.info || acc.account?.data || acc;
          const ui = Number(info?.tokenAmount?.uiAmount || info?.tokenAmount?.uiAmountString || 0);
          const mint = info?.mint || acc.mint || null;
          const pub = (acc.pubkey && acc.pubkey.toString) ? acc.pubkey.toString() : String(acc.pubkey || acc.pubkey);
          if(ui === 0) empty.push({ pubkey: pub, mint });
          else if(mint) mintMap[mint] = (mintMap[mint] || 0) + ui;
        }catch(e){ logDebug('parse token account error', e, acc); }
      });

      const holdingsArr = Object.keys(mintMap).map(m => ({ mint: m, amount: mintMap[m] }));
      emptyTokenAccounts = empty; holdings = holdingsArr;
      document.getElementById('emptyCount')?.textContent = String(empty.length);
      const est = empty.length * RENT_PER_EMPTY_ACCOUNT_SOL;
      document.getElementById('refundEstimateBig').textContent = toSol(est) + ' SOL';

      const hp = document.getElementById('holdingsPanel'); hp.innerHTML = '';
      if(holdingsArr.length === 0) hp.innerHTML = '<div class="small">No token holdings found.</div>';
      else{ const list=document.createElement('div'); list.className='list'; holdingsArr.forEach(h=>{ const item=document.createElement('div'); item.className='project'; item.innerHTML = `<div style="flex:1"><div class="mono">${h.mint}</div><div class="small">Balance: ${h.amount}</div></div>`; list.appendChild(item); }); hp.appendChild(list); }

      logDebug('scan: fetching parsed transactions');
      const parsedTxs = await fetchParsedTxsOwnerSafe(owner);
      logDebug('parsed txs count', parsedTxs.length);

      const flows = analyzeTransactionsForFlowsUnified({ source:'rpc', txs: parsedTxs });
      renderCounterpartySummary(flows);

      setStatus('Scan complete','success');
      logDebug('scan finished', { tokenRes:{ empty: empty.length, holdings: holdingsArr.length }, txCount: parsedTxs.length, flowsLength: flows.length });
      return { empty, holdings: holdingsArr, transactions: parsedTxs };
    }catch(e){ logDebug('scanAll error', e && (e.stack||e.message||e)); setStatus('Scan failed ‚Äî see debug log','error'); return { empty:[], holdings:[], transactions:[] }; }
  }

  function analyzeTransactionsForFlowsUnified(raw){
    if(!wallet) return [];
    const our = safePubkey(wallet).toBase58();
    const flows = {}; const txs = raw.txs || [];
    txs.forEach(tx=>{
      try{
        const message = tx.transaction?.message; if(!message) return;
        const instrs = message.instructions || [];
        instrs.forEach(ins=>{
          if(ins.parsed && ins.parsed.type === 'transfer' && ins.parsed.info){
            const from = ins.parsed.info.source || ins.parsed.info.from;
            const to = ins.parsed.info.destination || ins.parsed.info.to;
            const lam = Number(ins.parsed.info.lamports || 0);
            if(from === our){ flows[to] = flows[to] || { in:0, out:0 }; flows[to].out += lam; }
            if(to === our){ flows[from] = flows[from] || { in:0, out:0 }; flows[from].in += lam; }
          }
        });
      }catch(e){ logDebug('analyze tx error', e); }
    });
    return Object.keys(flows).map(addr => { const inLam = flows[addr].in || 0, outLam = flows[addr].out || 0; return { addr, inSol:(inLam/solanaWeb3.LAMPORTS_PER_SOL).toFixed(5), outSol:(outLam/solanaWeb3.LAMPORTS_PER_SOL).toFixed(5), netOutFromUs:((outLam-inLam)/solanaWeb3.LAMPORTS_PER_SOL).toFixed(5) }; }).sort((a,b)=> Number(b.netOutFromUs)-Number(a.netOutFromUs));
  }

  function renderCounterpartySummary(summary){
    const panel = document.getElementById('counterpartyPanel'); panel.innerHTML='';
    if(!summary || summary.length === 0){ panel.innerHTML = '<div class="small">No recent SOL flows found for this wallet.</div>'; return; }
    const list = document.createElement('div'); list.className='list';
    summary.slice(0,10).forEach(s=>{ const item=document.createElement('div'); item.className='project'; item.innerHTML = `<div style="flex:1"><div class="mono">${s.addr}</div><div class="small">net out: ${s.netOutFromUs} SOL ‚Ä¢ out ${s.outSol} / in ${s.inSol}</div></div><div><button class="btn" onclick="window.open('https://explorer.solana.com/address/${s.addr}','_blank')">Explorer</button></div>`; list.appendChild(item); });
    panel.appendChild(list);
  }

  // Close and export wiring
  document.getElementById('scanBtn').addEventListener('click', ()=> scanAllHoldingsAndHistoryImproved().catch(e=>logDebug('scan click error', e)));
  document.getElementById('exportReport').addEventListener('click', ()=>{ const report = { when:new Date().toISOString(), wallet: wallet? (wallet.toBase58?wallet.toBase58():String(wallet)) : null, holdings, emptyTokenAccounts, feed: sessionFeed }; const blob = new Blob([JSON.stringify(report,null,2)], { type:'application/json' }); const a=document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `recovery-report-${Date.now()}.json`; a.click(); setStatus('Recovery report exported','success'); });

  document.getElementById('recoverBtn').addEventListener('click', async ()=>{
    try{
      if(!wallet){ setStatus('Connect wallet first','warn'); return; }
      if(!emptyTokenAccounts || emptyTokenAccounts.length===0){ setStatus('No empty accounts to close','warn'); return; }
      if(!confirm(`Close ${emptyTokenAccounts.length} empty account(s)? Each requires wallet approval.`)) return;
      setStatus('Preparing close transactions...','info');
      for(const acc of emptyTokenAccounts){
        const tx = new solanaWeb3.Transaction().add(splToken.createCloseAccountInstruction(new solanaWeb3.PublicKey(acc.pubkey), wallet, wallet, []));
        tx.feePayer = wallet; tx.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
        const provider = window.solana;
        if(!provider) throw new Error('No provider');
        if(typeof provider.signAndSendTransaction === 'function'){ const res = await provider.signAndSendTransaction(tx); const sig = res.signature || res; await connection.confirmTransaction(sig,'confirmed'); sessionFeed.unshift({ action:'close', pubkey:acc.pubkey, sig, time:new Date().toISOString() }); }
        else if(typeof provider.signTransaction === 'function'){ const signed = await provider.signTransaction(tx); const raw = signed.serialize(); const id = await connection.sendRawTransaction(raw); await connection.confirmTransaction(id,'confirmed'); sessionFeed.unshift({ action:'close', pubkey:acc.pubkey, sig:id, time:new Date().toISOString() }); }
        else throw new Error('Provider cannot sign');
        await new Promise(r=>setTimeout(r,200));
      }
      setStatus('Close finished','success');
      await scanAllHoldingsAndHistoryImproved();
    }catch(e){ logDebug('recover error', e); setStatus('Close failed','error'); }
  });

  // Projects init
  (async function init(){ try{ await renderProjects(); logDebug('projects loaded'); }catch(e){ logDebug('init error', e); } })();

  </script>
</body>
