<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>BarbrickDesign ‚Äî Claim Your SOL</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description" content="Solana: Close unused SPL token accounts, reclaim rent, export recovery report, prepare manual sells (user-approved)." />
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <style>
    :root{
      --bg:#0a0c11; --panel:#0f131a; --muted:#a8b3c7; --text:#eaf1fb;
      --accent:#66fcf1; --good:#3be477; --warn:#fbbf24; --bad:#ff6b6b;
      --stroke:rgba(255,255,255,0.12);
    }
    *{box-sizing:border-box}
    html,body{margin:0;height:100%;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:radial-gradient(1200px 600px at 20% -20%, rgba(102,252,241,0.06), transparent),var(--bg);color:var(--text)}
    a{color:var(--accent);text-decoration:none}
    .wrap{max-width:1100px;margin:0 auto;padding:16px}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .card{background:var(--panel);border:1px solid var(--stroke);border-radius:12px;padding:14px}
    .btn{background:#121827;color:var(--text);border:1px solid #223149;padding:10px 12px;border-radius:10px;cursor:pointer;font-weight:700}
    .btn.ghost{background:transparent;border-color:var(--stroke)}
    .btn.primary{background:linear-gradient(135deg,#121a2b,#172238)}
    .mono{font-family:ui-monospace,Menlo,Consolas}
    .small{font-size:13px;color:var(--muted)}
    .title{font-size:20px;font-weight:800}
    header{display:flex;flex-direction:column;gap:12px}
    .header-row{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
    .brand{display:flex;gap:12px;align-items:center}
    .glyph{width:40px;height:40px;border-radius:8px;background:conic-gradient(from 200deg,var(--accent),#9b7bff);box-shadow:0 6px 30px rgba(102,252,241,0.08)}
    .wallet-status{padding:6px 10px;border-radius:10px;background:transparent;color:var(--muted);font-size:13px}
    @media(min-width:900px){ header{flex-direction:row} }
    .grid{display:grid;gap:12px}
    @media(min-width:980px){ .grid.two {grid-template-columns:1.4fr .7fr} }
    .stats{display:grid;gap:10px}
    @media(min-width:650px){ .stats{grid-template-columns:repeat(3,1fr)} }
    #debugPanel{position:fixed;bottom:0;left:0;width:100%;max-height:220px;overflow:auto;background:#081018;border-top:1px solid #222;font-family:ui-monospace,Menlo,Consolas;color:#9bd;padding:8px;z-index:99999}
    @media(max-width:600px){ #debugPanel{font-size:11px} }
    .notice{padding:10px;border-radius:10px;background:linear-gradient(180deg,rgba(102,252,241,0.03),transparent);border:1px solid var(--stroke);font-size:13px}
    /* Compact mobile-friendly layout for header controls */
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  </style>

  <!-- libs (order matters) -->
  <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.8/lib/index.iife.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/spl-token@0.3.11/dist/browser/spl-token.min.js"></script>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="header-row">
        <div class="brand">
          <div class="glyph" aria-hidden="true"></div>
          <div>
            <div class="title mono">BarbrickDesign</div>
            <div class="small">Solana Blockchain holds your SOL ‚Äî Claim it Back!</div>
          </div>
        </div>

        <div class="controls" role="toolbar" aria-label="Primary actions">
          <button id="connectBtn" class="btn primary">Connect Wallet</button>
          <button id="openInWalletApp" class="btn ghost" style="display:none">Open in Wallet App</button>
          <span id="walletStatus" class="wallet-status mono">Wallet: not detected</span>
          <a class="btn ghost" href="https://github.com/barbrickdesign" target="_blank" rel="noopener">GitHub</a>
        </div>
      </div>

      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
        <div id="status" class="small">Close unused token accounts to reclaim SOL rent fees safely and securely.</div>
        <div id="refPreview" class="small mono" style="opacity:.85">‚Äî</div>
      </div>
    </header>

    <main style="margin-top:12px">
      <section class="card">
        <div class="title">Solana Blockchain holds your SOL ‚Äî Claim it Back!</div>
        <div class="small" style="margin-top:8px">
          The Solana network charges rent for unused SPL token accounts. If you sold tokens but left accounts open, their rent stays locked. This tool helps you scan, safely close empty accounts, prepare sell instructions for small leftover balances (user-approved), and export a recovery report.
        </div>
      </section>

      <div class="grid two" style="margin-top:12px">
        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:12px">
            <div>
              <div class="small">Connected wallet</div>
              <div id="walletLabel" class="mono" style="font-weight:700">‚Äî</div>
            </div>
            <div style="text-align:right">
              <div class="small">Estimated refund</div>
              <div id="refundEstimateBig" class="big">0.00000 SOL</div>
            </div>
          </div>

          <div style="margin-top:12px" class="row">
            <button id="scanBtn" class="btn">Scan & Analyze</button>
            <button id="recoverBtn" class="btn ghost">Close Empty Accounts</button>
            <button id="prepareSellBtn" class="btn ghost">Prepare Manual Sells</button>
          </div>

          <div style="margin-top:12px" class="row">
            <input id="refAddress" class="btn mono" style="flex:1;background:transparent;border-radius:10px" placeholder="Optional referrer wallet (?ref=)" />
            <label class="small row" style="gap:8px;align-items:center">
              <input id="donationToggle" type="checkbox" checked />
              <span class="small">Include 5% support</span>
            </label>
          </div>

          <hr style="border:none;height:1px;background:var(--stroke);margin:12px 0" />

          <div class="stats">
            <div class="stat">
              <div class="small">Empty accounts</div>
              <div id="emptyCount" class="big">0</div>
            </div>
            <div class="stat">
              <div class="small">Estimated refund</div>
              <div id="refundEstimate" class="big">0.00000 SOL</div>
            </div>
            <div class="stat">
              <div class="small">Session actions</div>
              <div id="sessionActions" class="big">0</div>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="small" style="font-weight:800;margin-bottom:8px">Holdings & Recovery Assist</div>

          <div id="holdingsPanel" class="small" style="max-height:320px;overflow:auto">
            <!-- populated by JS: token list, small-balance bucket, manual sell queue -->
            <div class="notice">Connect a wallet then run Scan & Analyze to list holdings, empty accounts, and suggested small-balance sells (manual approval required).</div>
          </div>

          <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap">
            <button id="exportReport" class="btn ghost">Export Recovery Report</button>
            <button id="copySummary" class="btn ghost">Copy Summary</button>
          </div>
        </div>
      </div>

      <section style="margin-top:12px" class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="small" style="font-weight:800">Counterparty Flow (top receivers)</div>
          <div class="small">Helps you see where SOL moved (best-effort; Solscan & RPC)</div>
        </div>
        <div id="counterpartyPanel" style="margin-top:8px"></div>
      </section>

      <section style="margin-top:12px" class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="small" style="font-weight:800">Session Feed</div>
          <div class="small">Recent actions</div>
        </div>
        <div id="feed" style="margin-top:8px;max-height:200px;overflow:auto"></div>
      </section>
    </main>

    <footer style="margin-top:12px" class="small">
      ¬© BarbrickDesign 2025 ¬∑ Built with care ‚Äî all actions require your explicit wallet approval.
    </footer>
  </div>

  <!-- Debug panel -->
  <div id="debugPanel">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <strong>üîç Debug Log</strong>
      <div style="display:flex;gap:8px">
        <button id="dbgHide" class="btn ghost small">Hide</button>
        <button id="dbgClear" class="btn ghost small">Clear</button>
      </div>
    </div>
    <div id="debugLog" style="margin-top:8px;white-space:pre-wrap;max-height:160px;overflow:auto"></div>
  </div>

  <script>
    // helper logging UI
    function logDebug(...args){
      const el = document.getElementById('debugLog');
      const line = document.createElement('div');
      line.textContent = `[${new Date().toLocaleTimeString()}] ` + args.map(a => (typeof a==='object'?JSON.stringify(a):String(a))).join(' ');
      el.appendChild(line);
      el.scrollTop = el.scrollHeight;
      console.log(...args);
    }
    document.getElementById('dbgClear').addEventListener('click', ()=> document.getElementById('debugLog').innerHTML = '');
    document.getElementById('dbgHide').addEventListener('click', (e)=>{
      const d = document.getElementById('debugLog');
      const hidden = d.style.display === 'none';
      d.style.display = hidden ? 'block' : 'none';
      e.target.textContent = hidden ? 'Hide' : 'Show';
    });

    // state & constants
    const connection = new solanaWeb3.Connection('https://api.mainnet-beta.solana.com','confirmed');
    const RENT_PER_EMPTY_ACCOUNT_SOL = 0.00204;
    const DONATION_PCT = 0.05;
    const FEE_WALLET = new solanaWeb3.PublicKey('5hSWosj58ki4A6hSfQrvteQU5QvyCWmhHn4AuqgaQzqr');

    let wallet = null; // solanaWeb3.PublicKey
    let holdings = []; // [{mint, amount, meta?}]
    let emptyTokenAccounts = [];
    let sessionFeed = [];
    let sessionActions = 0;

    // small utilities
    function setStatus(msg, kind='info'){ const el=document.getElementById('status'); if(!el) return; el.textContent=msg; el.style.color = kind==='error'? 'var(--bad)' : kind==='warn'? 'var(--warn)' : kind==='success'? 'var(--good)' : 'var(--muted)'; }
    function shorten(s){ return s ? (s.slice(0,4)+'...'+s.slice(-4)) : '‚Äî'; }
    function toSol(n){ return (Math.round(n*100000)/100000).toFixed(5); }
    function normPubkey(x){ if(!x) return null; if(x instanceof solanaWeb3.PublicKey) return x; if(x.publicKey && x.publicKey instanceof solanaWeb3.PublicKey) return x.publicKey; try{return new solanaWeb3.PublicKey(x);}catch{return null;} }

    // tolerant provider getter and poller
    function getProviderTolerant(){ if(window.solana) return window.solana; return null; }
    async function waitForProvider(timeoutMs=3000, intervalMs=150){
      const start = Date.now();
      while(Date.now()-start < timeoutMs){
        const p = getProviderTolerant();
        if(p) return p;
        await new Promise(r=>setTimeout(r,intervalMs));
      }
      return null;
    }

    // mobile deep link (user gesture required)
    function buildPhantomDeepLink(){
      const appUrl = encodeURIComponent(location.origin);
      const redirect = encodeURIComponent(location.href.replace(location.search || '', '') + '?from_phantom=1');
      return `https://phantom.app/ul/v1/connect?app_url=${appUrl}&redirect_url=${redirect}`;
    }
    function promptOpenInWalletApp(){
      try{ localStorage.setItem('awaiting_wallet','1'); }catch(e){ logDebug('localStorage failed', e); }
      const link = buildPhantomDeepLink();
      logDebug('Opening deep link', link);
      // prefer navigation (works better on some stacks)
      try{ location.href = link; }catch(e){ window.open(link,'_blank'); }
      setStatus('Opening wallet app... approve connect then return.', 'warn');
    }

    // Connect + sign & verify flow (robust)
    async function connectAndVerify(){
      setStatus('Attempting wallet connect‚Ä¶');
      logDebug('connect start, mobile?', /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent));
      const provider = await waitForProvider(1500,120) || getProviderTolerant();
      if(!provider){
        if(/Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent)) { promptOpenInWalletApp(); return; }
        setStatus('No wallet detected. Install Phantom or enable extension.', 'warn'); return;
      }

      try{
        logDebug('provider.connect()');
        const resp = await provider.connect({ onlyIfTrusted:false });
        wallet = (resp && resp.publicKey) ? resp.publicKey : (provider.publicKey || null);
        if(!wallet || !wallet.toBase58) throw new Error('No publicKey returned');
        document.getElementById('walletLabel').textContent = shorten(wallet.toBase58());
        document.getElementById('walletStatus').textContent = 'Wallet: connected';
        logDebug('connected', wallet.toBase58());

        // sign-in message
        const nonce = Math.floor(Math.random()*1e9).toString();
        const ts = Date.now();
        const message = `BarbrickDesign sign-in\nnonce:${nonce}\nts:${ts}\naddress:${wallet.toBase58()}`;
        const enc = new TextEncoder();
        const msgBytes = enc.encode(message);

        setStatus('Requesting signature from wallet‚Ä¶');
        logDebug('requesting signMessage');
        let signed = null;
        if(typeof provider.signMessage === 'function'){
          try{ signed = await provider.signMessage(msgBytes,'utf8'); } catch(e){
            // fallback: provider.request
            signed = await provider.request?.({ method:'signMessage', params:{ message:Array.from(msgBytes) } });
          }
        } else if(typeof provider.request === 'function'){
          signed = await provider.request({ method:'signMessage', params:{ message:Array.from(msgBytes) } });
        } else throw new Error('Wallet doesn\'t support signMessage');

        // normalize signature
        let sigBytes = null;
        if(signed && signed.signature) sigBytes = signed.signature;
        else if(signed && signed.length) sigBytes = signed;
        else if(Array.isArray(signed)) sigBytes = Uint8Array.from(signed);
        if(!sigBytes) throw new Error('No signature returned');

        const sigBuf = sigBytes instanceof Uint8Array ? sigBytes : Uint8Array.from(sigBytes);
        const pubBytes = wallet.toBytes ? wallet.toBytes() : new solanaWeb3.PublicKey(wallet).toBytes();
        const ok = nacl.sign.detached.verify(msgBytes, sigBuf, pubBytes);

        logDebug('signature verified?', ok);
        if(!ok){ setStatus('Signature verification failed.', 'error'); wallet=null; document.getElementById('walletLabel').textContent='‚Äî'; return; }

        setStatus('Wallet connected and verified', 'success');
        await scanAllHoldingsAndHistoryImproved();
        await checkGateAccess();
      } catch(err){
        logDebug('connectAndVerify error', err);
        setStatus('Connection or verification failed.', 'error');
        wallet = null;
        document.getElementById('walletLabel').textContent='‚Äî';
        document.getElementById('walletStatus').textContent='Wallet: not detected';
      }
    }

    // Auto-reconnect after mobile deep-link return
    window.addEventListener('load', async ()=>{
      try{
        const params = new URLSearchParams(location.search);
        const awaiting = localStorage.getItem('awaiting_wallet');
        if(params.get('from_phantom')==='1' || awaiting==='1'){
          logDebug('Returned from wallet, waiting for provider...');
          const prov = await waitForProvider(6000,200);
          if(prov){
            try{ localStorage.removeItem('awaiting_wallet'); }catch(_){}
            await connectAndVerify();
            if(params.get('from_phantom')==='1'){ const clean = location.href.replace(/[?&]from_phantom=1/,''); history.replaceState(null,'',clean); }
          } else {
            setStatus('Returned from wallet but provider not injected. Open site in wallet browser and press Connect.', 'warn');
          }
        }
      }catch(e){ logDebug('auto reconnect error', e); }
    });

    // Scan token accounts (parsed + fallback)
    async function scanTokenAccounts(){
      const pk = normPubkey(wallet) || normPubkey(getProviderTolerant()?.publicKey);
      if(!pk){ setStatus('Connect wallet first.', 'warn'); return { empty:[], holdings:[] }; }
      setStatus('Scanning token accounts and holdings...');
      try{
        let res;
        try{ res = await connection.getParsedTokenAccountsByOwner(pk,{ programId: splToken.TOKEN_PROGRAM_ID }); }
        catch(e){
          logDebug('getParsedTokenAccountsByOwner failed, fallback', e);
          const raw = await connection.getTokenAccountsByOwner(pk,{ programId: splToken.TOKEN_PROGRAM_ID });
          const parsedFallback = raw.value.map(v=>({ pubkey: v.pubkey.toString(), account:{ data:{ parsed:{ info:{ tokenAmount:{ uiAmount:0 }, mint:'unknown' } } } } }));
          res = { value: parsedFallback };
        }
        const parsed = res.value || [];
        const empty = []; const map = {};
        parsed.forEach(acc=>{
          const info = acc.account && acc.account.data && acc.account.data.parsed && acc.account.data.parsed.info;
          const ui = Number(info?.tokenAmount?.uiAmount || 0);
          const mint = info?.mint || null;
          const pub = acc.pubkey?.toString ? acc.pubkey.toString() : String(acc.pubkey);
          if(ui===0) empty.push({ pubkey: pub, mint });
          else if(mint) map[mint] = (map[mint]||0) + ui;
        });
        const holdingsArr = Object.keys(map).map(m=>({ mint:m, amount:map[m] }));
        emptyTokenAccounts = empty; holdings = holdingsArr;
        document.getElementById('emptyCount').textContent = String(empty.length);
        const est = empty.length * RENT_PER_EMPTY_ACCOUNT_SOL;
        document.getElementById('refundEstimate').textContent = toSol(est) + ' SOL';
        document.getElementById('refundEstimateBig').textContent = toSol(est) + ' SOL';
        // populate holdings panel
        const hp = document.getElementById('holdingsPanel'); hp.innerHTML = '';
        if(holdingsArr.length===0){
          hp.innerHTML = `<div class="notice">No token holdings found. If you expect tokens, try reconnecting or use a different RPC.</div>`;
        } else {
          const ul = document.createElement('div'); ul.className='list';
          holdingsArr.forEach(h=>{
            const item = document.createElement('div'); item.className='item';
            item.innerHTML = `<div><div class="mono">${h.mint}</div><div class="small">Balance: ${h.amount}</div></div><div><button class="btn ghost small" data-mint="${h.mint}">View</button></div>`;
            ul.appendChild(item);
          });
          hp.appendChild(ul);
        }
        setStatus(`Scan complete. ${empty.length} empty account(s).`);
        logDebug('scanTokenAccounts', { emptyCount: empty.length, holdingsCount: holdingsArr.length });
        return { empty, holdings: holdingsArr };
      }catch(e){
        logDebug('scan error', e);
        setStatus('Scan failed. Try again.', 'error');
        return { empty:[], holdings:[] };
      }
    }

    // RPC robust helpers
    async function retry(fn, attempts=3, delay=300){
      let last;
      for(let i=0;i<attempts;i++){
        try{return await fn();}
        catch(e){ last=e; await new Promise(r=>setTimeout(r,delay*(i+1))); }
      }
      throw last;
    }

    async function fetchTransactionsForWalletRobust({rpcLimit=200}={}){
      const pk = normPubkey(wallet) || normPubkey(getProviderTolerant()?.publicKey);
      if(!pk){ logDebug('no pubkey for tx fetch'); return {source:'none',txs:[]}; }
      try{
        setStatus('Fetching signatures via RPC...');
        const sigInfos = await retry(()=>connection.getSignaturesForAddress(pk,{limit:rpcLimit}),3,300);
        if(!Array.isArray(sigInfos) || sigInfos.length===0){ logDebug('no signatures'); return {source:'rpc',txs:[]}; }
        const sigs = sigInfos.map(s=>s.signature);
        const parsed = [];
        const batch = 20;
        for(let i=0;i<sigs.length;i+=batch){
          const chunk = sigs.slice(i,i+batch);
          const resolved = await Promise.all(chunk.map(sig=>retry(()=>connection.getParsedTransaction(sig,'confirmed'),2,200).catch(e=>{ logDebug('tx parse fail',sig,e); return null })));
          parsed.push(...resolved.filter(Boolean));
          await new Promise(r=>setTimeout(r,150));
        }
        logDebug('RPC parsed txs', parsed.length);
        return { source:'rpc', txs: parsed };
      }catch(e){ logDebug('fetchTransactionsForWalletRobust failed', e); return {source:'none', txs:[]}; }
    }

    async function fetchTransactionsForWallet({solscanPages=2,solscanLimit=50,rpcLimit=200}={}){
      const pk = normPubkey(wallet) || normPubkey(getProviderTolerant()?.publicKey);
      if(!pk) return {source:'none',txs:[]};
      const addr = pk.toBase58();
      try{
        const all=[];
        for(let p=0;p<solscanPages;p++){
          const offset=p*solscanLimit;
          const url=`https://public-api.solscan.io/account/transactions?address=${addr}&limit=${solscanLimit}&offset=${offset}`;
          logDebug('solscan',url);
          const r=await fetch(url);
          if(!r.ok){ logDebug('solscan non-ok',r.status); throw new Error('solscan fail'); }
          const j=await r.json();
          if(!Array.isArray(j)||j.length===0) break;
          all.push(...j);
          if(j.length<solscanLimit) break;
          await new Promise(r=>setTimeout(r,250));
        }
        if(all.length>0){ logDebug('solscan txs',all.length); return {source:'solscan',txs:all}; }
      }catch(e){ logDebug('solscan failed',e); }
      return fetchTransactionsForWalletRobust({rpcLimit});
    }

    function analyzeTransactionsForFlowsUnified(raw){
      if(!wallet) return [];
      const our = normPubkey(wallet).toBase58();
      const flows = {};
      const txs = raw.txs||[];
      if(raw.source==='solscan'){
        txs.forEach(tx=>{
          const native = tx.nativeTransfers || tx.nativeTransfer || tx.native || [];
          native.forEach(nt=>{
            const from=nt.from, to=nt.to, lam = Math.round(Number(nt.amount||0)*solanaWeb3.LAMPORTS_PER_SOL);
            if(from===our){ flows[to]=flows[to]||{in:0,out:0}; flows[to].out+=lam; }
            if(to===our){ flows[from]=flows[from]||{in:0,out:0}; flows[from].in+=lam; }
          });
        });
      } else {
        txs.forEach(tx=>{
          try{
            const message = tx.transaction?.message;
            if(!message) return;
            const instrs = message.instructions || [];
            instrs.forEach(ins=>{
              if(ins.parsed && ins.parsed.type==='transfer' && ins.parsed.info){
                const from=ins.parsed.info.source||ins.parsed.info.from;
                const to=ins.parsed.info.destination||ins.parsed.info.to;
                const lam = Number(ins.parsed.info.lamports || Math.round((ins.parsed.info.amount||0)*solanaWeb3.LAMPORTS_PER_SOL||0));
                if(from===our){ flows[to]=flows[to]||{in:0,out:0}; flows[to].out+=lam; }
                if(to===our){ flows[from]=flows[from]||{in:0,out:0}; flows[from].in+=lam; }
              }
            });
          }catch(e){ logDebug('analyze tx error',e); }
        });
      }
      const summary = Object.keys(flows).map(addr=>{
        const inLam = flows[addr].in||0, outLam = flows[addr].out||0;
        return { addr, inSol: (inLam/solanaWeb3.LAMPORTS_PER_SOL).toFixed(5), outSol: (outLam/solanaWeb3.LAMPORTS_PER_SOL).toFixed(5), netOutFromUs: ((outLam-inLam)/solanaWeb3.LAMPORTS_PER_SOL).toFixed(5) };
      }).sort((a,b)=> Number(b.netOutFromUs) - Number(a.netOutFromUs));
      return summary;
    }

    function renderCounterpartySummary(summary){
      const panel = document.getElementById('counterpartyPanel'); panel.innerHTML='';
      const card = document.createElement('div'); card.className='card';
      if(!summary||summary.length===0){ card.innerHTML = `<div class="small">No recent SOL flows found for this wallet.</div>`; panel.appendChild(card); return; }
      const list=document.createElement('div'); list.className='list';
      summary.slice(0,10).forEach(s=>{
        const item=document.createElement('div'); item.className='item';
        item.innerHTML = `<div><div class="mono">${shorten(s.addr)}</div><div class="small">net out: ${s.netOutFromUs} SOL ‚Äî out ${s.outSol} / in ${s.inSol}</div></div><div><button class="btn ghost small" onclick="window.open('https://explorer.solana.com/address/${s.addr}','_blank')">Explorer</button></div>`;
        list.appendChild(item);
      });
      card.appendChild(list); panel.appendChild(card);
    }

    // high-level scan
    async function scanAllHoldingsAndHistoryImproved(){
      setStatus('Starting scan...');
      const tokenRes = await scanTokenAccounts();
      if(tokenRes.holdings.length===0) setStatus('No tokens found.', 'warn');
      const txBundle = await fetchTransactionsForWallet({solscanPages:2,solscanLimit:50,rpcLimit:200});
      const flows = analyzeTransactionsForFlowsUnified(txBundle);
      renderCounterpartySummary(flows);
      logDebug('scan finished', { tokenRes, txCount: (txBundle.txs||[]).length, flowsLength: flows.length });
    }

    // close empty accounts (requires explicit user approve)
    async function closeEmptyAccounts(){
      if(!wallet){ setStatus('Connect wallet first.','warn'); return; }
      if(emptyTokenAccounts.length===0){ setStatus('No empty accounts to close.','warn'); return; }
      if(!confirm(`Close ${emptyTokenAccounts.length} empty account(s)? Each close requires wallet approval.`)) return;
      setStatus('Preparing close transactions. You will approve each in your wallet.');
      for(const acc of emptyTokenAccounts){
        const tx = new solanaWeb3.Transaction().add(
          splToken.createCloseAccountInstruction(new solanaWeb3.PublicKey(acc.pubkey), wallet, wallet, [])
        );
        tx.feePayer = wallet;
        tx.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
        try{
          const sig = await signSendWithProvider(tx);
          addFeedItem(wallet.toBase58(), 1, RENT_PER_EMPTY_ACCOUNT_SOL, sig, new Date());
          logDebug('closed', acc.pubkey, sig);
        }catch(e){ logDebug('close failed', acc.pubkey, e); setStatus('Some closes failed; check debug log', 'warn'); }
        await new Promise(r=>setTimeout(r,200));
      }
      await scanTokenAccounts();
      setStatus('Close process finished.', 'success');
    }

    // prepare manual sells: build list of small-token markets (UI only), requires user review & per-trx approval
    async function prepareManualSells(){
      if(holdings.length===0){ setStatus('No holdings to prepare sells for.', 'warn'); return; }
      // heuristics: value per token unknown client-side without price oracle; show low-balance tokens to review
      const panel = document.getElementById('holdingsPanel'); panel.innerHTML='';
      const list=document.createElement('div'); list.className='list';
      const smalls = holdings.filter(h => h.amount && Number(h.amount) < 1.5); // heuristic
      if(smalls.length===0){ panel.innerHTML='<div class="small">No obvious small-balance tokens found to prepare sells for.</div>'; return; }
      smalls.forEach(h=>{
        const item=document.createElement('div'); item.className='item';
        item.innerHTML = `<div><div class="mono">${h.mint}</div><div class="small">Balance: ${h.amount}</div></div><div><button class="btn small" data-mint="${h.mint}">Prepare Sell (Manual)</button></div>`;
        list.appendChild(item);
      });
      panel.appendChild(list);
      setStatus('Prepared manual sell proposals; each requires approval when you execute them.', 'info');
      // actual selling must be manual and user-approved; we do not auto-execute.
    }

    // provider signing helpers
    async function signSendWithProvider(tx){
      const provider = getProviderTolerant();
      if(!provider) throw new Error('No provider for signing');
      // try signAndSendTransaction, else signTransaction + sendRawTransaction
      if(typeof provider.signAndSendTransaction === 'function'){
        const signed = await provider.signAndSendTransaction(tx);
        const sig = signed.signature || signed;
        await connection.confirmTransaction(sig,'confirmed');
        return sig;
      } else if(typeof provider.signTransaction === 'function'){
        const st = await provider.signTransaction(tx);
        const raw = st.serialize();
        const id = await connection.sendRawTransaction(raw);
        await connection.confirmTransaction(id,'confirmed');
        return id;
      } else throw new Error('Provider has no signing method');
    }

    // wire UI
    document.getElementById('connectBtn').addEventListener('click', connectAndVerify);
    document.getElementById('openInWalletApp').addEventListener('click', promptOpenInWalletApp);
    document.getElementById('scanBtn').addEventListener('click', scanAllHoldingsAndHistoryImproved);
    document.getElementById('recoverBtn').addEventListener('click', closeEmptyAccounts);
    document.getElementById('prepareSellBtn').addEventListener('click', prepareManualSells);
    document.getElementById('exportReport').addEventListener('click', ()=>{
      const report = { when: new Date().toISOString(), wallet: wallet ? wallet.toBase58() : null, holdings, emptyTokenAccounts, sessionFeed };
      const blob = new Blob([JSON.stringify(report,null,2)],{type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download=`recovery-report-${Date.now()}.json`; a.click(); URL.revokeObjectURL(url);
      setStatus('Recovery report exported.', 'success');
    });

    // helper to populate repo listing (simple fallback)
    async function fetchAndRenderRepos(){
      const container = document.getElementById('repoGroups'); container.innerHTML='Loading‚Ä¶';
      try{
        const r = await fetch('https://api.github.com/users/barbrickdesign/repos?per_page=100');
        const list = await r.json();
        container.innerHTML='';
        list.sort((a,b)=> new Date(b.pushed_at)-new Date(a.pushed_at));
        list.forEach(repo=>{
          const row=document.createElement('div'); row.className='item';
          const root = `https://barbrickdesign.github.io/${repo.name}/`;
          row.innerHTML = `<div><div class="mono"><a href="${repo.html_url}" target="_blank">${repo.name}</a></div><div class="small">${repo.description||'No description'}</div></div><div><a class="btn ghost small" href="${repo.html_url}" target="_blank">Repo</a> <a class="btn small" href="${root}" target="_blank">View</a></div>`;
          container.appendChild(row);
        });
      }catch(e){ container.innerHTML='<div class="small">Failed to load projects</div>'; logDebug('repo fetch fail',e); }
    }
    fetchAndRenderRepos();
  </script>
</body>
