<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>BarbrickDesign — Claim Your SOL</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description" content="Close unused SPL accounts, reclaim rent, prepare manual sells (user-approved), export recovery reports, and support projects." />
  <style>
    :root{
      --bg:#0a0c11; --panel:#0f131a; --muted:#a8b3c7; --text:#eaf1fb;
      --accent:#66fcf1; --good:#3be477; --warn:#fbbf24; --bad:#ff6b6b;
      --stroke:rgba(255,255,255,0.12);
    }
    *{box-sizing:border-box}
    html,body{margin:0;height:100%;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:radial-gradient(1200px 600px at 20% -20%, rgba(102,252,241,0.06), transparent),var(--bg);color:var(--text)}
    a{color:var(--accent);text-decoration:none}
    .wrap{max-width:1200px;margin:0 auto;padding:16px}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .card{background:var(--panel);border:1px solid var(--stroke);border-radius:12px;padding:14px}
    .btn{background:#121827;color:var(--text);border:1px solid #223149;padding:10px 12px;border-radius:10px;cursor:pointer;font-weight:700}
    .btn.ghost{background:transparent;border-color:var(--stroke)}
    .btn.primary{background:linear-gradient(135deg,#121a2b,#172238)}
    .mono{font-family:ui-monospace,Menlo,Consolas}
    .small{font-size:13px;color:var(--muted)}
    .title{font-size:20px;font-weight:800}
    .big{font-size:28px;font-weight:800}
    header{display:flex;flex-direction:column;gap:12px}
    .header-row{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
    .brand{display:flex;gap:12px;align-items:center}
    .glyph{width:40px;height:40px;border-radius:8px;background:conic-gradient(from 200deg,var(--accent),#9b7bff);box-shadow:0 6px 30px rgba(102,252,241,0.08)}
    .wallet-status{padding:6px 10px;border-radius:10px;background:transparent;color:var(--muted);font-size:13px}
    @media(min-width:900px){ header{flex-direction:row} }
    .grid{display:grid;gap:12px}
    @media(min-width:980px){ .grid.two {grid-template-columns:1.4fr .7fr} }
    .stats{display:grid;gap:10px}
    @media(min-width:650px){ .stats{grid-template-columns:repeat(3,1fr)} }
    #debugPanel{position:fixed;bottom:0;left:0;width:100%;max-height:260px;overflow:auto;background:#081018;border-top:1px solid #222;font-family:ui-monospace,Menlo,Consolas;color:#9bd;padding:8px;z-index:99999}
    @media(max-width:600px){ #debugPanel{font-size:11px} }
    .notice{padding:10px;border-radius:10px;background:linear-gradient(180deg,rgba(102,252,241,0.03),transparent);border:1px solid var(--stroke);font-size:13px}
    .projects-grid{display:grid;gap:10px}
    @media(min-width:900px){ .projects-grid{grid-template-columns:repeat(2,1fr)} }
    .project{display:flex;justify-content:space-between;gap:8px;align-items:center;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
    .value-pill{padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);font-weight:700}
    .muted { color: var(--muted); font-size:13px; }
  </style>

  <!-- libs (order matters) -->
  <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.8/lib/index.iife.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/spl-token@0.3.11/dist/browser/spl-token.min.js"></script>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="header-row">
        <div class="brand">
          <div class="glyph" aria-hidden="true"></div>
          <div>
            <div class="title mono">BarbrickDesign</div>
            <div class="small">Claim your SOL — close unused SPL accounts and recover rent.</div>
          </div>
        </div>

        <div class="row" role="toolbar" aria-label="Primary actions">
          <button id="connectBtn" class="btn primary">Connect Wallet</button>
          <button id="openInWalletApp" class="btn ghost" style="display:none">Open in Wallet App</button>
          <span id="walletStatus" class="wallet-status mono">Wallet: not detected</span>
          <a class="btn ghost" href="https://github.com/barbrickdesign" target="_blank" rel="noopener">GitHub</a>
        </div>
      </div>

      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
        <div id="status" class="small">Close unused token accounts to reclaim SOL rent fees safely and securely.</div>
        <div id="refPreview" class="small mono" style="opacity:.85">—</div>
      </div>
    </header>

    <main style="margin-top:12px">
      <section class="card">
        <div class="title">Solana Blockchain holds your SOL — Claim it Back!</div>
        <div class="small" style="margin-top:8px">
          The Solana network charges rent for unused SPL token accounts. If you sold tokens but left accounts open, their rent stays locked.
          Scan your wallet, close empty accounts, prepare manual sells for low-value tokens (manual approval required), and export a recovery report. All on-chain actions require wallet approval.
        </div>
      </section>

      <div class="grid two" style="margin-top:12px">
        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:12px">
            <div>
              <div class="small">Connected wallet</div>
              <div id="walletLabel" class="mono big">—</div>
            </div>
            <div style="text-align:right">
              <div class="small">Estimated refund</div>
              <div id="refundEstimateBig" class="big">0.00000 SOL</div>
            </div>
          </div>

          <div style="margin-top:12px" class="row">
            <button id="scanBtn" class="btn">Scan & Analyze</button>
            <button id="recoverBtn" class="btn ghost">Close Empty Accounts</button>
            <button id="prepareSellBtn" class="btn ghost">Prepare Manual Sells</button>
          </div>

          <div style="margin-top:12px" class="row">
            <input id="refAddress" class="btn mono" style="flex:1;background:transparent;border-radius:10px" placeholder="Optional referrer wallet (?ref=)" />
            <label class="small row" style="gap:8px;align-items:center">
              <input id="donationToggle" type="checkbox" checked />
              <span class="small">Include 5% support</span>
            </label>
          </div>

          <hr style="border:none;height:1px;background:var(--stroke);margin:12px 0" />

          <div class="stats">
            <div class="card" style="text-align:center">
              <div class="small">Empty accounts</div>
              <div id="emptyCount" class="big">0</div>
            </div>
            <div class="card" style="text-align:center">
              <div class="small">Estimated refund</div>
              <div id="refundEstimate" class="big">0.00000 SOL</div>
            </div>
            <div class="card" style="text-align:center">
              <div class="small">Session actions</div>
              <div id="sessionActions" class="big">0</div>
            </div>
          </div>

          <div style="margin-top:10px;display:flex;gap:8px">
            <button id="exportReport" class="btn ghost">Export Recovery Report</button>
            <button id="copySummary" class="btn ghost">Copy Summary</button>
          </div>
        </div>

        <div class="card">
          <div class="small" style="font-weight:800;margin-bottom:8px">Holdings & Recovery Assist</div>
          <div id="holdingsPanel" class="small" style="max-height:360px;overflow:auto">
            <div class="notice">Connect a wallet then run Scan & Analyze to list holdings, empty accounts, and suggested manual sells (each sale requires your approval).</div>
          </div>
        </div>
      </div>

      <section class="card" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="small" style="font-weight:800">Income modules</div>
          <div class="small">Recover, mint, and contribute (token-gated)</div>
        </div>

        <div style="margin-top:10px" class="row">
          <div class="card" style="flex:1">
            <div style="font-weight:800">SOL Recovery Portal</div>
            <div class="small">Close empty SPL token accounts and reclaim rent in bulk with per-transaction approvals.</div>
            <div style="margin-top:8px"><button id="recoverInlineBtn" class="btn">Recover here</button> <a class="btn ghost" href="https://barbrickdesign.github.io/SOLRecovery/" target="_blank">Open</a></div>
          </div>

          <div class="card" style="flex:1">
            <div style="font-weight:800">NFT Minting Portal</div>
            <div class="small">Mint lore-infused sigils and configure creator splits.</div>
            <div style="margin-top:8px"><a class="btn ghost" href="https://barbrickdesign.github.io/NFTMint/" target="_blank">Open</a> <button id="mintSigil" class="btn ghost">Mint (demo)</button></div>
          </div>
        </div>
      </section>

      <section class="card" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="small" style="font-weight:800">Projects</div>
          <div class="small">Analyze repos, show estimated USD proxy value, and enable contributions for coin holders</div>
        </div>

        <div id="projectsArea" style="margin-top:10px">
          <div class="projects-grid" id="projectsGrid">
            <div class="notice small">Loading projects…</div>
          </div>
        </div>
      </section>

      <section class="card" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="small" style="font-weight:800">Counterparty Flow (top receivers)</div>
          <div class="small">Helps you see where SOL moved (best-effort; Solscan & RPC)</div>
        </div>
        <div id="counterpartyPanel" style="margin-top:8px"></div>
      </section>

      <section class="card" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="small" style="font-weight:800">Session Feed</div>
          <div class="small">Recent actions</div>
        </div>
        <div id="feed" style="margin-top:8px;max-height:200px;overflow:auto"></div>
      </section>
    </main>

    <footer style="margin-top:12px" class="small">
      © BarbrickDesign 2025 · All actions require explicit wallet approval.
    </footer>
  </div>

  <div id="debugPanel">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <strong>🔍 Debug Log</strong>
      <div style="display:flex;gap:8px">
        <button id="dbgHide" class="btn ghost small">Hide</button>
        <button id="dbgClear" class="btn ghost small">Clear</button>
      </div>
    </div>
    <div id="debugLog" style="margin-top:8px;white-space:pre-wrap;max-height:200px;overflow:auto"></div>
  </div>

  <script>
    /* ---------- debug --------- */
    function logDebug(...args){ const el=document.getElementById('debugLog'); const line=document.createElement('div'); line.textContent = `[${new Date().toLocaleTimeString()}] ` + args.map(a=> typeof a==='object' ? JSON.stringify(a) : String(a)).join(' '); el.appendChild(line); el.scrollTop = el.scrollHeight; console.log(...args); }
    document.getElementById('dbgClear').addEventListener('click', ()=> document.getElementById('debugLog').innerHTML='');
    document.getElementById('dbgHide').addEventListener('click',(e)=>{ const d=document.getElementById('debugLog'); const hidden=d.style.display==='none'; d.style.display = hidden ? 'block' : 'none'; e.target.textContent = hidden ? 'Hide' : 'Show'; });

    /* ---------- state & helpers ---------- */
    const connection = new solanaWeb3.Connection('https://api.mainnet-beta.solana.com','confirmed');
    const RENT_PER_EMPTY_ACCOUNT_SOL = 0.00204;
    const DONATION_PCT = 0.05;
    const FEE_WALLET = new solanaWeb3.PublicKey('5hSWosj58ki4A6hSfQrvteQU5QvyCWmhHn4AuqgaQzqr');

    let wallet = null;
    let holdings = [];
    let emptyTokenAccounts = [];
    let sessionFeed = [];

    function setStatus(msg, kind='info'){ const el=document.getElementById('status'); if(!el) return; el.textContent=msg; el.style.color = kind==='error' ? 'var(--bad)' : kind==='warn' ? 'var(--warn)' : kind==='success' ? 'var(--good)' : 'var(--muted)'; }
    function shorten(s){ return s ? (s.slice(0,4)+'...'+s.slice(-4)) : '—'; }
    function toSol(n){ return (Math.round(n*100000)/100000).toFixed(5); }
    function normPubkey(x){ if(!x) return null; if(x instanceof solanaWeb3.PublicKey) return x; if(x.publicKey && x.publicKey instanceof solanaWeb3.PublicKey) return x.publicKey; try{ return new solanaWeb3.PublicKey(x); }catch{return null;} }

    function getProviderTolerant(){ if(window.solana) return window.solana; return null; }
    async function waitForProvider(timeoutMs=3000, intervalMs=150){ const start=Date.now(); while(Date.now()-start < timeoutMs){ const p=getProviderTolerant(); if(p) return p; await new Promise(r=>setTimeout(r, intervalMs)); } return null; }

    /* ---------- mobile deep-link ---------- */
    function buildPhantomDeepLink(){ const appUrl=encodeURIComponent(location.origin); const redirect=encodeURIComponent(location.href.replace(location.search||'','') + '?from_phantom=1'); return `https://phantom.app/ul/v1/connect?app_url=${appUrl}&redirect_url=${redirect}`; }
    function promptOpenInWalletApp(){ try{ localStorage.setItem('awaiting_wallet','1'); }catch(e){ logDebug('LS failed', e) } const link = buildPhantomDeepLink(); logDebug('deep link', link); try{ location.href = link; }catch(e){ window.open(link,'_blank'); } setStatus('Opening wallet app... approve connect then return.', 'warn'); }

    /* ---------- connect + sign flow (kept compatible with your working script) ---------- */
    async function connectAndVerify(){
      setStatus('Attempting wallet connect…');
      logDebug('connect start; mobile?', /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent));
      const provider = await waitForProvider(1500,120) || getProviderTolerant();
      if(!provider){ if(/Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent)) { promptOpenInWalletApp(); return; } setStatus('No wallet detected. Install Phantom or enable extension.','warn'); return; }
      try{
        logDebug('provider.connect()'); const resp = await provider.connect({ onlyIfTrusted:false });
        wallet = (resp && resp.publicKey) ? resp.publicKey : (provider.publicKey || null);
        if(!wallet || !wallet.toBase58) throw new Error('No publicKey returned');
        document.getElementById('walletLabel').textContent = shorten(wallet.toBase58());
        document.getElementById('walletStatus').textContent = 'Wallet: connected';
        logDebug('connected', wallet.toBase58());

        const nonce = Math.floor(Math.random()*1e9).toString(); const ts = Date.now();
        const message = `BarbrickDesign sign-in\nnonce:${nonce}\nts:${ts}\naddress:${wallet.toBase58()}`;
        const enc = new TextEncoder(); const msgBytes = enc.encode(message);

        setStatus('Requesting signature from wallet…'); logDebug('requesting signMessage');
        let signed = null;
        if(typeof provider.signMessage === 'function'){ try{ signed = await provider.signMessage(msgBytes, 'utf8'); }catch(e){ signed = await provider.request?.({ method:'signMessage', params: { message: Array.from(msgBytes) } }); } }
        else if(typeof provider.request === 'function'){ signed = await provider.request({ method:'signMessage', params:{ message: Array.from(msgBytes) } }); }
        else throw new Error('Wallet does not support signMessage');

        let sigBytes = null;
        if(signed && signed.signature) sigBytes = signed.signature; else if(signed && signed.length) sigBytes = signed; else if(Array.isArray(signed)) sigBytes = Uint8Array.from(signed);
        if(!sigBytes) throw new Error('No signature returned');

        const sigBuf = sigBytes instanceof Uint8Array ? sigBytes : Uint8Array.from(sigBytes);
        const pubBytes = wallet.toBytes ? wallet.toBytes() : new solanaWeb3.PublicKey(wallet).toBytes();
        const ok = nacl.sign.detached.verify(msgBytes, sigBuf, pubBytes);
        logDebug('signature verified?', ok);
        if(!ok){ setStatus('Signature verification failed.','error'); wallet=null; document.getElementById('walletLabel').textContent='—'; return; }

        setStatus('Wallet connected and verified','success');
        await scanAllHoldingsAndHistoryImproved();
      }catch(err){ logDebug('connect error', err); setStatus('Connection or verification failed.','error'); wallet=null; document.getElementById('walletLabel').textContent='—'; document.getElementById('walletStatus').textContent='Wallet: not detected'; }
    }

    window.addEventListener('load', async ()=>{
      try{
        const params = new URLSearchParams(location.search); const awaiting = localStorage.getItem('awaiting_wallet');
        if(params.get('from_phantom')==='1' || awaiting==='1'){ logDebug('returned from wallet'); const prov = await waitForProvider(6000,200); if(prov){ try{ localStorage.removeItem('awaiting_wallet'); }catch(_){} await connectAndVerify(); if(params.get('from_phantom')==='1'){ const clean = location.href.replace(/[?&]from_phantom=1/,''); history.replaceState(null,'',clean); } } else setStatus('Returned from wallet but provider not injected. Open site in wallet browser and press Connect.','warn'); }
      }catch(e){ logDebug('auto reconnect error', e); }
    });

    /* ---------- scanner replacements (improved) ---------- */
    async function retry(fn, attempts=3, delay=300){ let last; for(let i=0;i<attempts;i++){ try{ return await fn(); } catch(e){ last=e; await new Promise(r=>setTimeout(r, delay*(i+1))); } } throw last; }
    function tryParseRawTokenAccount(raw){ try{ return { pubkey: raw.pubkey?.toString?raw.pubkey.toString():String(raw.pubkey), account: { data:{ parsed:{ info:{ tokenAmount:{ uiAmount:0 }, mint:'unknown' } } } } }; }catch(e){return null;} }

    async function scanTokenAccountsImproved(){
      const pk = normPubkey(wallet) || normPubkey(getProviderTolerant()?.publicKey);
      if(!pk){ setStatus('Connect wallet first.','warn'); return { empty:[], holdings:[] }; }
      setStatus('Scanning token accounts and holdings (improved)...');
      try{
        let res;
        try{ res = await retry(()=> connection.getParsedTokenAccountsByOwner(pk, { programId: splToken.TOKEN_PROGRAM_ID }), 2, 250); logDebug('parsed token accounts', res.value.length); }
        catch(errParsed){ logDebug('parsed fetch failed', errParsed); const raw = await retry(()=> connection.getTokenAccountsByOwner(pk, { programId: splToken.TOKEN_PROGRAM_ID }), 2, 300); res = { value: raw.value.map(v=>tryParseRawTokenAccount(v)).filter(Boolean) }; logDebug('fallback token accounts', res.value.length); }

        const parsed = res.value || []; const empty=[]; const map={};
        for(const acc of parsed){
          const info = acc.account && acc.account.data && acc.account.data.parsed && acc.account.data.parsed.info;
          const ui = Number(info?.tokenAmount?.uiAmount || 0);
          const mint = info?.mint || null;
          const pub = acc.pubkey?.toString?acc.pubkey.toString():String(acc.pubkey);
          if(ui===0) empty.push({ pubkey: pub, mint }); else if(mint) map[mint] = (map[mint]||0) + ui;
        }
        const holdingsArr = Object.keys(map).map(m=>({ mint:m, amount:map[m] }));
        emptyTokenAccounts = empty; holdings = holdingsArr;
        document.getElementById('emptyCount').textContent = String(empty.length);
        const est = empty.length * RENT_PER_EMPTY_ACCOUNT_SOL;
        document.getElementById('refundEstimate').textContent = toSol(est) + ' SOL';
        document.getElementById('refundEstimateBig').textContent = toSol(est) + ' SOL';

        const hp = document.getElementById('holdingsPanel'); hp.innerHTML = '';
        if(holdingsArr.length===0) hp.innerHTML = '<div class="notice">No token holdings found. If you expect tokens, try reconnecting or use a different RPC.</div>';
        else { const list=document.createElement('div'); list.className='list'; holdingsArr.forEach(h=>{ const it=document.createElement('div'); it.className='project'; it.innerHTML=`<div class="meta"><div class="mono">${h.mint}</div><div class="small">Balance: ${h.amount}</div></div><div><span class="value-pill muted">Est $0</span></div>`; list.appendChild(it); }); hp.appendChild(list); }

        if(holdingsArr.length===0) setStatus('No token holdings found in this wallet.','warn'); else setStatus(`Found ${holdingsArr.length} token mint(s).`);
        logDebug('scanTokenAccountsImproved result', { emptyCount: empty.length, holdingsCount: holdingsArr.length });
        return { empty, holdings: holdingsArr };
      } catch(e){ logDebug('scanTokenAccountsImproved failed', e); setStatus('Scan failed. Try again.','error'); return { empty:[], holdings:[] }; }
    }

    async function fetchTransactionsForWalletRobustImproved({ rpcLimit = 250, rpcAlt = 'https://rpc.ankr.com/solana' } = {}){
      const pk = normPubkey(wallet) || normPubkey(getProviderTolerant()?.publicKey);
      if(!pk){ logDebug('fetchTransactions: no pubkey'); return { source:'none', txs:[] }; }
      try{
        setStatus('Fetching signatures via RPC (primary)...');
        const sigInfos = await retry(()=> connection.getSignaturesForAddress(pk, { limit: rpcLimit }), 2, 350);
        if(!Array.isArray(sigInfos) || sigInfos.length === 0){ logDebug('primary RPC returned no signatures'); return { source:'rpc', txs: [] }; }
        const signatures = sigInfos.map(s=>s.signature); const parsed=[]; const batchSize=20;
        for(let i=0;i<signatures.length;i+=batchSize){
          const chunk = signatures.slice(i,i+batchSize);
          const resolved = await Promise.all(chunk.map(sig=> retry(()=> connection.getParsedTransaction(sig,'confirmed'), 2, 200).catch(e=>{ logDebug('getParsedTransaction fail', sig, e); return null; })));
          parsed.push(...resolved.filter(Boolean)); await new Promise(r=>setTimeout(r,150));
        }
        logDebug('primary RPC parsed txs', parsed.length); return { source:'rpc', txs: parsed };
      } catch(ePrimary){
        logDebug('primary RPC failed', ePrimary);
        try{
          setStatus('Primary RPC failed. Trying alternate RPC node...');
          const altConn = new solanaWeb3.Connection(rpcAlt, 'confirmed');
          const sigInfos = await retry(()=> altConn.getSignaturesForAddress(pk, { limit: rpcLimit }), 2, 400);
          if(!Array.isArray(sigInfos) || sigInfos.length === 0){ logDebug('alt RPC returned no signatures'); return { source:'alt-rpc', txs: [] }; }
          const signatures = sigInfos.map(s=>s.signature); const parsed=[]; const batchSize=20;
          for(let i=0;i<signatures.length;i+=batchSize){
            const chunk = signatures.slice(i,i+batchSize);
            const resolved = await Promise.all(chunk.map(sig=> retry(()=> altConn.getParsedTransaction(sig,'confirmed'), 2, 250).catch(e=>{ logDebug('alt getParsedTransaction fail', sig, e); return null; })));
            parsed.push(...resolved.filter(Boolean)); await new Promise(r=>setTimeout(r,150));
          }
          logDebug('alt RPC parsed txs', parsed.length); return { source:'alt-rpc', txs: parsed };
        } catch(eAlt){ logDebug('alternate RPC failed too', eAlt); setStatus('Failed to fetch transactions (RPC nodes failing).','error'); return { source:'none', txs: [] }; }
      }
    }

    async function fetchTransactionsForWallet({ solscanPages = 2, solscanLimit = 50, rpcLimit = 250 } = {}){
      const pk = normPubkey(wallet) || normPubkey(getProviderTolerant()?.publicKey);
      if(!pk) return { source:'none', txs:[] };
      const addr = pk.toBase58();
      try{
        const all=[]; for(let p=0;p<solscanPages;p++){ const offset=p*solscanLimit; const url=`https://public-api.solscan.io/account/transactions?address=${addr}&limit=${solscanLimit}&offset=${offset}`; logDebug('Solscan fetch', url); const r=await fetch(url); if(!r.ok){ logDebug('Solscan non-ok', r.status); throw new Error('Solscan non-ok '+r.status); } const j=await r.json(); if(!Array.isArray(j)||j.length===0) break; all.push(...j); if(j.length<solscanLimit) break; await new Promise(r=>setTimeout(r,250)); } logDebug('Solscan returned tx count', all.length); if(all.length>0) return { source:'solscan', txs: all };
      }catch(e){ logDebug('Solscan fetch failed; falling back to RPC', e); }
      return fetchTransactionsForWalletRobustImproved({ rpcLimit });
    }

    function analyzeTransactionsForFlowsUnified(raw){
      if(!wallet) return [];
      const our = normPubkey(wallet).toBase58(); const flows = {}; const txs = raw.txs || [];
      if(raw.source === 'solscan'){ txs.forEach(tx=>{ const native = tx.nativeTransfers || tx.nativeTransfer || tx.native || []; native.forEach(nt=>{ const from=nt.from, to=nt.to, lam=Math.round(Number(nt.amount||0)*solanaWeb3.LAMPORTS_PER_SOL); if(from===our){ flows[to]=flows[to]||{in:0,out:0}; flows[to].out+=lam; } if(to===our){ flows[from]=flows[from]||{in:0,out:0}; flows[from].in+=lam; } }); }); }
      else{ txs.forEach(tx=>{ try{ const message = tx.transaction?.message; if(!message) return; const instrs = message.instructions || []; instrs.forEach(ins=>{ if(ins.parsed && ins.parsed.type==='transfer' && ins.parsed.info){ const from = ins.parsed.info.source || ins.parsed.info.from; const to = ins.parsed.info.destination || ins.parsed.info.to; const lam = Number(ins.parsed.info.lamports || Math.round((ins.parsed.info.amount||0)*solanaWeb3.LAMPORTS_PER_SOL||0)); if(from===our){ flows[to]=flows[to]||{in:0,out:0}; flows[to].out+=lam; } if(to===our){ flows[from]=flows[from]||{in:0,out:0}; flows[from].in+=lam; } } }); }catch(e){ logDebug('analyze tx error', e); } }); }
      const summary = Object.keys(flows).map(addr=>{ const inLam = flows[addr].in||0, outLam=flows[addr].out||0; return { addr, inSol:(inLam/solanaWeb3.LAMPORTS_PER_SOL).toFixed(5), outSol:(outLam/solanaWeb3.LAMPORTS_PER_SOL).toFixed(5), netOutFromUs:((outLam-inLam)/solanaWeb3.LAMPORTS_PER_SOL).toFixed(5) }; }).sort((a,b)=> Number(b.netOutFromUs) - Number(a.netOutFromUs));
      return summary;
    }

    function renderCounterpartySummary(summary){
      const panel=document.getElementById('counterpartyPanel'); panel.innerHTML='';
      if(!summary || summary.length===0){ panel.innerHTML=`<div class="small">No recent SOL flows found for this wallet.</div>`; return; }
      const list=document.createElement('div'); list.className='list'; summary.slice(0,10).forEach(s=>{ const item=document.createElement('div'); item.className='project'; item.innerHTML=`<div class="meta"><div class="mono">${shorten(s.addr)}</div><div class="small">net out: ${s.netOutFromUs} SOL — out ${s.outSol} / in ${s.inSol}</div></div><div><button class="btn ghost small" onclick="window.open('https://explorer.solana.com/address/${s.addr}','_blank')">Explorer</button></div>`; list.appendChild(item); }); panel.appendChild(list);
    }

    /* ---------- projects UI and valuation via stars→USD proxy ---------- */
    const PROJECTS_JSON_URL = './projects.json'; // live pattern: try projects.json then fallback to GitHub listing
    const PROJECT_VALUE_PER_STAR_USD = 10; // heuristic mapping: 1 star ≈ $10 as a proxy (change when you have an oracle)

    async function loadProjectsList(){
      // first try local projects.json
      try{
        const r = await fetch(PROJECTS_JSON_URL);
        if(r.ok){
          const j = await r.json();
          if(Array.isArray(j) && j.length>0) return j;
        }
      }catch(e){ logDebug('projects.json fetch failed', e); }
      // fallback: fetch first 40 repos from GitHub user
      try{
        const r = await fetch('https://api.github.com/users/barbrickdesign/repos?per_page=100');
        if(r.ok){
          const repos = await r.json();
          return repos.map(repo => ({ name: repo.name, repo: repo.name, description: repo.description
