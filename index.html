<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>BarbrickDesign — Build, Recover, and Earn</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="BarbrickDesign — SOL recovery, token analysis, and token-gated LLM." />
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <style>
    :root{
      --bg:#0a0c11; --panel:#0f131a; --glass:rgba(255,255,255,0.06);
      --stroke:rgba(255,255,255,0.14); --text:#eaf1fb; --muted:#a8b3c7;
      --accent:#66fcf1; --good:#3be477; --warn:#fbbf24; --bad:#ff6b6b;
    }
    *{box-sizing:border-box}
    html,body{margin:0;height:100%;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;background:radial-gradient(1200px 600px at 20% -20%, rgba(102,252,241,0.06), transparent),var(--bg);color:var(--text)}
    a{color:var(--accent);text-decoration:none}
    .wrap{max-width:1200px;margin:0 auto;padding:16px}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .col{display:grid;gap:10px}
    .card{background:var(--panel);border:1px solid var(--stroke);border-radius:14px;padding:14px}
    .btn{background:#121827;color:var(--text);border:1px solid #223149;padding:10px 12px;border-radius:10px;cursor:pointer;font-weight:700}
    .btn.ghost{background:transparent;border-color:var(--stroke)}
    .btn.primary{background:linear-gradient(135deg,#121a2b,#172238);border-color:#2a3f62}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .badge{display:inline-block;padding:6px 10px;border-radius:999px;border:1px solid var(--stroke);background:var(--glass);font-size:12px;color:var(--muted)}
    .title{font-size:26px;font-weight:900}
    .subtitle{color:var(--muted);font-size:14px}
    .small{font-size:13px;color:var(--muted)}
    .big{font-size:30px;font-weight:900}
    header{display:flex;flex-direction:column;gap:10px}
    .header-top{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
    .brand{display:flex;gap:12px;align-items:center}
    .glyph{width:42px;height:42px;border-radius:10px;background:conic-gradient(from 210deg,var(--accent),#9b7bff,var(--accent));box-shadow:0 0 60px rgba(102,252,241,0.12);animation:spin 12s linear infinite}
    @keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .wallet-status{display:inline-flex;align-items:center;padding:6px 10px;border-radius:10px;background:transparent;border:1px solid transparent;color:var(--muted);font-size:13px}
    .hero{margin-top:12px;display:grid;gap:12px}
    .hero-grid{display:grid;grid-template-columns:1fr;gap:12px}
    @media(min-width:980px){.hero-grid{grid-template-columns:1.45fr .75fr}}
    .stats{display:grid;grid-template-columns:1fr;gap:10px;margin-top:10px}
    @media(min-width:650px){.stats{grid-template-columns:repeat(3,1fr)}}
    .stat{text-align:center;border-radius:12px;padding:12px;border:1px solid var(--stroke)}
    .list{display:grid;gap:8px}
    .item{display:grid;gap:10px}
    @media(min-width:800px){.item{grid-template-columns:1.1fr .7fr 1fr;align-items:center}}
    .feed{background:var(--panel);border:1px solid var(--stroke);border-radius:12px;padding:12px;margin-top:12px}
    .feed-head,.feed-row{display:grid;grid-template-columns:1fr .6fr .9fr 1.4fr .8fr;gap:8px;align-items:center}
    @media(max-width:820px){.feed-head,.feed-row{grid-template-columns:1fr .6fr .9fr 1.2fr;}.feed-head span:last-child,.feed-row span:last-child{display:none}}
    #debugPanel{position:fixed;bottom:0;left:0;width:100%;max-height:260px;overflow:auto;background:#081018;border-top:1px solid #222;font-family:ui-monospace,Menlo,Consolas;color:#9bd;padding:8px;z-index:99999}
    @media(max-width:600px){#debugPanel{font-size:11px}}
    input[type="text"], input[type="search"], .btn.mono {border-radius:10px;border:1px solid var(--stroke);padding:10px;background:transparent;color:var(--text)}
  </style>

  <!-- TweetNaCl for signature verification -->
  <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl.min.js"></script>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="header-top">
        <div class="brand">
          <div class="glyph" aria-hidden="true"></div>
          <div>
            <div class="mono" style="font-weight:800;font-size:16px">BarbrickDesign</div>
            <div class="small">Mythic automation, sovereign agents, and instant SOL recovery</div>
          </div>
        </div>

        <div class="controls" role="toolbar" aria-label="Primary actions">
          <button id="connectBtn" class="btn primary">Connect Wallet</button>
          <button id="openInWalletApp" class="btn ghost small" style="display:none">Open in Wallet App</button>
          <span id="walletStatus" class="wallet-status mono">Wallet: not detected</span>
          <a class="btn ghost small" href="https://www.barbrickdesign.com" target="_blank" rel="noopener">Main site</a>
          <a class="btn ghost small" href="https://github.com/barbrickdesign?tab=repositories" target="_blank" rel="noopener">GitHub</a>
        </div>
      </div>

      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;">
        <div id="status" class="small" style="min-height:20px;color:var(--muted)">Ready</div>
        <div class="small mono" id="refPreview" style="opacity:.9">—</div>
      </div>
    </header>

    <section class="hero">
      <div class="card">
        <div class="title">Build, recover, and earn — all in one place</div>
        <div class="subtitle">Close empty token accounts, analyze transaction history, map SOL flow, and recover rent.</div>
      </div>

      <div class="hero-grid">
        <div class="card">
          <div class="row" style="justify-content:space-between">
            <div class="mono small">Wallet</div>
            <div id="walletLabel" class="mono small">—</div>
          </div>

          <div style="height:10px"></div>

          <div class="big" id="refundEstimateBig">0.00000 SOL</div>
          <div class="small">Estimated SOL you can recover right now</div>

          <div class="row" style="margin-top:10px">
            <button id="recoverBtn" class="btn block">Recover My SOL</button>
            <button id="scanBtn" class="btn ghost">Scan & Analyze</button>
            <div class="badge">5% support (optional)</div>
          </div>

          <div class="row" style="margin-top:8px">
            <input id="refAddress" class="btn mono" style="min-width:200px;background:transparent" placeholder="Optional referrer wallet (?ref=)" />
            <label class="row" style="gap:8px;align-items:center"><input id="donationToggle" type="checkbox" checked /> <span class="small">Include support</span></label>
          </div>

          <div class="hr"></div>

          <div class="stats">
            <div class="stat">
              <div class="small">Empty accounts</div>
              <div id="emptyCount" class="big">0</div>
            </div>
            <div class="stat">
              <div class="small">Estimated refund</div>
              <div id="refundEstimate" class="big">0.00000 SOL</div>
            </div>
            <div class="stat">
              <div class="small">Session actions</div>
              <div id="sessionActions" class="big">0</div>
            </div>
          </div>
        </div>

        <div class="card">
          <div style="font-weight:800;margin-bottom:6px">Coin-holder LLM access</div>
          <div class="small">Token‑gated chat for holders.</div>
          <div class="hr"></div>
          <div class="row" style="align-items:center">
            <div id="llmAccessBadge" class="badge">Access: locked</div>
            <button id="openLLM" class="btn" disabled>Open LLM</button>
          </div>
          <div class="small" style="margin-top:8px">Connect wallet to verify holdings.</div>
        </div>
      </div>
    </section>

    <section class="modules">
      <div class="card">
        <div style="font-weight:800;margin-bottom:8px">Income modules</div>
        <div class="list">
          <div class="item">
            <div>
              <div class="link">SOL Recovery Portal</div>
              <div class="small">Close empty SPL token accounts and reclaim rent in bulk.</div>
            </div>
            <a class="btn ghost small" href="https://barbrickdesign.github.io/SOLRecovery/" target="_blank" rel="noopener">Open</a>
            <button id="recoverInlineBtn" class="btn">Recover here</button>
          </div>

          <div class="item">
            <div>
              <div class="link">NFT Minting Portal</div>
              <div class="small">Mint sigils, set splits, and manage drops.</div>
            </div>
            <a class="btn ghost small" href="https://barbrickdesign.github.io/NFTMint/" target="_blank" rel="noopener">Open</a>
            <button id="mintSigil" class="btn">Mint</button>
          </div>
        </div>
      </div>

      <div class="card">
        <div style="font-weight:800;margin-bottom:6px">Projects</div>
        <div style="max-height:420px;overflow:auto;padding-right:8px">
          <div id="repoGroups" class="list"></div>
        </div>
        <div class="small" style="margin-top:8px">We check each project's root index.html and avoid direct 404 links.</div>
      </div>
    </section>

    <section class="feed">
      <div class="feed-head">
        <span>Wallet</span><span>Accounts</span><span>Refunded SOL</span><span>Tx</span><span>Date</span>
      </div>
      <div id="feed"></div>
      <div class="row" style="justify-content:flex-end;margin-top:8px">
        <button id="exportSession" class="btn ghost">Export session</button>
        <button id="loadMore" class="btn ghost">Load more</button>
      </div>
    </section>

    <footer style="margin-top:12px">
      <div class="row" style="justify-content:space-between">
        <div class="small">© BarbrickDesign 2025 · Built for contributors and coin holders</div>
        <div class="row">
          <a class="badge" href="https://www.barbrickdesign.com" target="_blank" rel="noopener">Main site</a>
          <a class="badge" href="https://github.com/barbrickdesign?tab=repositories" target="_blank" rel="noopener">GitHub</a>
        </div>
      </div>
    </footer>
  </div>

  <!-- Commit viewer -->
  <div id="commitToggle" style="position:fixed;bottom:20px;right:20px;z-index:9999;cursor:pointer;">🕰️</div>
  <div id="commitViewer" style="display:none;position:fixed;top:10px;right:10px;background:#111;padding:10px;border-radius:8px;max-height:90vh;overflow:auto;width:min(640px,92vw);z-index:9999;">
    <h3 class="mono" style="font-weight:800">🔁 Commit viewer</h3>
    <div class="row" style="gap:6px">
      <select id="commitSelector" class="btn mono" style="flex:1;background:transparent"></select>
      <button id="commitLoad" class="btn">Load</button>
      <button id="commitCopy" class="btn ghost">📋 Copy</button>
    </div>
    <div id="previewFrame" style="margin-top:10px;border:1px solid #333;height:300px;background:#000"></div>
    <pre id="commitPreview" style="margin-top:10px;background:#222;padding:10px;border-radius:6px;white-space:pre-wrap"></pre>
  </div>

  <!-- Solana libs -->
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.8/lib/index.iife.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/spl-token@0.3.11/dist/browser/spl-token.min.js"></script>

  <!-- projects.js fallback loader -->
  <script src="./projects.js"></script>

  <script>
    /* Debug panel */
    const debugPanel = document.createElement('div');
    debugPanel.id = 'debugPanel';
    debugPanel.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center">
        <strong>🔍 Debug Log</strong>
        <div style="display:flex;gap:8px;align-items:center">
          <button id="toggleDebug" class="btn ghost small">Hide</button>
          <button id="clearDebug" class="btn ghost small">Clear</button>
        </div>
      </div>
      <div id="debugLog" style="margin-top:8px;white-space:pre-wrap"></div>
    `;
    document.body.appendChild(debugPanel);
    function logDebug(...args){
      const el = document.getElementById('debugLog');
      const t = '[' + new Date().toLocaleTimeString() + '] ' + args.map(a => (typeof a === 'object' ? JSON.stringify(a,null,2) : String(a))).join(' ');
      const d = document.createElement('div'); d.textContent = t; el.appendChild(d); el.scrollTop = el.scrollHeight; console.log(...args);
    }
    document.getElementById('clearDebug').addEventListener('click', ()=> document.getElementById('debugLog').innerHTML = '');
    document.getElementById('toggleDebug').addEventListener('click', (e)=> {
      const log = document.getElementById('debugLog'); const hidden = log.style.display === 'none'; log.style.display = hidden ? 'block' : 'none'; e.target.textContent = hidden ? 'Hide' : 'Show';
    });

    /* Elements & state */
    const connectBtn = document.getElementById('connectBtn');
    const openInWalletAppBtn = document.getElementById('openInWalletApp');
    const walletLabel = document.getElementById('walletLabel');
    const statusEl = document.getElementById('status');
    const walletStatusBadge = document.getElementById('walletStatus');
    const scanBtn = document.getElementById('scanBtn');
    const recoverBtn = document.getElementById('recoverBtn');
    const refundEstimateBigEl = document.getElementById('refundEstimateBig');
    const emptyCountEl = document.getElementById('emptyCount');
    const refundEstimateEl = document.getElementById('refundEstimate');
    const sessionActionsEl = document.getElementById('sessionActions');
    const repoGroups = document.getElementById('repoGroups');

    const endpoint = 'https://api.mainnet-beta.solana.com';
    const connection = new solanaWeb3.Connection(endpoint, 'confirmed');
    const RENT_PER_EMPTY_ACCOUNT_SOL = 0.00204;
    const DONATION_PCT = 0.05;
    const REFERRAL_SPLIT_PCT_OF_DONATION = 0.20;
    const FEE_WALLET = new solanaWeb3.PublicKey('5hSWosj58ki4A6hSfQrvteQU5QvyCWmhHn4AuqgaQzqr');

    let wallet = null;
    let emptyTokenAccounts = [];
    let holdings = [];
    let sessionFeed = [];
    let sessionActions = 0;

    function setStatus(msg, kind='info'){ if(statusEl){ statusEl.textContent = msg; statusEl.style.color = kind==='error' ? 'var(--bad)' : kind==='warn' ? 'var(--warn)' : kind==='success' ? 'var(--good)' : 'var(--muted)'; } }
    function shorten(s){ return s ? (s.slice(0,4) + '...' + s.slice(-4)) : '—' }
    function toSol(n){ return (Math.round(n*100000)/100000).toFixed(5) }
    function lamportsToSol(l){ return l / solanaWeb3.LAMPORTS_PER_SOL }
    function safePubkey(s){ try{ return s ? new solanaWeb3.PublicKey(s) : null } catch(_) { return null } }

    function getProvider(){ const p = window.solana; if(p && (p.isPhantom || p.isBackpack || p.isOKXWallet)) return p; return null }

    function isMobileBrowser(){ return /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent || ''); }
    async function waitForProvider(timeoutMs = 1500, intervalMs = 150){
      const start = Date.now();
      while(Date.now() - start < timeoutMs){
        const p = window.solana;
        if(p && (p.isPhantom || p.isBackpack || p.isOKXWallet)) return p;
        await new Promise(r=>setTimeout(r, intervalMs));
      }
      return null;
    }
    function buildPhantomDeepLink(){
      const appUrl = encodeURIComponent(window.location.origin);
      const redirect = encodeURIComponent(window.location.href.replace(window.location.search || '', '') + '?from_phantom=1');
      return `https://phantom.app/ul/v1/connect?app_url=${appUrl}&redirect_url=${redirect}`;
    }
    function promptOpenInWalletApp(){ try{ localStorage.setItem('awaiting_wallet','1'); }catch(e){ logDebug('localStorage set failed', e) } const link = buildPhantomDeepLink(); logDebug('Opening wallet app via deep link:', link); window.open(link, '_blank'); setStatus('Opening wallet app... approve connect inside the app, then return to this page.', 'warn'); }

    function normPubkey(x){ if(!x) return null; if(x instanceof solanaWeb3.PublicKey) return x; if(x.publicKey && x.publicKey instanceof solanaWeb3.PublicKey) return x.publicKey; if(typeof x === 'string'){ try{ return new solanaWeb3.PublicKey(x) }catch(_){} } return null; }

    /* CONNECT + SIGN flow (uses tweetnacl for verification) */
    async function connectWallet(){
      setStatus('Attempting wallet connect…');
      logDebug('connectWallet start; mobile?', isMobileBrowser());
      const provider = await waitForProvider(1500,150) || getProvider();
      if(!provider){
        if(isMobileBrowser()){ promptOpenInWalletApp(); return; }
        setStatus('No wallet detected. Install Phantom or enable extension and reload.', 'warn');
        return;
      }

      try{
        logDebug('Invoking provider.connect()');
        const resp = await provider.connect({ onlyIfTrusted: false });
        // normalize pubkey
        wallet = (resp && resp.publicKey) ? resp.publicKey : (provider.publicKey || null);
        if(!wallet || !wallet.toBase58) throw new Error('No publicKey returned from provider');
        walletLabel.textContent = shorten(wallet.toBase58());
        logDebug('Connected', wallet.toBase58());

        // create message and nonce
        const nonce = Math.floor(Math.random()*1e9).toString();
        const ts = Date.now();
        const message = `BarbrickDesign sign-in\nnonce:${nonce}\nts:${ts}\naddress:${wallet.toBase58()}`;
        const enc = new TextEncoder();
        const msgBytes = enc.encode(message);

        setStatus('Requesting signature from wallet…');
        logDebug('Requesting message signature');

        let signed = null;
        if(typeof provider.signMessage === 'function'){
          // Phantom returns { signature: Uint8Array } or Uint8Array based on version
          try { signed = await provider.signMessage(msgBytes, 'utf8'); } catch(e){
            // fallback to request
            try { signed = await provider.request?.({ method: 'signMessage', params: { message: Array.from(msgBytes) } }); } catch(err){ throw err; }
          }
        } else if(typeof provider.request === 'function'){
          signed = await provider.request({ method: 'signMessage', params: { message: Array.from(msgBytes) } });
        } else {
          throw new Error('Wallet does not support signMessage');
        }

        // normalize signature bytes
        let signatureBytes = null;
        if(signed && signed.signature) signatureBytes = signed.signature;
        else if(signed && signed.length) signatureBytes = signed;
        else if(signed && signed.sig) signatureBytes = signed.sig;
        else if(Array.isArray(signed)) signatureBytes = Uint8Array.from(signed);
        if(!signatureBytes) throw new Error('No signature returned from wallet');

        // ensure Uint8Array
        const sigBuf = signatureBytes instanceof Uint8Array ? signatureBytes : Uint8Array.from(signatureBytes);
        const pubkeyBytes = wallet.toBytes ? wallet.toBytes() : new solanaWeb3.PublicKey(wallet).toBytes();
        const ok = nacl.sign.detached.verify(msgBytes, sigBuf, pubkeyBytes);

        logDebug('Signature verification result', ok);
        if(!ok){ setStatus('Signature verification failed.', 'error'); wallet = null; walletLabel.textContent = '—'; return; }

        setStatus('Wallet connected and verified', 'success');
        await scanAllHoldingsAndHistoryImproved();
        await checkGateAccess();
      }catch(err){
        logDebug('connectWallet/sign flow failed', err);
        setStatus('Wallet connection or verification failed.', 'error');
        wallet = null;
        walletLabel.textContent = '—';
      }
    }

    /* SCAN token accounts + transaction analysis (robust) */
    const SOLSCAN_ACCOUNT_TXS = 'https://public-api.solscan.io/account/transactions';
    const SOLSCAN_TOKEN_INFO = 'https://public-api.solscan.io/token/meta?tokenAddress=';

    async function scanTokenAccounts(){
      const pk = normPubkey(wallet) || normPubkey(getProvider()?.publicKey);
      if(!pk){ setStatus('Connect wallet first.', 'warn'); return { empty:[], holdings:[] } }
      setStatus('Scanning token accounts and holdings...');
      try{
        let res;
        try{ res = await connection.getParsedTokenAccountsByOwner(pk, { programId: splToken.TOKEN_PROGRAM_ID }); }
        catch(errParsed){
          logDebug('getParsedTokenAccountsByOwner failed, fallback', errParsed);
          const raw = await connection.getTokenAccountsByOwner(pk, { programId: splToken.TOKEN_PROGRAM_ID });
          const parsedFallback = raw.value.map(v=>({ pubkey: v.pubkey.toString(), account:{ data:{ parsed:{ info:{ tokenAmount:{ uiAmount:0 }, mint:'unknown' } } } } }));
          res = { value: parsedFallback };
        }
        const parsed = res.value || [];
        const empty = []; const holdsMap = {};
        for(const acc of parsed){
          const info = acc.account && acc.account.data && acc.account.data.parsed && acc.account.data.parsed.info;
          const ui = Number(info?.tokenAmount?.uiAmount || 0);
          const mint = info?.mint || null;
          const pubkey = acc.pubkey?.toString ? acc.pubkey.toString() : String(acc.pubkey);
          if(ui === 0) empty.push({ pubkey, mint });
          else if(mint) holdsMap[mint] = (holdsMap[mint]||0) + ui;
        }
        const holdingsArr = Object.keys(holdsMap).map(m=>({ mint:m, amount:holdsMap[m] }));
        emptyTokenAccounts = empty; holdings = holdingsArr;
        emptyCountEl.textContent = String(empty.length);
        const est = empty.length * RENT_PER_EMPTY_ACCOUNT_SOL;
        refundEstimateEl.textContent = toSol(est) + ' SOL';
        refundEstimateBigEl.textContent = toSol(est) + ' SOL';
        if(holdingsArr.length === 0) setStatus('No token holdings found in this wallet.', 'warn');
        else setStatus(`Found ${holdingsArr.length} token mint(s).`);
        logDebug('scanTokenAccounts', { emptyCount: empty.length, holdingsCount: holdingsArr.length });
        return { empty, holdings: holdingsArr };
      }catch(e){ logDebug('scanTokenAccounts failed', e); setStatus('Scan failed. Try again.', 'error'); return { empty:[], holdings:[] } }
    }

    async function retry(fn, attempts = 3, delay = 300){
      let last;
      for(let i=0;i<attempts;i++){
        try{ return await fn() } catch(e){ last = e; await new Promise(r=>setTimeout(r, delay*(i+1))); }
      }
      throw last;
    }

    async function fetchTransactionsForWalletRobust({ rpcLimit = 250 } = {}){
      const pk = normPubkey(wallet) || normPubkey(getProvider()?.publicKey);
      if(!pk){ logDebug('no pubkey'); return { source:'none', txs:[] } }
      try{
        setStatus('Fetching signatures (RPC)...');
        const sigInfos = await retry(()=> connection.getSignaturesForAddress(pk, { limit: rpcLimit }), 3, 300);
        if(!Array.isArray(sigInfos) || sigInfos.length === 0){ logDebug('RPC no signatures'); return { source:'rpc', txs:[] } }
        const sigs = sigInfos.map(s=>s.signature);
        const parsed = []; const batchSize = 20;
        for(let i=0;i<sigs.length;i+=batchSize){
          const chunk = sigs.slice(i,i+batchSize);
          const resolved = await Promise.all(chunk.map(sig => retry(()=> connection.getParsedTransaction(sig, 'confirmed'), 2, 200).catch(e=>{ logDebug('getParsedTransaction fail', sig, e); return null; })));
          parsed.push(...resolved.filter(Boolean));
          await new Promise(r=>setTimeout(r,150));
        }
        logDebug('RPC parsed txs', parsed.length);
        return { source:'rpc', txs: parsed };
      }catch(e){ logDebug('fetchTransactionsForWalletRobust failed', e); return { source:'none', txs:[] } }
    }

    async function fetchTransactionsForWallet({ solscanPages = 2, solscanLimit = 50, rpcLimit = 250 } = {}){
      const pk = normPubkey(wallet) || normPubkey(getProvider()?.publicKey);
      if(!pk) return { source:'none', txs:[] };
      const addr = pk.toBase58();
      try{
        const all = [];
        for(let p=0;p<solscanPages;p++){
          const offset = p*solscanLimit;
          const url = `${SOLSCAN_ACCOUNT_TXS}?address=${addr}&limit=${solscanLimit}&offset=${offset}`;
          logDebug('Solscan fetch', url);
          const r = await fetch(url);
          if(!r.ok){ logDebug('Solscan non-ok', r.status); throw new Error('Solscan non-ok ' + r.status) }
          const j = await r.json();
          if(!Array.isArray(j) || j.length === 0) break;
          all.push(...j);
          if(j.length < solscanLimit) break;
          await new Promise(r=>setTimeout(r,250));
        }
        logDebug('Solscan tx count', all.length);
        if(all.length > 0) return { source:'solscan', txs: all };
      }catch(e){ logDebug('Solscan failed, fallback RPC', e) }
      return fetchTransactionsForWalletRobust({ rpcLimit });
    }

    function analyzeTransactionsForFlowsUnified(rawTxBundle){
      if(!wallet) return [];
      const our = normPubkey(wallet).toBase58();
      const flows = {}; const txs = rawTxBundle.txs || [];
      if(rawTxBundle.source === 'solscan'){
        for(const tx of txs){
          const native = tx.nativeTransfers || tx.nativeTransfer || tx.native || [];
          if(Array.isArray(native) && native.length){
            for(const nt of native){
              const from = nt.from, to = nt.to;
              const lam = Math.round(Number(nt.amount || 0) * solanaWeb3.LAMPORTS_PER_SOL);
              if(from === our){ flows[to] = flows[to] || { in:0, out:0 }; flows[to].out += lam }
              if(to === our){ flows[from] = flows[from] || { in:0, out:0 }; flows[from].in += lam }
            }
          }
        }
      } else if(rawTxBundle.source === 'rpc'){
        for(const tx of txs){
          try{
            const meta = tx.meta; const message = tx.transaction?.message;
            if(!meta || !message) continue;
            const instrs = message.instructions || [];
            for(const ins of instrs){
              if(ins.parsed && ins.parsed.type === 'transfer' && ins.parsed.info){
                const from = ins.parsed.info.source || ins.parsed.info.from;
                const to = ins.parsed.info.destination || ins.parsed.info.to;
                const lam = Number(ins.parsed.info.lamports || Math.round((ins.parsed.info.amount || 0) * solanaWeb3.LAMPORTS_PER_SOL || 0));
                if(from === our){ flows[to] = flows[to] || { in:0, out:0 }; flows[to].out += lam }
                if(to === our){ flows[from] = flows[from] || { in:0, out:0 }; flows[from].in += lam }
              }
            }
          }catch(e){ logDebug('analyze RPC tx error', e) }
        }
      }
      const summary = Object.keys(flows).map(addr=>{
        const inLam = flows[addr].in || 0; const outLam = flows[addr].out || 0;
        return { addr, inSol: (inLam/solanaWeb3.LAMPORTS_PER_SOL).toFixed(5), outSol: (outLam/solanaWeb3.LAMPORTS_PER_SOL).toFixed(5), netOutFromUs: ((outLam-inLam)/solanaWeb3.LAMPORTS_PER_SOL).toFixed(5) };
      }).sort((a,b)=> Number(b.netOutFromUs) - Number(a.netOutFromUs));
      return summary;
    }

    async function scanAllHoldingsAndHistoryImproved(){
      setStatus('Starting comprehensive scan (improved)...');
      const tokenResult = await scanTokenAccounts();
      for(const h of tokenResult.holdings.slice(0,6)){ try{ const r = await fetch(SOLSCAN_TOKEN_INFO + encodeURIComponent(h.mint)); if(r.ok) h.meta = await r.json(); }catch(_){} }
      const txBundle = await fetchTransactionsForWallet({ solscanPages:2, solscanLimit:50, rpcLimit:250 });
      const flowSummary = analyzeTransactionsForFlowsUnified(txBundle);
      renderCounterpartySummary(flowSummary);
      logDebug('Improved scan finished', { tokenResult, txCount: (txBundle.txs||[]).length, flowSummaryLength: flowSummary.length });
      return { tokenResult, txBundle, flowSummary };
    }

    function renderCounterpartySummary(summary){
      const existing = document.getElementById('counterpartyPanel'); if(existing) existing.remove();
      const panel = document.createElement('div'); panel.id = 'counterpartyPanel'; panel.className = 'card';
      panel.innerHTML = `<div style="font-weight:800;margin-bottom:6px">Counterparty flow (top receivers)</div>`; const list = document.createElement('div'); list.className = 'list';
      if(!summary || summary.length === 0){ const none = document.createElement('div'); none.className='small'; none.textContent='No recent SOL flows found for this wallet.'; list.appendChild(none); }
      else { summary.slice(0,10).forEach(s=>{ const row=document.createElement('div'); row.className='item'; row.innerHTML = `<div><div class="mono">${shorten(s.addr)}</div><div class="small">net out: ${s.netOutFromUs} SOL; out: ${s.outSol} SOL; in: ${s.inSol} SOL</div></div><div><button class="btn ghost small" onclick="window.open('https://explorer.solana.com/address/${s.addr}','_blank')">Explorer</button></div>`; list.appendChild(row); }); }
      panel.appendChild(list); repoGroups.parentNode.insertBefore(panel, repoGroups); setStatus('Analysis complete. See counterparty panel.');
    }

    async function recoverNow(){ if(!wallet){ setStatus('Connect a wallet first.','warn'); return } if(emptyTokenAccounts.length === 0){ setStatus('No empty accounts to close.','warn'); return } setStatus('Preparing recovery transactions...'); const ownerPubkey = wallet; const chunkSize = 8; let closed=0, refundLamports=0; for(let i=0;i<emptyTokenAccounts.length;i+=chunkSize){ const slice = emptyTokenAccounts.slice(i,i+chunkSize); const tx = new solanaWeb3.Transaction(); for(const acc of slice){ const ix = splToken.createCloseAccountInstruction(new solanaWeb3.PublicKey(acc.pubkey), ownerPubkey, ownerPubkey, []); tx.add(ix); } tx.feePayer = ownerPubkey; tx.recentBlockhash = (await connection.getLatestBlockhash()).blockhash; try{ const sig = await signSendConfirm(tx); closed += slice.length; refundLamports += Math.floor(slice.length * solanaWeb3.LAMPORTS_PER_SOL * RENT_PER_EMPTY_ACCOUNT_SOL); addFeedItem(ownerPubkey.toBase58(), slice.length, slice.length * RENT_PER_EMPTY_ACCOUNT_SOL, sig, new Date()); setStatus(`Closed ${closed}/${emptyTokenAccounts.length} accounts...`); logDebug('Recovered chunk', { closed, sig }); }catch(e){ logDebug('recover chunk failed', e); setStatus('Some accounts failed to close. Retry the remaining ones.', 'warn'); } await new Promise(r=>setTimeout(r,200)); } if(donationToggle.checked && refundLamports>0){ const donationLamports = Math.floor(refundLamports * DONATION_PCT); const referralLamports = Math.floor(donationLamports * REFERRAL_SPLIT_PCT_OF_DONATION); const feeLamports = donationLamports - referralLamports; const referralAddr = safePubkey(refInput.value); const tipTx = new solanaWeb3.Transaction(); if(feeLamports>0) tipTx.add(solanaWeb3.SystemProgram.transfer({ fromPubkey: ownerPubkey, toPubkey: FEE_WALLET, lamports: feeLamports })); if(referralAddr && referralLamports>0) tipTx.add(solanaWeb3.SystemProgram.transfer({ fromPubkey: ownerPubkey, toPubkey: referralAddr, lamports: referralLamports })); try{ const sig = await signSendConfirm(tipTx); addFeedItem(ownerPubkey.toBase58(), 0, (donationLamports/solanaWeb3.LAMPORTS_PER_SOL).toFixed(5), sig, new Date()); setStatus('Support and referral sent.', 'success'); }catch(e){ logDebug('support failed', e); setStatus('Support send failed.', 'warn'); } sessionActions += 1; sessionActionsEl.textContent = String(sessionActions); await scanTokenAccounts(); setStatus('Recovery complete.', 'success'); }

    async function signSendConfirm(tx){ const provider = getProvider(); if(!provider){ logDebug('No provider available'); throw new Error('No provider') } try{ if(typeof provider.signAndSendTransaction === 'function'){ logDebug('Using signAndSendTransaction'); const res = await provider.signAndSendTransaction(tx); const sig = res.signature || res; await connection.confirmTransaction(sig, 'confirmed'); return sig; } else if(typeof provider.signTransaction === 'function'){ logDebug('Using signTransaction fallback'); const signed = await provider.signTransaction(tx); const raw = signed.serialize(); const txid = await connection.sendRawTransaction(raw); await connection.confirmTransaction(txid, 'confirmed'); return txid; } else throw new Error('Provider has no signing methods'); }catch(e){ logDebug('signSendConfirm error', e); throw e }

    function addFeedItem(walletAddr, accounts, sol, sig, date){ sessionFeed.unshift({ wallet: walletAddr, accounts, sol, sig, date: date.toISOString() }); renderFeed(); }
    function renderFeed(){ feedEl.innerHTML=''; for(const it of sessionFeed.slice(0,24)){ const row=document.createElement('div'); row.className='feed-row'; row.innerHTML = `<span class="mono">${shorten(it.wallet)}</span><span>${it.accounts}</span><span>${toSol(it.sol)} SOL</span><span class="mono">${shorten(it.sig||'')}</span><span>${new Date(it.date).toLocaleString()}</span>`; feedEl.appendChild(row); } }
    function exportSession(){ const blob=new Blob([JSON.stringify({ feed: sessionFeed }, null, 2)], { type:'application/json' }); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`barbrick-session-${Date.now()}.json`; a.click(); URL.revokeObjectURL(url); }

    /* UI wiring */
    connectBtn.addEventListener('click', connectWallet);
    openInWalletAppBtn.addEventListener('click', promptOpenInWalletApp);
    scanBtn.addEventListener('click', ()=> scanAllHoldingsAndHistoryImproved());
    document.getElementById('commitToggle').addEventListener('click', ()=>{ const cv = document.getElementById('commitViewer'); cv.style.display = cv.style.display === 'block' ? 'none' : 'block'; if(cv.style.display === 'block' && !document.getElementById('commitSelector').dataset.loaded) fetchCommits(); });
    document.getElementById('commitLoad').addEventListener('click', loadCommit);
    document.getElementById('commitCopy').addEventListener('click', copyCommitToClipboard);

    window._bd = { connectWallet, scanTokenAccounts, scanAllHoldingsAndHistoryImproved, fetchTransactionsForWallet, fetchTransactionsForWalletRobust, analyzeTransactionsForFlowsUnified, logDebug };
  </script>
</body>
</html>
