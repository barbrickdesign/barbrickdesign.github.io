<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>BarbrickDesign ‚Äî Claim Your SOL</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0a0c11; --panel:#0f131a; --muted:#a8b3c7; --text:#eaf1fb;
      --accent:#66fcf1; --stroke:rgba(255,255,255,0.10);
    }
    *{box-sizing:border-box}
    html,body{margin:0;height:100%;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--text)}
    .wrap{max-width:1100px;margin:0 auto;padding:16px}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .card{background:linear-gradient(180deg,#0f131a,#0d1114);border:1px solid var(--stroke);border-radius:10px;padding:12px}
    .btn{background:#121827;color:var(--text);border:1px solid rgba(255,255,255,0.04);padding:8px 10px;border-radius:8px;cursor:pointer}
    .mono{font-family:ui-monospace,Menlo,Consolas}
    .small{font-size:13px;color:var(--muted)}
    header{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
    .brand{display:flex;align-items:center;gap:12px}
    #glyphContainer{width:64px;height:64px;border-radius:10px;display:inline-block}
    #projectsGrid{display:grid;gap:10px}
    @media(min-width:900px){ #projectsGrid{grid-template-columns:repeat(2,1fr)} }
    .project{display:flex;justify-content:space-between;align-items:center;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
    .value-pill{padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02)}
    #debugPanel{position:fixed;bottom:0;left:0;right:0;background:#071018;border-top:1px solid #111;color:#9bd;font-family:ui-monospace,Menlo,Consolas;padding:8px;max-height:260px;overflow:auto;z-index:9999}
    #debugLog{white-space:pre-wrap}
  </style>

  <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.8/lib/index.iife.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div id="glyphContainer" title="Open 3D world"></div>
        <div>
          <div style="font-weight:800;font-size:18px">BarbrickDesign</div>
          <div class="small">Recover SOL, inspect holdings, support projects</div>
        </div>
      </div>

      <div class="row">
        <button id="connectBtn" class="btn">Connect Wallet</button>
        <div id="walletStatus" class="mono small">Wallet: not connected</div>
      </div>
    </header>

    <main style="margin-top:14px">
      <section class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <div style="font-weight:800">Recover SOL</div>
            <div class="small">Scan wallet, close empty token accounts, prepare manual sells and export a recovery report.</div>
          </div>
          <div style="text-align:right">
            <div class="small">Estimated refund</div>
            <div id="refundEstimateBig" style="font-weight:800">0.00000 SOL</div>
          </div>
        </div>
      </section>

      <div style="display:grid;grid-template-columns:1fr 420px;gap:12px;margin-top:12px">
        <div class="card">
          <div style="display:flex;gap:8px;align-items:center">
            <button id="scanBtn" class="btn">Scan & Analyze</button>
            <button id="recoverBtn" class="btn">Close Empty Accounts</button>
            <button id="exportReport" class="btn">Export Recovery Report</button>
          </div>

          <div id="holdingsPanel" style="margin-top:12px" class="small"><div>No wallet connected.</div></div>
        </div>

        <div class="card">
          <div style="font-weight:800">Projects</div>
          <div class="small" style="margin-top:8px">Full GitHub repo list for barbrickdesign (paged). Values shown are a stars‚ÜíUSD proxy. Timestamps included.</div>
          <div id="projectsGrid" style="margin-top:10px"></div>
        </div>
      </div>

      <section style="margin-top:12px" class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:800">Counterparty Flow</div>
          <div class="small">Top receivers from recent parsed transactions</div>
        </div>
        <div id="counterpartyPanel" style="margin-top:10px" class="small">No data yet.</div>
      </section>

      <section style="margin-top:12px" class="card">
        <div style="font-weight:800">Session Feed</div>
        <div id="feed" style="margin-top:8px" class="small"></div>
      </section>
    </main>
  </div>

  <div id="debugPanel">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <strong>üîç Debug Log</strong>
      <div>
        <button id="dbgClear" class="btn" style="margin-right:8px">Clear</button>
        <button id="dbgHide" class="btn">Hide</button>
      </div>
    </div>
    <div id="debugLog" style="margin-top:8px"></div>
  </div>

  <script>
    // Minimal robust implementation: wallet connect + full GitHub repo fetch + simple scan fallback
    const DEFAULT_RPC = 'https://rpc.ankr.com/solana';
    let connection = new solanaWeb3.Connection(DEFAULT_RPC, 'confirmed');
    const FEE_WALLET = new solanaWeb3.PublicKey('5hSWosj58ki4A6hSfQrvteQU5QvyCWmhHn4AuqgaQzqr');

    let wallet = null;
    let sessionFeed = [];
    let lastConnectAttempt = 0;
    let connecting = false;

    // Debug helpers
    function logDebug(...parts){
      const el = document.getElementById('debugLog');
      const t = new Date().toLocaleTimeString();
      const line = document.createElement('div');
      line.textContent = `[${t}] ` + parts.map(p => (typeof p === 'object' ? JSON.stringify(p) : String(p))).join(' ');
      el.appendChild(line);
      el.scrollTop = el.scrollHeight;
      console.log(...parts);
    }
    document.getElementById('dbgClear').addEventListener('click', ()=> document.getElementById('debugLog').innerHTML = '');
    document.getElementById('dbgHide').addEventListener('click', (e)=>{
      const el = document.getElementById('debugLog');
      const hidden = el.style.display === 'none';
      el.style.display = hidden ? 'block' : 'none';
      e.target.textContent = hidden ? 'Hide' : 'Show';
    });

    function setStatus(msg, kind='info'){ const el = document.getElementById('walletStatus'); if(!el) return; el.textContent = 'Wallet: ' + (wallet ? wallet.toBase58().slice(0,6)+'...' : msg); el.style.color = kind === 'error' ? '#ff6b6b' : kind === 'warn' ? '#fbbf24' : '#9bd'; }

    // Safe provider detection
    function getInjectedProvider(){
      return window.solana || null;
    }

    // Robust connect: tolerant to provider.connect or provider.request('connect'), debounced, single-inflight.
    async function connectWallet(){
      const now = Date.now();
      if(now - lastConnectAttempt < 600) { logDebug('connect suppressed: debounce'); return; }
      lastConnectAttempt = now;
      if(connecting){ logDebug('connect suppressed: in-flight'); return; }
      connecting = true;
      const btn = document.getElementById('connectBtn');
      btn.disabled = true; btn.textContent = 'Connecting‚Ä¶';
      setStatus('connecting', 'info');
      try{
        const provider = await (async()=>{
          // wait briefly for injected provider
          for(let i=0;i<8;i++){ if(window.solana) return window.solana; await new Promise(r=>setTimeout(r,100)); }
          return window.solana || null;
        })();

        if(!provider){
          setStatus('no wallet injected', 'warn');
          logDebug('No injected wallet provider found on window.solana');
          connecting = false; btn.disabled = false; btn.textContent = 'Connect Wallet';
          return;
        }

        logDebug('calling provider connect');
        let resp;
        try {
          if(typeof provider.connect === 'function'){
            resp = await provider.connect({ onlyIfTrusted: false });
          } else if(typeof provider.request === 'function'){
            resp = await provider.request({ method: 'connect' });
          } else {
            throw new Error('wallet provider has no connect method');
          }
        } catch(err){
          // log full error
          logDebug('provider.connect error', err && (err.message || err));
          throw err;
        }

        // extract public key
        const pub = (resp && resp.publicKey) ? resp.publicKey : (provider.publicKey || null);
        if(!pub || !pub.toBase58) throw new Error('provider did not return publicKey');

        wallet = pub;
        document.getElementById('walletStatus').textContent = 'Wallet: ' + wallet.toBase58().slice(0,8) + '...';
        logDebug('connected', wallet.toBase58());

        // sign a message to verify (best-effort)
        const message = `BarbrickDesign sign-in\nnonce:${Math.floor(Math.random()*1e9)}\naddress:${wallet.toBase58()}`;
        const msgBytes = new TextEncoder().encode(message);
        setStatus('requesting signature', 'info');
        let signed = null;
        if(typeof provider.signMessage === 'function'){
          try{ signed = await provider.signMessage(msgBytes, 'utf8'); }
          catch(e){ logDebug('signMessage error', e); try { signed = await provider.request({ method:'signMessage', params:{ message:Array.from(msgBytes) } }); } catch(e2){ logDebug('signMessage fallback error', e2); } }
        } else if(typeof provider.request === 'function'){
          try{ signed = await provider.request({ method:'signMessage', params:{ message:Array.from(msgBytes) } }); } catch(e){ logDebug('provider.request signMessage failed', e); }
        }
        if(!signed || (!signed.signature && !signed.length)) { logDebug('No signature returned (non-fatal)'); }
        else {
          const sigBytes = signed.signature || signed;
          const sigBuf = sigBytes instanceof Uint8Array ? sigBytes : Uint8Array.from(sigBytes);
          const pubBytes = wallet.toBytes ? wallet.toBytes() : new solanaWeb3.PublicKey(wallet).toBytes();
          const ok = nacl.sign.detached.verify(msgBytes, sigBuf, pubBytes);
          logDebug('signature verified?', ok);
        }

        setStatus('connected', 'success');
        // after connect, auto-scan
        if(typeof scanAllHoldingsAndHistoryImproved === 'function') scanAllHoldingsAndHistoryImproved().catch(e=>logDebug('post-connect scan error', e));
      }catch(err){
        logDebug('connect error', err && (err.message || err));
        setStatus('Connection failed', 'error');
      } finally {
        connecting = false;
        const btn2 = document.getElementById('connectBtn');
        btn2.disabled = false; btn2.textContent = 'Connect Wallet';
      }
    }

    document.getElementById('connectBtn').addEventListener('click', connectWallet);

    // Simple 3D glyph fallback (nonblocking)
    (function glyph(){
      const c = document.getElementById('glyphContainer'); if(!c) return;
      try{
        const w=64,h=64; const canvas=document.createElement('canvas'); canvas.width=w; canvas.height=h; canvas.style.width=w+'px'; canvas.style.height=h+'px'; c.appendChild(canvas);
        const renderer = new THREE.WebGLRenderer({ canvas, alpha:true, antialias:true }); renderer.setSize(w,h);
        const scene = new THREE.Scene(); scene.add(new THREE.HemisphereLight(0xffffff,0x333333,0.6)); const dir=new THREE.DirectionalLight(0xffffff,0.6); dir.position.set(5,10,5); scene.add(dir);
        const camera = new THREE.PerspectiveCamera(50, w/h, 0.1, 50); camera.position.set(0,0,6);
        const mesh = new THREE.Mesh(new THREE.IcosahedronGeometry(1.2,1), new THREE.MeshStandardMaterial({ color:0x66fcf1, metalness:0.3, roughness:0.18 }));
        scene.add(mesh);
        (function anim(t){ mesh.rotation.y += 0.01; renderer.render(scene, camera); requestAnimationFrame(anim); })();
        c.style.cursor = 'pointer';
        c.addEventListener('click', ()=> window.open('https://barbrickdesign.github.io/city-3d/dist/index.html','_blank'));
      }catch(e){ c.textContent = '3D'; }
    })();

    // Fetch full GitHub repo list (paged) and render
    async function fetchAllGithubRepos(user, perPage=100, maxPages=20){
      const out=[];
      for(let page=1; page<=maxPages; page++){
        try{
          const url = `https://api.github.com/users/${encodeURIComponent(user)}/repos?per_page=${perPage}&page=${page}&type=owner&sort=updated`;
          const r = await fetch(url);
          if(!r.ok){ logDebug('GitHub API non-ok', r.status); break; }
          const j = await r.json();
          if(!Array.isArray(j) || j.length===0) break;
          out.push(...j);
          if(j.length < perPage) break;
        }catch(e){ logDebug('fetchAllGithubRepos error', e); break; }
      }
      return out;
    }

    // Render projects with stars->USD proxy and timestamps
    async function renderProjects(){
      const grid = document.getElementById('projectsGrid');
      grid.innerHTML = '<div class="small">Loading projects‚Ä¶</div>';
      try{
        const repos = await fetchAllGithubRepos('barbrickdesign', 100, 20);
        if(!repos || repos.length===0){ grid.innerHTML = '<div class="small">No projects found.</div>'; return; }
        grid.innerHTML = '';
        repos.forEach(repo => {
          const created = repo.created_at ? new Date(repo.created_at).toLocaleString() : '‚Äî';
          const updated = repo.updated_at ? new Date(repo.updated_at).toLocaleString() : '‚Äî';
          const usd = Math.max(1, (repo.stargazers_count || 0) * 12);
          const div = document.createElement('div'); div.className = 'project';
          div.innerHTML = `<div style="flex:1"><div style="font-weight:700">${repo.name}</div><div class="small">${repo.description || 'No description'}</div><div class="small">Created: ${created} ‚Ä¢ Updated: ${updated}</div></div><div style="text-align:right"><div class="value-pill">$${usd.toLocaleString()}</div><div style="margin-top:8px"><a class="btn" href="${repo.html_url}" target="_blank">Repo</a></div></div>`;
          grid.appendChild(div);
        });
      }catch(e){ logDebug('renderProjects error', e); grid.innerHTML = '<div class="small">Failed to load projects.</div>'; }
    }

    // Simple client scan fallback (works if wallet connected via injected provider)
    async function scanAllHoldingsAndHistoryImproved(){
      if(!wallet){ setStatus('connect wallet first', 'warn'); return; }
      setStatus('Scanning...', 'info');
      try{
        const pk = wallet;
        const res = await connection.getParsedTokenAccountsByOwner(pk, { programId: splToken.TOKEN_PROGRAM_ID }).catch(e=>{
          logDebug('getParsedTokenAccountsByOwner failed', e);
          return null;
        });
        let parsed = [];
        if(res && res.value) parsed = res.value;
        const empty = []; const map = {};
        parsed.forEach(acc=>{
          try{
            const info = acc.account?.data?.parsed?.info;
            const ui = Number(info?.tokenAmount?.uiAmount || 0);
            const mint = info?.mint || null;
            if(ui === 0) empty.push({ pubkey: acc.pubkey.toString(), mint });
            else if(mint) map[mint] = (map[mint]||0) + ui;
          }catch(e){ logDebug('parse error', e, acc); }
        });
        const holdings = Object.keys(map).map(m=>({ mint:m, amount: map[m] }));
        document.getElementById('emptyCount').textContent = String(empty.length);
        const est = empty.length * RENT_PER_EMPTY_ACCOUNT_SOL;
        document.getElementById('refundEstimateBig').textContent = toSol(est) + ' SOL';
        const hp = document.getElementById('holdingsPanel'); hp.innerHTML = '';
        if(holdings.length === 0) hp.innerHTML = '<div class="small">No token holdings found.</div>';
        else {
          const list = document.createElement('div');
          list.className = 'list';
          holdings.forEach(h=>{ const item=document.createElement('div'); item.className='project'; item.innerHTML = `<div style="flex:1"><div class="mono">${h.mint}</div><div class="small">Balance: ${h.amount}</div></div>`; list.appendChild(item); });
          hp.appendChild(list);
        }
        setStatus('Scan complete','success');
      }catch(e){ logDebug('scanAll error', e); setStatus('Scan failed','error'); }
    }

    function toSol(n){ return (Math.round(n*100000)/100000).toFixed(5); }
    const RENT_PER_EMPTY_ACCOUNT_SOL = 0.00204;

    // wire buttons
    document.getElementById('scanBtn').addEventListener('click', ()=> scanAllHoldingsAndHistoryImproved().catch(e=>logDebug(e)));
    document.getElementById('exportReport').addEventListener('click', ()=>{
      const report = { when: new Date().toISOString(), wallet: wallet ? wallet.toBase58() : null, sessionFeed: sessionFeed };
      const blob = new Blob([JSON.stringify(report,null,2)], { type: 'application/json' });
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `recovery-report-${Date.now()}.json`; a.click();
      setStatus('Exported report','success');
    });

    // initial render projects
    (async function init(){ try{ await renderProjects(); logDebug('projects loaded'); }catch(e){ logDebug('init error', e); } })();
  </script>
</body>
</html>
