<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>BarbrickDesign ‚Äî Claim Your SOL</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description" content="Close unused SPL accounts, reclaim rent, prepare manual sells (user-approved), export recovery reports, and support projects." />
  <style>
    :root{
      --bg:#0a0c11; --panel:#0f131a; --muted:#a8b3c7; --text:#eaf1fb;
      --accent:#66fcf1; --good:#3be477; --warn:#fbbf24; --bad:#ff6b6b;
      --stroke:rgba(255,255,255,0.12);
    }
    *{box-sizing:border-box}
    html,body{margin:0;height:100%;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:radial-gradient(1200px 600px at 20% -20%, rgba(102,252,241,0.06), transparent),var(--bg);color:var(--text)}
    a{color:var(--accent);text-decoration:none}
    .wrap{max-width:1200px;margin:0 auto;padding:16px}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .card{background:var(--panel);border:1px solid var(--stroke);border-radius:12px;padding:14px}
    .btn{background:#121827;color:var(--text);border:1px solid #223149;padding:10px 12px;border-radius:10px;cursor:pointer;font-weight:700}
    .btn.ghost{background:transparent;border-color:var(--stroke)}
    .btn.primary{background:linear-gradient(135deg,#121a2b,#172238)}
    .mono{font-family:ui-monospace,Menlo,Consolas}
    .small{font-size:13px;color:var(--muted)}
    .title{font-size:20px;font-weight:800}
    .big{font-size:28px;font-weight:800}
    header{display:flex;flex-direction:column;gap:12px}
    .header-row{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
    .brand{display:flex;gap:12px;align-items:center}
    .glyph{width:40px;height:40px;border-radius:8px;background:conic-gradient(from 200deg,var(--accent),#9b7bff);box-shadow:0 6px 30px rgba(102,252,241,0.08)}
    .wallet-status{padding:6px 10px;border-radius:10px;background:transparent;color:var(--muted);font-size:13px}
    @media(min-width:900px){ header{flex-direction:row} }
    .grid{display:grid;gap:12px}
    @media(min-width:980px){ .grid.two {grid-template-columns:1.4fr .7fr} }
    .stats{display:grid;gap:10px}
    @media(min-width:650px){ .stats{grid-template-columns:repeat(3,1fr)} }
    #debugPanel{position:fixed;bottom:0;left:0;width:100%;max-height:260px;overflow:auto;background:#081018;border-top:1px solid #222;font-family:ui-monospace,Menlo,Consolas;color:#9bd;padding:8px;z-index:99999}
    @media(max-width:600px){ #debugPanel{font-size:11px} }
    .notice{padding:10px;border-radius:10px;background:linear-gradient(180deg,rgba(102,252,241,0.03),transparent);border:1px solid var(--stroke);font-size:13px}
    .projects-grid{display:grid;gap:10px}
    @media(min-width:900px){ .projects-grid{grid-template-columns:repeat(2,1fr)} }
    .project{display:flex;justify-content:space-between;gap:8px;align-items:center;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
    .value-pill{padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);font-weight:700}
    .muted{color:var(--muted);font-size:13px}
    .list{display:grid;gap:8px}
    .feed-row{display:flex;justify-content:space-between;gap:12px}
  </style>

  <!-- libs (order matters) -->
  <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.8/lib/index.iife.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@solana/spl-token@0.3.11/dist/browser/spl-token.min.js"></script>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="header-row">
        <div class="brand">
          <div class="glyph" aria-hidden="true"></div>
          <div>
            <div class="title mono">BarbrickDesign</div>
            <div class="small">Claim your SOL ‚Äî close unused SPL accounts and recover rent.</div>
          </div>
        </div>

        <div class="row" role="toolbar" aria-label="Primary actions">
          <button id="connectBtn" class="btn primary">Connect Wallet</button>
          <button id="openInWalletApp" class="btn ghost" style="display:none">Open in Wallet App</button>
          <span id="walletStatus" class="wallet-status mono">Wallet: not detected</span>
          <a class="btn ghost" href="https://github.com/barbrickdesign" target="_blank" rel="noopener">GitHub</a>
        </div>
      </div>

      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
        <div id="status" class="small">Close unused token accounts to reclaim SOL rent fees safely and securely.</div>
        <div id="refPreview" class="small mono" style="opacity:.85">‚Äî</div>
      </div>
    </header>

    <main style="margin-top:12px">
      <section class="card">
        <div class="title">Solana Blockchain holds your SOL ‚Äî Claim it Back!</div>
        <div class="small" style="margin-top:8px">
          Scan your wallet, close empty token accounts, prepare manual sells for low-value tokens (manual approval required), export a recovery report, and support projects. Every blockchain action requires your explicit wallet approval.
        </div>
      </section>

      <div class="grid two" style="margin-top:12px">
        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:12px">
            <div>
              <div class="small">Connected wallet</div>
              <div id="walletLabel" class="mono big">‚Äî</div>
            </div>
            <div style="text-align:right">
              <div class="small">Estimated refund</div>
              <div id="refundEstimateBig" class="big">0.00000 SOL</div>
            </div>
          </div>

          <div style="margin-top:12px" class="row">
            <button id="scanBtn" class="btn">Scan & Analyze</button>
            <button id="recoverBtn" class="btn ghost">Close Empty Accounts</button>
            <button id="prepareSellBtn" class="btn ghost">Prepare Manual Sells</button>
          </div>

          <div style="margin-top:12px" class="row">
            <input id="refAddress" class="btn mono" style="flex:1;background:transparent;border-radius:10px" placeholder="Optional referrer wallet (?ref=)" />
            <label class="small row" style="gap:8px;align-items:center">
              <input id="donationToggle" type="checkbox" checked />
              <span class="small">Include 5% support</span>
            </label>
          </div>

          <hr style="border:none;height:1px;background:var(--stroke);margin:12px 0" />

          <div class="stats">
            <div class="card" style="text-align:center">
              <div class="small">Empty accounts</div>
              <div id="emptyCount" class="big">0</div>
            </div>
            <div class="card" style="text-align:center">
              <div class="small">Estimated refund</div>
              <div id="refundEstimate" class="big">0.00000 SOL</div>
            </div>
            <div class="card" style="text-align:center">
              <div class="small">Session actions</div>
              <div id="sessionActions" class="big">0</div>
            </div>
          </div>

          <div style="margin-top:10px;display:flex;gap:8px">
            <button id="exportReport" class="btn ghost">Export Recovery Report</button>
            <button id="copySummary" class="btn ghost">Copy Summary</button>
          </div>
        </div>

        <div class="card">
          <div class="small" style="font-weight:800;margin-bottom:8px">Holdings & Recovery Assist</div>
          <div id="holdingsPanel" class="small" style="max-height:360px;overflow:auto">
            <div class="notice">Connect a wallet then run Scan & Analyze to list holdings, empty accounts, and suggested manual sells (each sale requires your approval).</div>
          </div>
        </div>
      </div>

      <section class="card" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="small" style="font-weight:800">Income modules</div>
          <div class="small">Recover, mint, and contribute (token-gated)</div>
        </div>

        <div style="margin-top:10px" class="row">
          <div class="card" style="flex:1">
            <div style="font-weight:800">SOL Recovery Portal</div>
            <div class="small">Close empty SPL token accounts and reclaim rent in bulk with per-transaction approvals.</div>
            <div style="margin-top:8px"><button id="recoverInlineBtn" class="btn">Recover here</button> <a class="btn ghost" href="https://barbrickdesign.github.io/SOLRecovery/" target="_blank">Open</a></div>
          </div>

          <div class="card" style="flex:1">
            <div style="font-weight:800">NFT Minting Portal</div>
            <div class="small">Mint lore-infused sigils and configure creator splits.</div>
            <div style="margin-top:8px"><a class="btn ghost" href="https://barbrickdesign.github.io/NFTMint/" target="_blank">Open</a> <button id="mintSigil" class="btn ghost">Mint (demo)</button></div>
          </div>
        </div>
      </section>

      <section class="card" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="small" style="font-weight:800">Projects</div>
          <div class="small">Analyze repos, estimate USD proxy value, and enable contributions (token-gated)</div>
        </div>

        <div id="projectsArea" style="margin-top:10px">
          <div class="projects-grid" id="projectsGrid">
            <div class="notice small">Loading projects‚Ä¶</div>
          </div>
        </div>
      </section>

      <section class="card" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="small" style="font-weight:800">Counterparty Flow (top receivers)</div>
          <div class="small">Helps you see where SOL moved (best-effort; Solscan & RPC)</div>
        </div>
        <div id="counterpartyPanel" style="margin-top:8px"></div>
      </section>

      <section class="card" style="margin-top:12px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="small" style="font-weight:800">Session Feed</div>
          <div class="small">Recent actions</div>
        </div>
        <div id="feed" style="margin-top:8px;max-height:200px;overflow:auto"></div>
      </section>
    </main>

    <footer style="margin-top:12px" class="small">
      ¬© BarbrickDesign 2025 ¬∑ All actions require explicit wallet approval.
    </footer>
  </div>

  <div id="debugPanel">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <strong>üîç Debug Log</strong>
      <div style="display:flex;gap:8px">
        <button id="dbgHide" class="btn ghost small">Hide</button>
        <button id="dbgClear" class="btn ghost small">Clear</button>
      </div>
    </div>
    <div id="debugLog" style="margin-top:8px;white-space:pre-wrap;max-height:200px;overflow:auto"></div>
  </div>

  <script>
    /* ----------------- Utilities & Debug ----------------- */
    function logDebug(...args){
      const el = document.getElementById('debugLog');
      const line = document.createElement('div');
      line.textContent = `[${new Date().toLocaleTimeString()}] ` + args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');
      el.appendChild(line); el.scrollTop = el.scrollHeight; console.log(...args);
    }
    document.getElementById('dbgClear').addEventListener('click', ()=> document.getElementById('debugLog').innerHTML = '');
    document.getElementById('dbgHide').addEventListener('click', (e)=> {
      const d = document.getElementById('debugLog'); const hidden = d.style.display === 'none';
      d.style.display = hidden ? 'block' : 'none'; e.target.textContent = hidden ? 'Hide' : 'Show';
    });

    const connection = new solanaWeb3.Connection('https://api.mainnet-beta.solana.com', 'confirmed');
    const RENT_PER_EMPTY_ACCOUNT_SOL = 0.00204;
    const DONATION_PCT = 0.05;
    const FEE_WALLET = new solanaWeb3.PublicKey('5hSWosj58ki4A6hSfQrvteQU5QvyCWmhHn4AuqgaQzqr');

    let wallet = null;
    let holdings = [];
    let emptyTokenAccounts = [];
    let sessionFeed = [];

    function setStatus(msg, kind='info'){ const el=document.getElementById('status'); if(!el) return; el.textContent = msg; el.style.color = kind==='error' ? 'var(--bad)' : kind==='warn' ? 'var(--warn)' : kind==='success' ? 'var(--good)' : 'var(--muted)'; }
    function shorten(s){ return s ? (s.slice(0,4) + '...' + s.slice(-4)) : '‚Äî'; }
    function toSol(n){ return (Math.round(n*100000)/100000).toFixed(5); }
    function normPubkey(x){ if(!x) return null; if(x instanceof solanaWeb3.PublicKey) return x; if(x.publicKey && x.publicKey instanceof solanaWeb3.PublicKey) return x.publicKey; try{ return new solanaWeb3.PublicKey(x); } catch { return null; } }

    function getProviderTolerant(){ if(window.solana) return window.solana; return null; }
    async function waitForProvider(timeoutMs=3000, intervalMs=150){ const start=Date.now(); while(Date.now()-start < timeoutMs){ const p=getProviderTolerant(); if(p) return p; await new Promise(r=>setTimeout(r, intervalMs)); } return null; }

    /* ----------------- Mobile deep-link ----------------- */
    function buildPhantomDeepLink(){
      const appUrl = encodeURIComponent(location.origin);
      const redirect = encodeURIComponent(location.href.replace(location.search || '', '') + '?from_phantom=1');
      return `https://phantom.app/ul/v1/connect?app_url=${appUrl}&redirect_url=${redirect}`;
    }
    function promptOpenInWalletApp(){
      try{ localStorage.setItem('awaiting_wallet','1'); }catch(e){ logDebug('localStorage set failed', e) }
      const link = buildPhantomDeepLink(); logDebug('Opening deep link', link);
      try{ location.href = link; }catch(e){ window.open(link, '_blank') }
      setStatus('Opening wallet app... approve connect then return.', 'warn');
    }

    /* ----------------- Connect & Sign ----------------- */
    async function connectAndVerify(){
      setStatus('Attempting wallet connect‚Ä¶');
      logDebug('connect start; mobile?', /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent));
      const provider = await waitForProvider(1500,120) || getProviderTolerant();
      if(!provider){
        if(/Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent)){ promptOpenInWalletApp(); return; }
        setStatus('No wallet detected. Install Phantom or enable extension.','warn'); return;
      }
      try{
        logDebug('provider.connect()');
        const resp = await provider.connect({ onlyIfTrusted:false });
        wallet = (resp && resp.publicKey) ? resp.publicKey : (provider.publicKey || null);
        if(!wallet || !wallet.toBase58) throw new Error('No publicKey returned');
        document.getElementById('walletLabel').textContent = shorten(wallet.toBase58());
        document.getElementById('walletStatus').textContent = 'Wallet: connected';
        logDebug('connected', wallet.toBase58());

        const nonce = Math.floor(Math.random()*1e9).toString();
        const ts = Date.now();
        const message = `BarbrickDesign sign-in\nnonce:${nonce}\nts:${ts}\naddress:${wallet.toBase58()}`;
        const enc = new TextEncoder();
        const msgBytes = enc.encode(message);

        setStatus('Requesting signature from wallet‚Ä¶');
        logDebug('requesting signMessage');
        let signed = null;
        if(typeof provider.signMessage === 'function'){
          try{ signed = await provider.signMessage(msgBytes, 'utf8'); } catch(e){
            signed = await provider.request?.({ method: 'signMessage', params: { message: Array.from(msgBytes) } });
          }
        } else if(typeof provider.request === 'function'){
          signed = await provider.request({ method: 'signMessage', params: { message: Array.from(msgBytes) } });
        } else throw new Error('Wallet does not support signMessage');

        let sigBytes = null;
        if(signed && signed.signature) sigBytes = signed.signature;
        else if(signed && signed.length) sigBytes = signed;
        else if(Array.isArray(signed)) sigBytes = Uint8Array.from(signed);
        if(!sigBytes) throw new Error('No signature returned');

        const sigBuf = sigBytes instanceof Uint8Array ? sigBytes : Uint8Array.from(sigBytes);
        const pubBytes = wallet.toBytes ? wallet.toBytes() : new solanaWeb3.PublicKey(wallet).toBytes();
        const ok = nacl.sign.detached.verify(msgBytes, sigBuf, pubBytes);

        logDebug('signature verified?', ok);
        if(!ok){ setStatus('Signature verification failed.', 'error'); wallet = null; document.getElementById('walletLabel').textContent = '‚Äî'; return; }

        setStatus('Wallet connected and verified', 'success');
        await scanAllHoldingsAndHistoryImproved();
      }catch(err){
        logDebug('connect error', err);
        setStatus('Connection or verification failed.','error'); wallet=null;
        document.getElementById('walletLabel').textContent = '‚Äî';
        document.getElementById('walletStatus').textContent = 'Wallet: not detected';
      }
    }

    // auto-reconnect after deep-link
    window.addEventListener('load', async ()=>{
      try{
        const params = new URLSearchParams(location.search);
        const awaiting = localStorage.getItem('awaiting_wallet');
        if(params.get('from_phantom')==='1' || awaiting === '1'){
          logDebug('Returned from wallet app; waiting for provider...');
          const prov = await waitForProvider(6000,200);
          if(prov){
            try{ localStorage.removeItem('awaiting_wallet'); }catch(_){}
            await connectAndVerify();
            if(params.get('from_phantom')==='1'){ const clean = location.href.replace(/[?&]from_phantom=1/,''); history.replaceState(null,'',clean); }
          } else {
            setStatus('Returned from wallet app but provider not injected. Open site in wallet browser and press Connect.', 'warn');
          }
        }
      }catch(e){ logDebug('autoReconnect error', e); }
    });

    /* ----------------- Scanner & RPC fallback (improved) ----------------- */
    async function retry(fn, attempts=3, delay=300){ let last; for(let i=0;i<attempts;i++){ try{return await fn(); }catch(e){ last=e; await new Promise(r=>setTimeout(r, delay*(i+1))); } } throw last; }
    function tryParseRawTokenAccount(raw){ try{ return { pubkey: raw.pubkey?.toString?raw.pubkey.toString():String(raw.pubkey), account: { data: { parsed: { info: { tokenAmount: { uiAmount: 0 }, mint: 'unknown' } } } } }; }catch(e){ return null; } }

    async function scanTokenAccountsImproved(){
      const pk = normPubkey(wallet) || normPubkey(getProviderTolerant()?.publicKey);
      if(!pk){ setStatus('Connect wallet first.', 'warn'); return { empty:[], holdings:[] }; }
      setStatus('Scanning token accounts and holdings (improved)...');
      try{
        let res;
        try{ res = await retry(()=> connection.getParsedTokenAccountsByOwner(pk, { programId: splToken.TOKEN_PROGRAM_ID }), 2, 250); logDebug('getParsedTokenAccountsByOwner ok, entries:', (res.value||[]).length); }
        catch(errParsed){ logDebug('getParsedTokenAccountsByOwner failed, fallback to getTokenAccountsByOwner', errParsed); const raw = await retry(()=> connection.getTokenAccountsByOwner(pk, { programId: splToken.TOKEN_PROGRAM_ID }), 2, 300); res = { value: raw.value.map(v => tryParseRawTokenAccount(v)).filter(Boolean) }; logDebug('fallback getTokenAccountsByOwner returned', (res.value||[]).length, 'entries'); }

        const parsed = res.value || [];
        const empty = [];
        const map = {};
        parsed.forEach(acc => {
          const info = acc.account && acc.account.data && acc.account.data.parsed && acc.account.data.parsed.info;
          const ui = Number(info?.tokenAmount?.uiAmount || 0);
          const mint = info?.mint || null;
          const pubkey = acc.pubkey?.toString ? acc.pubkey.toString() : String(acc.pubkey);
          if(ui === 0) empty.push({ pubkey, mint });
          else if(mint) map[mint] = (map[mint] || 0) + ui;
        });

        const holdingsArr = Object.keys(map).map(m => ({ mint: m, amount: map[m] }));
        emptyTokenAccounts = empty; holdings = holdingsArr;
        document.getElementById('emptyCount').textContent = String(empty.length);
        const est = empty.length * RENT_PER_EMPTY_ACCOUNT_SOL;
        document.getElementById('refundEstimate').textContent = toSol(est) + ' SOL';
        document.getElementById('refundEstimateBig').textContent = toSol(est) + ' SOL';

        const hp = document.getElementById('holdingsPanel'); hp.innerHTML = '';
        if(holdingsArr.length === 0){
          hp.innerHTML = `<div class="notice">No token holdings found. If you expect tokens, try reconnecting or use a different RPC.</div>`;
        } else {
          const list = document.createElement('div'); list.className='list';
          holdingsArr.forEach(h=>{
            const item = document.createElement('div'); item.className='project';
            item.innerHTML = `<div class="meta"><div class="mono">${h.mint}</div><div class="small">Balance: ${h.amount}</div></div><div><span class="value-pill muted">Est $0</span></div>`;
            list.appendChild(item);
          });
          hp.appendChild(list);
        }

        if(holdingsArr.length === 0) setStatus('No token holdings found in this wallet.', 'warn'); else setStatus(`Found ${holdingsArr.length} token mint(s).`);
        logDebug('scanTokenAccountsImproved result', { emptyCount: empty.length, holdingsCount: holdingsArr.length });
        return { empty, holdings: holdingsArr };
      }catch(e){
        logDebug('scanTokenAccountsImproved failed', e);
        setStatus('Scan failed. Try again.', 'error');
        return { empty:[], holdings:[] };
      }
    }

    async function fetchTransactionsForWalletRobustImproved({ rpcLimit = 250, rpcAlt = 'https://rpc.ankr.com/solana' } = {}){
      const pk = normPubkey(wallet) || normPubkey(getProviderTolerant()?.publicKey);
      if(!pk){ logDebug('fetchTransactionsForWalletRobustImproved: no pubkey'); return { source:'none', txs:[] }; }
      try{
        setStatus('Fetching signatures via RPC (primary)...');
        const sigInfos = await retry(()=> connection.getSignaturesForAddress(pk, { limit: rpcLimit }), 2, 350);
        if(!Array.isArray(sigInfos) || sigInfos.length === 0){ logDebug('primary RPC returned no signatures'); return { source:'rpc', txs: [] }; }
        const signatures = sigInfos.map(s => s.signature);
        const parsed = []; const batchSize = 20;
        for(let i=0;i<signatures.length;i+=batchSize){
          const chunk = signatures.slice(i, i+batchSize);
          const resolved = await Promise.all(chunk.map(sig => retry(()=> connection.getParsedTransaction(sig, 'confirmed'), 2, 200).catch(e=>{ logDebug('getParsedTransaction fail', sig, e); return null; })));
          parsed.push(...resolved.filter(Boolean));
          await new Promise(r=>setTimeout(r,150));
        }
        logDebug('primary RPC parsed txs', parsed.length);
        return { source:'rpc', txs: parsed };
      } catch(ePrimary){
        logDebug('primary RPC failed', ePrimary);
        try{
          setStatus('Primary RPC failed. Trying alternate RPC node...');
          const altConn = new solanaWeb3.Connection(rpcAlt, 'confirmed');
          const sigInfos = await retry(()=> altConn.getSignaturesForAddress(pk, { limit: rpcLimit }), 2, 400);
          if(!Array.isArray(sigInfos) || sigInfos.length === 0){ logDebug('alt RPC returned no signatures'); return { source:'alt-rpc', txs: [] }; }
          const signatures = sigInfos.map(s => s.signature);
          const parsed = []; const batchSize = 20;
          for(let i=0;i<signatures.length;i+=batchSize){
            const chunk = signatures.slice(i, i+batchSize);
            const resolved = await Promise.all(chunk.map(sig => retry(()=> altConn.getParsedTransaction(sig, 'confirmed'), 2, 250).catch(e=>{ logDebug('alt getParsedTransaction fail', sig, e); return null; })));
            parsed.push(...resolved.filter(Boolean));
            await new Promise(r=>setTimeout(r,150));
          }
          logDebug('alt RPC parsed txs', parsed.length);
          return { source:'alt-rpc', txs: parsed };
        } catch(eAlt){
          logDebug('alternate RPC failed too', eAlt);
          setStatus('Failed to fetch transactions (RPC nodes failing).', 'error');
          return { source:'none', txs: [] };
        }
      }
    }

    async function fetchTransactionsForWallet({ solscanPages = 2, solscanLimit = 50, rpcLimit = 250 } = {}){
      const pk = normPubkey(wallet) || normPubkey(getProviderTolerant()?.publicKey);
      if(!pk) return { source:'none', txs: [] };
      const addr = pk.toBase58();
      try{
        const all=[];
        for(let p=0;p<solscanPages;p++){
          const offset = p * solscanLimit;
          const url = `https://public-api.solscan.io/account/transactions?address=${addr}&limit=${solscanLimit}&offset=${offset}`;
          logDebug('Solscan fetch', url);
          const r = await fetch(url);
          if(!r.ok){ logDebug('Solscan non-ok', r.status); throw new Error('Solscan non-ok ' + r.status); }
          const j = await r.json();
          if(!Array.isArray(j) || j.length === 0) break;
          all.push(...j);
          if(j.length < solscanLimit) break;
          await new Promise(r=>setTimeout(r,250));
        }
        logDebug('Solscan returned tx count', all.length);
        if(all.length > 0) return { source:'solscan', txs: all };
      }catch(e){
        logDebug('Solscan fetch failed; falling back to RPC', e);
      }
      return fetchTransactionsForWalletRobustImproved({ rpcLimit });
    }

    function analyzeTransactionsForFlowsUnified(raw){
      if(!wallet) return [];
      const our = normPubkey(wallet).toBase58();
      const flows = {};
      const txs = raw.txs || [];

      if(raw.source === 'solscan'){
        for(const tx of txs){
          const native = tx.nativeTransfers || tx.nativeTransfer || tx.native || [];
          for(const nt of native){
            const from = nt.from, to = nt.to;
            const lam = Math.round(Number(nt.amount || 0) * solanaWeb3.LAMPORTS_PER_SOL);
            if(from === our){ flows[to] = flows[to] || { in:0, out:0 }; flows[to].out += lam; }
            if(to === our){ flows[from] = flows[from] || { in:0, out:0 }; flows[from].in += lam; }
          }
        }
      } else {
        for(const tx of txs){
          try{
            const message = tx.transaction?.message;
            if(!message) continue;
            const instrs = message.instructions || [];
            for(const ins of instrs){
              if(ins.parsed && ins.parsed.type === 'transfer' && ins.parsed.info){
                const from = ins.parsed.info.source || ins.parsed.info.from;
                const to = ins.parsed.info.destination || ins.parsed.info.to;
                const lam = Number(ins.parsed.info.lamports || Math.round((ins.parsed.info.amount || 0) * solanaWeb3.LAMPORTS_PER_SOL || 0));
                if(from === our){ flows[to] = flows[to] || { in:0, out:0 }; flows[to].out += lam; }
                if(to === our){ flows[from] = flows[from] || { in:0, out:0 }; flows[from].in += lam; }
              }
            }
          }catch(e){ logDebug('analyze RPC tx error', e); }
        }
      }

      const summary = Object.keys(flows).map(addr => {
        const inLam = flows[addr].in || 0;
        const outLam = flows[addr].out || 0;
        return { addr, inSol: (inLam/solanaWeb3.LAMPORTS_PER_SOL).toFixed(5), outSol: (outLam/solanaWeb3.LAMPORTS_PER_SOL).toFixed(5), netOutFromUs: ((outLam-inLam)/solanaWeb3.LAMPORTS_PER_SOL).toFixed(5) };
      }).sort((a,b)=> Number(b.netOutFromUs) - Number(a.netOutFromUs));

      return summary;
    }

    function renderCounterpartySummary(summary){
      const panel=document.getElementById('counterpartyPanel'); panel.innerHTML='';
      if(!summary || summary.length===0){ panel.innerHTML=`<div class="small">No recent SOL flows found for this wallet.</div>`; return; }
      const list=document.createElement('div'); list.className='list';
      summary.slice(0,10).forEach(s=>{
        const item=document.createElement('div'); item.className='project';
        item.innerHTML = `<div class="meta"><div class="mono">${shorten(s.addr)}</div><div class="small">net out: ${s.netOutFromUs} SOL ‚Äî out ${s.outSol} / in ${s.inSol}</div></div><div><button class="btn ghost small" onclick="window.open('https://explorer.solana.com/address/${s.addr}','_blank')">Explorer</button></div>`;
        list.appendChild(item);
      });
      panel.appendChild(list);
    }

    /* ----------------- Projects with valuation (no placeholder) ----------------- */
    const PROJECTS_JSON_URL = './projects.json';
    const PROJECT_VALUE_PER_STAR_USD = 10;

    async function loadProjectsList(){
      try{
        const r = await fetch(PROJECTS_JSON_URL);
        if(r.ok){
          const j = await r.json();
          if(Array.isArray(j) && j.length>0) return j;
        }
      }catch(e){ logDebug('projects.json fetch failed', e); }
      // fallback to GitHub repos
      try{
        const r = await fetch('https://api.github.com/users/barbrickdesign/repos?per_page=100');
        if(!r.ok) throw new Error('GitHub API non-ok ' + r.status);
        const repos = await r.json();
        return repos.map(repo => ({
          name: repo.name,
          repo: repo.name,
          description: repo.description,
          html_url: repo.html_url,
          stargazers_count: repo.stargazers_count || 0,
          siteRoot: `https://barbrickdesign.github.io/${repo.name}/`,
          agency: repo.owner?.login || null,
          gateMint: null
        }));
      }catch(e){
        logDebug('GitHub fallback for projects failed', e);
        return [];
      }
    }

    async function renderProjects(){
      const grid = document.getElementById('projectsGrid'); grid.innerHTML='';
      const list = await loadProjectsList();
      if(!list || list.length === 0){ grid.innerHTML = '<div class="notice small">No projects found.</div>'; return; }

      for(const p of list){
        const el = document.createElement('div'); el.className='project';
        const repoName = p.repo || p.name || (p.html_url||'').split('/').pop();
        const stars = p.stargazers_count || 0;
        const estimatedUSD = (stars * PROJECT_VALUE_PER_STAR_USD).toFixed(0);
        const agency = (p.agency || p.description || 'Independent').slice(0,120);
        el.innerHTML = `
          <div class="meta">
            <div style="font-weight:800">${repoName}</div>
            <div class="small muted">${p.description || 'No description'}</div>
            <div class="small muted">Agency: ${agency}</div>
          </div>
          <div style="display:flex;flex-direction:column;align-items:flex-end;gap:8px">
            <div class="value-pill" title="Stars‚ÜíUSD proxy">$${estimatedUSD}</div>
            <div style="display:flex;gap:8px">
              <a class="btn ghost small" href="${p.html_url || (p.siteRoot||'#')}" target="_blank">Repo</a>
              <button class="btn small contribute" data-gate="${p.gateMint||''}" data-repo="${repoName}">Contribute</button>
            </div>
          </div>
        `;
        grid.appendChild(el);
      }
      enableProjectContributeButtons();
    }

    async function enableProjectContributeButtons(){
      const buttons = document.querySelectorAll('#projectsGrid .contribute');
      if(!buttons || buttons.length === 0) return;
      if(!wallet){
        buttons.forEach(b => { b.disabled = true; b.title = 'Connect wallet to contribute'; });
        return;
      }
      let ownedMints = new Set();
      try{
        const res = await connection.getParsedTokenAccountsByOwner(wallet, { programId: splToken.TOKEN_PROGRAM_ID });
        (res.value||[]).forEach(acc=>{
          const info = acc.account?.data?.parsed?.info;
          if(info && Number(info.tokenAmount?.uiAmount || 0) > 0) ownedMints.add(info.mint);
        });
      }catch(e){ logDebug('enableProjectContributeButtons: token fetch failed', e); }

      buttons.forEach(b=>{
        const gate = b.dataset.gate || '';
        if(!gate){ b.disabled = false; b.title = 'Open contribution (wallet approval required)'; }
        else { b.disabled = !ownedMints.has(gate); b.title = b.disabled ? 'Requires gate token' : 'Contribute (wallet approval required)'; }

        b.onclick = async (ev) => {
          if(b.disabled){ alert('You do not meet the token-gate for this project.'); return; }
          const repo = b.dataset.repo;
          if(!confirm(`Contribute to ${repo}? This will open a wallet approval dialog.`)) return;
          try{
            const tx = new solanaWeb3.Transaction().add(
              solanaWeb3.SystemProgram.transfer({ fromPubkey: wallet, toPubkey: FEE_WALLET, lamports: Math.round(0.001 * solanaWeb3.LAMPORTS_PER_SOL) })
            );
            tx.feePayer = wallet;
            tx.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
            const provider = getProviderTolerant();
            if(!provider) throw new Error('No provider for signing contribution');
            let sig;
            if(typeof provider.signAndSendTransaction === 'function'){
              const res = await provider.signAndSendTransaction(tx);
              sig = res.signature || res;
              await connection.confirmTransaction(sig, 'confirmed');
            } else if(typeof provider.signTransaction === 'function'){
              const signed = await provider.signTransaction(tx);
              const raw = signed.serialize();
              sig = await connection.sendRawTransaction(raw);
              await connection.confirmTransaction(sig, 'confirmed');
            } else throw new Error('Provider has no signing methods');
            addFeedItem(wallet.toBase58(), 0, 0.001, sig, new Date());
            setStatus('Contribution sent. Thank you!', 'success');
          }catch(err){ logDebug('contribution failed', err); setStatus('Contribution failed. See debug log.', 'error'); }
        };
      });
    }

    /* ----------------- High-level scan and other flows ----------------- */
    async function scanAllHoldingsAndHistoryImproved(){
      setStatus('Starting comprehensive scan (improved)...');
      const tokenRes = await scanTokenAccountsImproved();
      if(tokenRes.holdings.length === 0) setStatus('No token holdings detected. Scan complete.', 'warn');
      const txBundle = await fetchTransactionsForWallet({ solscanPages:2, solscanLimit:50, rpcLimit:200 });
      const flows = analyzeTransactionsForFlowsUnified(txBundle);
      renderCounterpartySummary(flows);
      logDebug('scan finished', { tokenRes, txCount: (txBundle.txs||[]).length, flowsLength: flows.length });
      await renderProjects();
    }

    async function signSendWithProvider(tx){
      const provider = getProviderTolerant();
      if(!provider) throw new Error('No provider for signing');
      if(typeof provider.signAndSendTransaction === 'function'){
        const res = await provider.signAndSendTransaction(tx);
        const sig = res.signature || res;
        await connection.confirmTransaction(sig, 'confirmed');
        return sig;
      } else if(typeof provider.signTransaction === 'function'){
        const signed = await provider.signTransaction(tx);
        const raw = signed.serialize();
        const id = await connection.sendRawTransaction(raw);
        await connection.confirmTransaction(id, 'confirmed');
        return id;
      } else throw new Error('Provider has no signing methods');
    }

    async function closeEmptyAccounts(){
      if(!wallet){ setStatus('Connect wallet first.', 'warn'); return; }
      if(emptyTokenAccounts.length === 0){ setStatus('No empty accounts to close.', 'warn'); return; }
      if(!confirm(`Close ${emptyTokenAccounts.length} empty account(s)? Each will require wallet approval.`)) return;
      setStatus('Preparing close transactions... approve each in your wallet.');
      for(const acc of emptyTokenAccounts){
        const tx = new solanaWeb3.Transaction().add(
          splToken.createCloseAccountInstruction(new solanaWeb3.PublicKey(acc.pubkey), wallet, wallet, [])
        );
        tx.feePayer = wallet;
        tx.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
        try{
          const sig = await signSendWithProvider(tx);
          addFeedItem(wallet.toBase58(), 1, RENT_PER_EMPTY_ACCOUNT_SOL, sig, new Date());
          logDebug('closed', acc.pubkey, sig);
        }catch(e){ logDebug('close failed', acc.pubkey, e); setStatus('Some closes failed; check debug log','warn'); }
        await new Promise(r=>setTimeout(r,200));
      }
      await scanTokenAccountsImproved();
      setStatus('Close process finished.','success');
    }

    function prepareManualSells(){
      if(holdings.length === 0){ setStatus('No holdings to propose sells for.','warn'); return; }
      const panel = document.getElementById('holdingsPanel'); panel.innerHTML = '';
      const smalls = holdings.filter(h => h.amount && Number(h.amount) < 1.5);
      if(smalls.length === 0){ panel.innerHTML = '<div class="small">No obvious small-balance tokens found for manual sell proposals.</div>'; return; }
      const list = document.createElement('div'); list.className='list';
      smalls.forEach(h=>{
        const row = document.createElement('div'); row.className='project';
        row.innerHTML = `<div class="meta"><div class="mono">${h.mint}</div><div class="small">Balance: ${h.amount}</div></div><div><button class="btn small" data-mint="${h.mint}">Prepare Sell (manual)</button></div>`;
        list.appendChild(row);
      });
      panel.appendChild(list);
      setStatus('Prepared manual sell proposals; executing sells requires explicit, per-transaction approval.','info');
    }

    function addFeedItem(walletAddr, accounts, sol, sig, date){
      sessionFeed.unshift({ wallet: walletAddr, accounts, sol, sig, date: date.toISOString() });
      renderFeed();
    }
    function renderFeed(){ const f=document.getElementById('feed'); f.innerHTML=''; sessionFeed.slice(0,24).forEach(it=>{ const row=document.createElement('div'); row.className='feed-row small'; row.textContent = `${shorten(it.wallet)} ‚Ä¢ accounts ${it.accounts} ‚Ä¢ ${toSol(it.sol)} SOL ‚Ä¢ ${shorten(it.sig||'')} ‚Ä¢ ${new Date(it.date).toLocaleString()}`; f.appendChild(row); }); }

    /* ----------------- UI wiring ----------------- */
    document.getElementById('connectBtn').addEventListener('click', connectAndVerify);
    document.getElementById('openInWalletApp').addEventListener('click', promptOpenInWalletApp);
    document.getElementById('scanBtn').addEventListener('click', scanAllHoldingsAndHistoryImproved);
    document.getElementById('recoverBtn').addEventListener('click', closeEmptyAccounts);
    document.getElementById('prepareSellBtn').addEventListener('click', prepareManualSells);
    document.getElementById('exportReport').addEventListener('click', ()=>{
      const report = { when: new Date().toISOString(), wallet: wallet ? wallet.toBase58() : null, holdings, emptyTokenAccounts, sessionFeed };
      const blob = new Blob([JSON.stringify(report,null,2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `recovery-report-${Date.now()}.json`; a.click(); URL.revokeObjectURL(url);
      setStatus('Recovery report exported.', 'success');
    });

    // initial projects render
    (async function init(){ await renderProjects(); window._bd = { connectAndVerify, scanAllHoldingsAndHistoryImproved, closeEmptyAccounts, prepareManualSells, renderProjects, logDebug }; })();
  </script>
</body>
</html>
