<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>SanctumLink ✝️ — Sovereign Atlas + $LINK Hub (Deployable + Auto-Populate + Watchdogs)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script>
// Define logStep early to avoid ReferenceError
function logStep(message) {
  console.log(`[STEP] ${message}`);
}

// Ensure buffer shim is applied early
(function applyEarlyBufferShim() {
  if (!window.Buffer) {
    window.Buffer = {
      from: (s) => new TextEncoder().encode(String(s)),
      alloc: (n) => new Uint8Array(n),
    };
    console.log('Early buffer shim applied');
  }
})();

// Fix syntax errors by ensuring script blocks are balanced
// Ensure no stray tokens or unclosed blocks exist
</script>
</head>
<body>
<div class="wrap">
  <div id="diagStatus" class="small mono">Status: ready</div>
  <div id="rewardView" class="small mono rewardView">Rewards: 0</div>
  </div>
  <div id="diagBanner" class="diag-banner diag-hidden">Diagnostics</div>

  <script>
    // Delegate quick profile link buttons to the main connect/disconnect handlers
    document.addEventListener('DOMContentLoaded', function(){
      try{
        const cq = document.getElementById('connectQuick');
        const dq = document.getElementById('disconnectQuick');
        const conn = document.getElementById('connectPhantom');
        const disc = document.getElementById('disconnectPhantom');
        if(cq && conn){ cq.addEventListener('click', ()=> conn.click()); }
        if(dq && disc){ dq.addEventListener('click', ()=> disc.click()); }
        // Mirror enabled/disabled state from the main buttons
        const sync = ()=>{
          if(conn && cq) cq.disabled = conn.disabled;
          if(disc && dq) dq.disabled = disc.disabled;
          const wv = document.getElementById('walletView');
          const pv = document.getElementById('profileName');
          if(wv && pv){ pv.textContent = wv.textContent && wv.textContent !== '—' ? ('@'+wv.textContent.slice(0,8)) : '@agentRB'; }
        };
        setInterval(sync, 800);
      }catch(e){ console.warn('Profile quick-wire failed', e); }
    });
  </script>

  <!-- ATLAS -->
  <div class="card panel" id="panel-atlas">
    <h2>Global atlas</h2>
    <div class="grid g-2">
      <div>
        <div class="row tip">
          <b>Connect wallet</b> <span class="small">(Phantom)</span>
          <div class="bubble">Connect your Solana wallet for validation, peace marking, and orders.</div>
        </div>
  <div class="row row-flex">
          <button class="btn" id="connectPhantom">Connect Phantom</button>
          <button class="btn btn-secondary" id="disconnectPhantom" disabled>Disconnect</button>
          <span class="small mono" id="walletView">—</span>
        </div>
        <div class="row row-flex-sm tool-row">
          <button class="btn btn-ghost" id="addTestAddr">Add test address</button>
          <button class="btn btn-ghost" id="clearAddrs">Clear poll addresses</button>
        </div>

        <div class="row tip">
          <b>Geoapify API key (optional)</b>
          <div class="bubble">Enter your API key to ingest places of worship in real time. Otherwise, auto‑populated sanctums are shown.</div>
        </div>
        <div class="row"><input id="geoKey" placeholder="Enter Geoapify API key for live ingestion"></div>

        <div class="row tip">
          <b>Ingest sanctums</b>
          <div class="bubble">Use your location or coordinates + radius to fetch sanctums. Auto‑seeded sanctums are already loaded.</div>
        </div>
        <div class="row"><button class="btn" id="detect">Detect & ingest</button></div>
  <div class="row row-flex-sm">
          <input id="lat" placeholder="Lat" />
          <input id="lon" placeholder="Lon" />
          <input id="rad" value="20000" placeholder="Radius m" />
        </div>
        <div class="row"><button class="btn btn-secondary" id="ingest">Ingest region</button> <span class="small" id="ingestStatus"></span></div>

        <div class="row tip">
          <b>Add my place of worship</b>
          <div class="bubble">Submit a sanctum. 3+ coin holders must verify to illuminate it.</div>
        </div>
        <div class="row"><input id="addName" placeholder="Sanctum name" /></div>
        <div class="row"><input id="addAddr" placeholder="Address (optional)" /></div>
  <div class="row row-flex-nwrap">
          <input id="addLat" placeholder="Lat" /><input id="addLon" placeholder="Lon" />
        </div>
        <div class="row"><textarea id="addDesc" placeholder="Description / denomination (optional)"></textarea></div>
        <div class="row"><button class="btn" id="addSubmit">Submit sanctum for verification</button> <span class="small" id="addStatus"></span></div>

        <div class="row">
          <div class="pill">Self‑checks</div>
          <div class="row small">• <span id="t-wallet" class="warn">Wallet connected</span></div>
          <div class="row small">• <span id="t-geo" class="warn">Places ingested</span></div>
          <div class="row small">• <span id="t-qr" class="warn">QR working</span></div>
          <div class="row small">• <span id="t-helix" class="warn">Helix live (tx stream)</span></div>
          <div class="row small">• <span id="t-watch" class="warn">Watchdog healthy</span></div>
          <div class="row small">• <span id="t-seed" class="warn">Auto‑populated sanctums loaded</span></div>
        </div>

        <div class="row row-flex-sm">
          <button class="btn-ghost" id="exportState">Export state</button>
          <label for="importFile" class="small label-inline">Import state</label>
          <input id="importFile" type="file" accept="application/json" class="hidden" aria-label="Import state file" />
          <button class="btn-ghost ml-6" id="importState">Import (open)</button>
          <span class="small mono" id="createdStamp"></span>
        </div>
      </div>

      <div>
        <div id="stage">
          <div id="globe" aria-label="Global map"></div>
          <div id="helix3d" aria-label="Double helix visualization"></div>
          <div id="legend">
            <div class="lg"><span class="c c-buy"></span> Buy</div>
            <div class="lg"><span class="c c-sell"></span> Sale</div>
            <div class="lg"><span class="c c-xfer"></span> Transfer</div>
            <div class="lg"><span class="c c-peace"></span> Peace mark ✌️</div>
            <div class="lg"><span class="c c-offgrid"></span> Off‑grid beacon</div>
          </div>
        </div>
      </div>
          <!-- BOARD -->
          <div class="card panel panel-hidden" id="panel-board">
            <h2>Sanctums — Board View</h2>
            <div class="row row-flex-sm">
              <input id="boardFilter" placeholder="Search name or address" class="mono" />
              <select id="boardSort"><option value="mcap_desc">Market cap ↓</option><option value="mcap_asc">Market cap ↑</option><option value="name_asc">Name A→Z</option><option value="name_desc">Name Z→A</option></select>
              <button class="btn" id="boardExport">Export CSV</button>
            </div>
            <div id="boardTableWrap" style="margin-top:12px;">
              <table id="boardTable" class="small" style="width:100%; border-collapse:collapse;">
                <thead><tr><th style="text-align:left">Name</th><th>Location</th><th>mcap USD</th><th>Rank</th><th>Off‑grid</th></tr></thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
    </div>
            <script>
              function renderBoard(){
                try{
                  const filter = (document.getElementById('boardFilter')||{value:''}).value.toLowerCase().trim();
                  const sort = (document.getElementById('boardSort')||{value:'mcap_desc'}).value;
                  let arr = (S.places||[]).slice();
                  if(filter){ arr = arr.filter(p=> (p.name||'').toLowerCase().includes(filter) || (p.address||'').toLowerCase().includes(filter)); }
                  if(sort==='mcap_desc') arr.sort((a,b)=>(b.mcapUSD||0)-(a.mcapUSD||0));
                  if(sort==='mcap_asc') arr.sort((a,b)=>(a.mcapUSD||0)-(b.mcapUSD||0));
                  if(sort==='name_asc') arr.sort((a,b)=>(String(a.name||'').localeCompare(String(b.name||''))));
                  if(sort==='name_desc') arr.sort((a,b)=>(String(b.name||'').localeCompare(String(a.name||''))));
                  const tbody = document.querySelector('#boardTable tbody'); if(!tbody) return;
                  tbody.innerHTML = arr.map(p=>`<tr><td style="padding:6px">${p.name}</td><td>${p.address||''}</td><td style="text-align:right">$${(p.mcapUSD||0).toFixed(0)}</td><td style="text-align:center">${p.rank||0}</td><td style="text-align:center">${S.offGrid.has(p.id)?'⚡':''}</td></tr>`).join('');
                }catch(e){ console.warn('renderBoard failed', e); }
              }
              document.addEventListener('DOMContentLoaded', ()=>{
                const f = document.getElementById('boardFilter'); if(f) f.addEventListener('input', renderBoard);
                const s = document.getElementById('boardSort'); if(s) s.addEventListener('change', renderBoard);
                const ex = document.getElementById('boardExport'); if(ex) ex.addEventListener('click', ()=>{
                  const rows = [['Name','Address','mcapUSD','rank','offgrid']].concat((S.places||[]).map(p=>[p.name||'', p.address||'', p.mcapUSD||0, p.rank||0, S.offGrid.has(p.id)?1:0]));
                  const csv = rows.map(r=> r.map(c=>`"${String(c).replace(/"/g,'""')}"`).join(',')).join('\n');
                  const a=document.createElement('a'); a.href = URL.createObjectURL(new Blob([csv],{type:'text/csv'})); a.download='sanctums_board.csv'; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),2000);
                });
                // initial render when S is available
                try{ renderBoard(); }catch(e){}
              });
            </script>

    <h3>Sanctums</h3>
    <div class="grid g-2">
      <div>
        <div id="list"></div>
      </div>
      <div>
        <h4>Pending sanctums (need verification)</h4>
        <div id="pendingList" class="small">None pending.</div>
      </div>
    </div>
  </div>

  <!-- HUB -->
  <div class="card panel panel-hidden" id="panel-hub">
    <h2>$LINK✝️ hub</h2>
    <div class="grid g-3">
      <div>
        <div class="row"><b>Sanctum Vault</b><div class="mono" id="mainVault">BVnVEfipjrx8cDVqUSCJ1ZjwyrU3kVMebwac3cnGhLB</div></div>
        <div class="row"><b>Top sanctuaries</b><div id="topList"></div></div>
      </div>
      <div>
        <div class="row tip">
          <b>Generate QR for sanctum</b>
          <div class="bubble">Create a scannable beacon for presence and donations. Download and place physically or share virtually.</div>
        </div>
  <div class="row row-flex-sm">
  <div class="row row-flex-sm">
          <label for="qrSelect" class="visually-hidden">Select sanctum for QR</label>
          <select id="qrSelect" aria-label="Select sanctum for QR"></select>
          <button class="btn" id="mkQR">Generate QR</button>
          <button class="btn btn-secondary" id="dlQR" disabled>Download QR</button>
        </div>
  <canvas id="qrCanvas" class="qr-canvas hidden"></canvas>
      </div>
      <div>
        <div class="row tip">
          <b>Wallet validation via Pump.fun</b>
          <div class="bubble">Open Pump.fun with your wallet as referrer to validate activity and presence.</div>
        </div>
        <div class="small">Create or verify a token on Pump.fun:</div>
  <div class="row row-flex-sm">
          <input id="pfName" placeholder="Proposed token name (optional)" />
          <button class="btn" id="openPump">Open Pump.fun</button>
        </div>
      </div>
    </div>

    <h3>Link checks</h3>
    <div class="grid g-2">
      <div>
        <div class="row"><label>Solscan vault URL</label><input id="linkSolscan" placeholder="https://solscan.io/account/BVnV..."><div class="bar"><div class="fill" id="sbSolscan"></div></div></div>
        <div class="row"><label>Public site URL</label><input id="linkSite" placeholder="https://sanctum.link"><div class="bar"><div class="fill" id="sbSite"></div></div></div>
      </div>
      <div>
        <div class="row"><label>Data API health (optional)</label><input id="linkAPI" placeholder="https://api.sanctum.link/health"><div class="bar"><div class="fill" id="sbAPI"></div></div></div>
        <div class="row"><button class="btn" id="testAll">Test all links</button> <span class="small" id="testAllResult"></span></div>
      </div>
    </div>
  </div>

  <!-- ORDERS -->
  <div class="card panel panel-hidden" id="panel-orders">
    <h2>Orders — Stickers and Eternal Plaques</h2>
    <div class="grid g-2">
      <div>
        <div class="pill">Order QR stickers (drop‑ship; dual‑signature)</div>
  <div class="row"><label for="ordSanctum">Sanctum</label><select id="ordSanctum" aria-label="Sanctum for order"></select></div>
  <div class="row"><label for="ordSanctum">Sanctum</label><select id="ordSanctum" aria-label="Sanctum for order"></select></div>
  <div class="row"><label for="ordQty">Quantity</label><input id="ordQty" type="number" min="10" value="50" aria-label="Order quantity"></div>
        <div class="row"><label>Ship to (place of worship)</label><textarea id="ordShip" placeholder="Sanctum shipping address"></textarea></div>
        <div class="row"><button class="btn" id="genNonce">Generate validation nonce</button> <span class="mono small" id="nonceView"></span></div>
        <div class="row"><label>Donation signature (TXID)</label><input id="donTxid" placeholder="Paste transaction signature"></div>
        <div class="row"><label>Donation memo (nonce)</label><input id="donMemo" placeholder="Paste the nonce you included in memo"></div>
        <div class="row"><button class="btn btn-secondary" id="validateOrder">Validate donation & create order</button> <span class="small" id="orderStatus"></span></div>
        <h4>Drop‑shipper receipt (required)</h4>
        <div class="row"><label>Drop‑shipper wallet</label><input id="dsWallet" placeholder="e.g., walletDS1"></div>
        <div class="row"><label>Drop‑shipper signature</label><input id="dsSig" placeholder="Paste receipt signature"></div>
        <div class="row"><button class="btn" id="fulfillOrder">Mark fulfilled</button> <span class="small" id="fulfillStatus"></span></div>
      </div>

      <div>
        <div class="pill">Order eternal plaque (Thai metals; dual‑signature)</div>
  <div class="row"><label for="plqSanctum">Sanctum</label><select id="plqSanctum" aria-label="Sanctum for plaque"></select></div>
        <div class="row"><label>Material</label>
        <div class="row"><label for="plqSanctum">Sanctum</label><select id="plqSanctum" aria-label="Sanctum for plaque"></select></div>
          <label for="plqMaterial" class="visually-hidden">Material</label>
          <select id="plqMaterial" aria-label="Plaque material">
            <option value="bronze">Bronze</option>
            <option value="stainless">Stainless steel</option>
          </select>
        </div>
  <script>(async function(){
  // ====== Self-heal & engagement module ======
  const SelfHeal = (function(){
    // Simple pattern-based auto-fixes. This is intentionally conservative.
    const fixes = [
      {
        name: 'inject-web3-umd',
        match: /inject-web3-umd|web3 not loaded/i,
        fix: function(){
          // Prefer a local vendor file for reliability, otherwise fall back to CDN UMD
          if(window.solanaWeb3 || window.solana_web3 || window.solanaweb3 || window.solana) return 'already-umd';
          const localPaths = ['/vendor/@solana_web3.umd.js','/vendor/index.browser.umd.js','/vendor/solana-web3.umd.js'];
          let chosen = null;
          for(const p of localPaths){ try{ const req = new Request(p, { method:'HEAD' }); fetch(req).then(r=>{ if(r.ok){ const s = document.createElement('script'); s.src = p; s.crossOrigin='anonymous'; document.head.appendChild(s); logStep('SelfHeal: injected local web3 UMD '+p); } }).catch(()=>{}); }catch(e){} }
          // Also inject CDN as fallback
          const url = 'https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.3/lib/index.browser.umd.js';
          const s = document.createElement('script'); s.src = url; s.crossOrigin='anonymous';
          s.onload = function(){
            try{
              const umd = window.solanaWeb3 || window.solana_web3 || window.solanaweb3 || window.solana;
              if(umd){ try{ Connection = umd.Connection; PublicKey = umd.PublicKey; if(Connection) Connection.isShim = false; }catch(e){ console.warn('SelfHeal wiring web3 UMD failed', e); }
                try{ if(typeof S !== 'undefined'){ S.connectionIsShim = !!(Connection && Connection.isShim); S.connection = new Connection(clusterApiUrl("mainnet-beta"), "confirmed"); } }catch(e){}
                logStep('SelfHeal: web3 UMD loaded and wired');
              }
            }catch(e){ console.warn('SelfHeal onload handler error', e); }
          };
          document.head.appendChild(s);
          return 'injected-web3-umd';
        }
      },
      {
        name: 'web3-buffer-fix',
        match: /Failed to resolve module specifier 'buffer'/i,
        fix: function(){
          // Attempt to inject a lightweight buffer shim and fallback loader
          if(window.Buffer) return 'already-buffer';
          const s = document.createElement('script');
          s.textContent = `window.Buffer = { from: (s)=> new TextEncoder().encode(String(s)) };`;
          document.head.appendChild(s);
          return 'injected-buffer-shim';
        }
      },
      {
        name: 'three-cdn-fallback',
        match: /Three\.js|THREE is not defined|three is not defined/i,
        fix: function(){
          if(window.THREE) return 'already-three';
          const url = 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js';
          const s = document.createElement('script'); s.src = url; s.crossOrigin='anonymous';
          document.head.appendChild(s);
          return 'injected-three-fallback';
        }
      }
    ];

    function analyzeAndFix(msg){
      for(const f of fixes){
        try{ if(f.match.test(msg)){ const res=f.fix(); logStep('SelfHeal: applied '+f.name+' -> '+res); return {applied:f.name, result:res}; } }catch(e){ console.warn('SelfHeal fix failed', e); }
      }
      return null;
    }

    // Keep a tiny history of console errors for analysis
    const history = [];
    function record(errMsg){ history.push({ts:new Date().toISOString(), msg:errMsg}); if(history.length>200) history.shift(); }

    // Public API
    return {
      record,
      analyzeAndFix,
      history,
      runAutoHeal(count=3){
        let applied=0;
        for(let i=0;i<count;i++){
          const entry = history[history.length-1-i];
          if(!entry) break;
          const r = analyzeAndFix(entry.msg);
          if(r) applied++; 
        }
        return applied;
      }
    };
  })();
  try{
    // Try ESM dynamic import first (modern browsers)
    const mod = await import("https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.3/lib/index.browser.esm.js");
    Connection = mod.Connection; PublicKey = mod.PublicKey; clusterApiUrl = mod.clusterApiUrl;
  const _ds1 = document.getElementById('diagStatus'); if(_ds1) _ds1.textContent = 'Status: web3 (esm) loaded';
  }catch(err){
    console.warn('solana/web3 dynamic import failed — attempting UMD/global fallback', err);
    // Record dynamic import failures to SelfHeal history
    try{ SelfHeal.record(String(err && err.message ? err.message : err)); }catch(e){}
    // Attempt to use the UMD global (loaded by the static script tag above) named `solanaWeb3`.
    const umd = (typeof window !== 'undefined') ? (window.solanaWeb3 || window.solana_web3 || window.solanaweb3 || window.solana) : null;
    if(umd && (umd.PublicKey || umd.PublicKey?.prototype)){
      try{
        Connection = umd.Connection || umd.connection || umd.ConnectionConstructor;
        PublicKey = umd.PublicKey || umd.PublicKeyConstructor || function(s){ return new (umd.PublicKey)(s); };
        clusterApiUrl = umd.clusterApiUrl || ((network)=> 'https://api.mainnet-beta.solana.com');
  const _ds2 = document.getElementById('diagStatus'); if(_ds2) _ds2.textContent = 'Status: web3 (UMD) loaded';
      }catch(e){
        console.warn('UMD web3 detected but failed to wire up', e);
      }
    }
    // If neither ESM nor UMD provided necessary symbols, fall back to lightweight shims so the app can still boot.
    if(typeof PublicKey === 'undefined' || typeof Connection === 'undefined'){
      console.warn('solana/web3 not available — using shims');
      clusterApiUrl = (network)=> 'https://api.mainnet-beta.solana.com';
      class PublicKeyShim { constructor(s){ this._s = s; } toBase58(){ return this._s?.toString?.()||String(this._s); } }
      PublicKey = PublicKeyShim;
      Connection = class { constructor(){ console.warn('Connection shim used'); } async getSignaturesForAddress(){ return []; } };
      Connection.isShim = true;
      try{ SelfHeal.record('web3 not loaded - using shim'); }catch(e){}
      const b = document.getElementById('diagBanner'); if(b){ b.textContent = 'Warning: Solana web3 failed to load — using shims'; b.classList.remove('diag-hidden'); }
  const _ds3 = document.getElementById('diagStatus'); if(_ds3) _ds3.textContent = 'Status: web3 shim';
    }
  }

  // ====== Timestamp anchor ======
  const CREATED_AT = new Date().toISOString();
  document.getElementById("createdStamp").textContent = `Created: ${CREATED_AT}`;
  localStorage.setItem("createdAt", CREATED_AT);

  // ====== State ======
  const S = {
    wallet: null,
    connection: new Connection(clusterApiUrl("mainnet-beta"), "confirmed"),
    rewards: parseInt(localStorage.getItem('rewards')||'0',10) || 0,
    geoKey: localStorage.getItem("geoKey")||"",
    mainVault: "BVnVEfipjrx8cDVqUSCJ1ZjwyrU3kVMebwac3cnGhLB",
    places: JSON.parse(localStorage.getItem("places")||"[]"),
    pending: JSON.parse(localStorage.getItem("pending")||"[]"),
    offGrid: new Set(JSON.parse(localStorage.getItem("offgrid")||"[]")),
    orders: JSON.parse(localStorage.getItem("orders")||"[]"),
    trust: JSON.parse(localStorage.getItem("trust")||"{}"),
    txFeedAddrs: new Set(),
    helix: { scene:null, renderer:null, camera:null, composer:null, particles:[] },
    watchers: { wallet:false, globe:false, helix:false, qr:false, seed:false }
  };
  // Record whether the connection is a shim (no real RPC capability)
  S.connectionIsShim = !!(Connection && Connection.isShim);

  // ====== Auto-populate known sanctums (global seed) ======
  const KNOWN_SANCTUMS = [
    { id:'auto-001', name:'St. Peter’s Basilica', address:'Vatican City', lat:41.9022, lon:12.4539, mcapUSD:25000, rank:100 },
    { id:'auto-002', name:'Great Mosque of Mecca', address:'Mecca, Saudi Arabia', lat:21.4225, lon:39.8262, mcapUSD:25000, rank:100 },
    { id:'auto-003', name:'Golden Temple', address:'Amritsar, India', lat:31.6200, lon:74.8765, mcapUSD:20000, rank:95 },
    { id:'auto-004', name:'Western Wall', address:'Jerusalem, Israel', lat:31.7767, lon:35.2345, mcapUSD:17000, rank:85 },
    { id:'auto-005', name:'Shwedagon Pagoda', address:'Yangon, Myanmar', lat:16.7983, lon:96.1497, mcapUSD:16000, rank:82 },
    { id:'auto-006', name:'Notre-Dame Cathedral', address:'Paris, France', lat:48.8530, lon:2.3499, mcapUSD:16000, rank:82 },
    { id:'auto-007', name:'Sagrada Família', address:'Barcelona, Spain', lat:41.4036, lon:2.1744, mcapUSD:15000, rank:80 },
    { id:'auto-008', name:'Angkor Wat', address:'Siem Reap, Cambodia', lat:13.4125, lon:103.8670, mcapUSD:18000, rank:88 },
    { id:'auto-009', name:'Borobudur Temple', address:'Magelang, Indonesia', lat:-7.6079, lon:110.2038, mcapUSD:17500, rank:87 },
    { id:'auto-010', name:'St. Basil’s Cathedral', address:'Moscow, Russia', lat:55.7525, lon:37.6231, mcapUSD:15500, rank:81 },
    { id:'auto-011', name:'Kashi Vishwanath Temple', address:'Varanasi, India', lat:25.3109, lon:82.9739, mcapUSD:16500, rank:83 },
    { id:'auto-012', name:'Uluru Sacred Site', address:'Uluru, Australia', lat:-25.3450, lon:131.0360, mcapUSD:14000, rank:75 },
    { id:'auto-013', name:'La Sagrada Catedral Metropolitana', address:'Mexico City, Mexico', lat:19.4340, lon:-99.1332, mcapUSD:14800, rank:78 },
    { id:'auto-014', name:'Haghia Sophia', address:'Istanbul, Türkiye', lat:41.0086, lon:28.9802, mcapUSD:19000, rank:90 },
    { id:'auto-015', name:'Kiyomizu-dera', address:'Kyoto, Japan', lat:34.9949, lon:135.7850, mcapUSD:15800, rank:79 },
    { id:'auto-016', name:'Shrine of Fatima', address:'Fátima, Portugal', lat:39.6329, lon:-8.6716, mcapUSD:14200, rank:76 },
    { id:'auto-017', name:'Christ the Redeemer', address:'Rio de Janeiro, Brazil', lat:-22.9519, lon:-43.2105, mcapUSD:16200, rank:82 },
    { id:'auto-018', name:'St. Paul’s Cathedral', address:'London, UK', lat:51.5138, lon:-0.0984, mcapUSD:15100, rank:80 },
    { id:'auto-019', name:'Lotus Temple', address:'New Delhi, India', lat:28.5535, lon:77.2588, mcapUSD:14900, rank:79 },
    { id:'auto-020', name:'Sri Padmanabhaswamy Temple', address:'Thiruvananthapuram, India', lat:8.4820, lon:76.9433, mcapUSD:16000, rank:82 },
    { id:'auto-021', name:'Canterbury Cathedral', address:'Canterbury, UK', lat:51.2798, lon:1.0837, mcapUSD:14000, rank:75 },
    { id:'auto-022', name:'St. Patrick’s Cathedral', address:'New York, USA', lat:40.758465, lon:-73.975993, mcapUSD:15500, rank:81 },
    { id:'auto-023', name:'Masjid al-Nabawi', address:'Medina, Saudi Arabia', lat:24.4672, lon:39.6111, mcapUSD:23000, rank:98 },
    { id:'auto-024', name:'Fushimi Inari Taisha', address:'Kyoto, Japan', lat:34.9671, lon:135.7727, mcapUSD:15000, rank:80 },
    { id:'auto-025', name:'Jokhang Temple', address:'Lhasa, Tibet', lat:29.6540, lon:91.1165, mcapUSD:17000, rank:86 }
  ];
  (function seedKnown(){
    const existing = new Set(S.places.map(p=>p.id));
    let added = 0;
    KNOWN_SANCTUMS.forEach(s => { if(!existing.has(s.id)){ S.places.push(s); added++; } });
    if(added>0){
      localStorage.setItem("places", JSON.stringify(S.places));
      document.getElementById('t-seed').className='ok';
    }
    S.watchers.seed = true;
  })();
  logStep('seedKnown completed');

  // ====== Wallet (Phantom) ======
  const connectBtn = document.getElementById("connectPhantom");
  const disconnectBtn = document.getElementById("disconnectPhantom");
  const walletView = document.getElementById("walletView");

  function getPhantomProvider(){
    if(typeof window==='undefined') return null;
    // Try common provider locations and variants used by Phantom and wrappers
    const win = window;
    const candidates = [win.solana, win.phantom && win.phantom.solana, win.phantom, win?.solana?.provider, win?.phantom?.provider];
    for(const c of candidates){
      if(!c) continue;
      try{ if(c.isPhantom || c.isPhantom===true) return c; }catch(e){}
    }
    // Last-ditch: return window.solana if present
    return win.solana || null;
  }

  async function connectWallet(){
    const provider = getPhantomProvider();
    if(!provider){
      // Show helpful links to install Phantom and open Pump.fun for validation
      try{
        showWalletInstallLinks();
      }catch(e){ alert('Phantom wallet not detected. Please install Phantom and refresh.'); }
      return;
    }
    try{
      // Request connection (will prompt the extension)
      const res = await provider.connect();
      // publicKey may be an object with toString(), or a string
      const pubStr = res?.publicKey?.toString ? res.publicKey.toString() : (res?.publicKey || String(res));
      if(!pubStr){ throw new Error('No publicKey returned from provider'); }
      // Use the project's PublicKey (from web3 import or shim)
      S.wallet = new PublicKey(pubStr);
      if(walletView) walletView.textContent = (S.wallet && S.wallet.toBase58) ? S.wallet.toBase58() : String(S.wallet);
      if(connectBtn) connectBtn.disabled = true;
      if(disconnectBtn) disconnectBtn.disabled = false;
      markOk('t-wallet'); S.watchers.wallet = true;
      const addrStr = (S.wallet && S.wallet.toBase58) ? S.wallet.toBase58() : String(S.wallet);
      S.txFeedAddrs.add(addrStr);
      // When an address is added, clear any pollIdle UI state
      try{ clearPollIdle(); }catch(e){}
      // mark helix watcher active so heartbeat shows ok
      S.watchers.helix = true;
      const diag = document.getElementById('diagStatus'); if(diag) diag.textContent = 'Status: wallet connected';
    }catch(err){
      // User rejected or other error
      if(err && (err.code === 4001 || err.message && err.message.toLowerCase().includes('user rejected'))){
        console.warn('User rejected wallet connection');
        alert('Wallet connection was rejected.');
      }else{
        console.warn('connectWallet error', err);
        alert('Wallet connection failed. See console for details.');
      }
    }
  }

  async function disconnectWallet(){
    const provider = getPhantomProvider();
    try{
      if(provider && typeof provider.disconnect === 'function') await provider.disconnect();
    }catch(e){ console.warn('disconnect error', e); }
    S.wallet = null;
    if(walletView) walletView.textContent = '—';
    if(connectBtn) connectBtn.disabled = false;
    if(disconnectBtn) disconnectBtn.disabled = true;
    S.watchers.wallet = false;
    // remove any addresses tied to this wallet from poll set
    try{ if(S.wallet){ S.txFeedAddrs.delete(S.wallet.toBase58()); } }catch(e){}
    const diag = document.getElementById('diagStatus'); if(diag) diag.textContent = 'Status: wallet disconnected';
  }

  if(connectBtn) connectBtn.addEventListener('click', connectWallet);
  if(disconnectBtn) disconnectBtn.addEventListener('click', disconnectWallet);

  // Provider poller: auto-detect when Phantom injects and enable connect button
  let _providerPollInterval = null;
  function startProviderPoll(){
    if(_providerPollInterval) return;
    _providerPollInterval = setInterval(()=>{
      try{
        const p = getPhantomProvider();
        if(p){
          // provider appeared — enable connect and hide install banner
          if(connectBtn) connectBtn.disabled = false;
          const b = document.getElementById('diagBanner'); if(b){ b.classList.add('diag-hidden'); }
          S.watchers.wallet = false; // not connected yet
          logStep('Provider detected by poll');
          clearInterval(_providerPollInterval); _providerPollInterval = null;
        }
      }catch(e){ console.warn('provider poll error', e); }
    }, 1200);
  }
  function stopProviderPoll(){ if(_providerPollInterval){ clearInterval(_providerPollInterval); _providerPollInterval=null; } }

  // Helpers for testing: clear poll idle UI and add/remove test addresses
  function clearPollIdle(){
    try{ const b=document.getElementById('diagBanner'); if(b) b.classList.add('diag-hidden'); const ds=document.getElementById('diagStatus'); if(ds) ds.textContent='Status: ready'; pollIdle=false; _consecutiveEmptyPolls=0; }catch(e){}
  }
  const addTestAddrBtn = document.getElementById('addTestAddr');
  const clearAddrsBtn = document.getElementById('clearAddrs');
  if(addTestAddrBtn) addTestAddrBtn.addEventListener('click', ()=>{
    // sample Test address (not real): use mainVault for demo so it's valid format
    const sample = S.mainVault;
    S.txFeedAddrs.add(sample);
    clearPollIdle();
    logStep('Test address added: '+sample);
  });
  if(clearAddrsBtn) clearAddrsBtn.addEventListener('click', ()=>{
    S.txFeedAddrs.clear(); logStep('All poll addresses cleared');
  });

  // QR lib check
  if(typeof window.QRCode==='undefined'){ const b = document.getElementById('diagBanner'); if(b){ b.textContent = 'Warning: QR library missing — QR generation disabled'; b.classList.remove('diag-hidden'); } }

  // ====== Geo Ingestion (optional) ======
  const geoKeyInput = document.getElementById("geoKey");
  geoKeyInput.value = S.geoKey;
  if(geoKeyInput) geoKeyInput.addEventListener("input", e=>{ S.geoKey = e.target.value.trim(); localStorage.setItem("geoKey", S.geoKey); });

  async function ingestByCircle(lat, lon, radius=20000){
    const status = document.getElementById("ingestStatus");
    if(!S.geoKey){ status.textContent="Add Geoapify key (optional) — skipped"; return; }
    status.textContent="Fetching…";
    const url = `https://api.geoapify.com/v2/places?categories=religion.place_of_worship&filter=circle:${lon},${lat},${radius}&limit=200&apiKey=${S.geoKey}`;
    try{
      const res = await fetch(url);
      if(!res.ok){ status.textContent="Geoapify error"; return; }
      const data = await res.json();
      const incoming = (data.features||[]).map(f=>{
        const p=f.properties||{};
        const id=(p.place_id ?? `${p.osm_id}-${p.name??'unnamed'}`).toString();
        return { id, name:p.name||"Unnamed Place", address:p.address_line1||p.formatted||"", lat:f.geometry.coordinates[1], lon:f.geometry.coordinates[0], rank:0, mcapUSD: 2500+Math.random()*9000 };
      });
      const map = new Map(S.places.map(x=>[x.id, x]));
      incoming.forEach(x=> map.set(x.id, {...map.get(x.id), ...x}) );
      S.places = Array.from(map.values());
      localStorage.setItem("places", JSON.stringify(S.places));
      status.textContent="Ingested";
      markOk("t-geo");
      renderList();
      drawGlobePins();
    }catch(err){ console.warn('ingestByCircle failed', err); status.textContent='Ingest failed'; }
  }
  const detectBtn = document.getElementById("detect");
  if(detectBtn) detectBtn.addEventListener("click", ()=>{
    const st=document.getElementById("ingestStatus");
    if(!navigator.geolocation){ if(st) st.textContent="Geolocation unavailable"; return; }
    if(st) st.textContent="Locating…";
    navigator.geolocation.getCurrentPosition(pos=>{
      ingestByCircle(pos.coords.latitude, pos.coords.longitude, 20000);
    }, err=> { if(st) st.textContent = "Error: "+err.message; });
  });
  const ingestBtn = document.getElementById("ingest");
  if(ingestBtn) ingestBtn.addEventListener("click", ()=>{
    const lat = parseFloat((document.getElementById("lat")||{}).value);
    const lon = parseFloat((document.getElementById("lon")||{}).value);
    const rad = parseInt((document.getElementById("rad")||{value:'20000'}).value||"20000", 10);
    const st = document.getElementById("ingestStatus");
    if(Number.isNaN(lat)||Number.isNaN(lon)){ if(st) st.textContent = "Enter valid lat/lon"; return; }
    ingestByCircle(lat, lon, rad);
  });

  // ====== Add + Verify Sanctum ======
  function distanceKm(lat1, lon1, lat2, lon2){
    const R=6371; const dLat=(lat2-lat1)*Math.PI/180; const dLon=(lon2-lon1)*Math.PI/180;
    const a= Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)**2;
    return 2*R*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  }
  const addSubmitBtn = document.getElementById("addSubmit");
  if(addSubmitBtn) addSubmitBtn.addEventListener("click", ()=>{
    const name = document.getElementById("addName").value.trim();
    const addr = document.getElementById("addAddr").value.trim();
    const lat = parseFloat(document.getElementById("addLat").value);
    const lon = parseFloat(document.getElementById("addLon").value);
    const desc = document.getElementById("addDesc").value.trim();
    const st = document.getElementById("addStatus");
    if(!name || Number.isNaN(lat) || Number.isNaN(lon)){ st.textContent="Enter name and valid coordinates"; return; }
    const dup = S.places.find(p=> distanceKm(p.lat,p.lon,lat,lon) < 0.1);
    if(dup){ st.textContent="Already exists within ~100m"; return; }
    const id = "pending-"+Math.random().toString(36).slice(2);
    const submittedBy = S.wallet ? S.wallet.toBase58() : "anonymous";
    S.pending.push({ id, name, address:addr, lat, lon, desc, submittedBy, verifiers:[], status:"unverified", mcapUSD:2400, rank:10, createdAt:new Date().toISOString() });
    localStorage.setItem("pending", JSON.stringify(S.pending));
    st.textContent="Submitted. Awaiting verification (3+).";
    renderPending();
    drawGlobePins();
  });
  function verifyPending(id){
    const p = S.pending.find(x=>x.id===id); if(!p) return;
    const who = S.wallet ? S.wallet.toBase58() : "anonymous";
    if(!p.verifiers.includes(who)) p.verifiers.push(who);
    const threshold=3;
    if(p.verifiers.length>=threshold){
      const newId="s-"+Math.random().toString(36).slice(2);
      const v={ id:newId, name:p.name, address:p.address, lat:p.lat, lon:p.lon, rank:p.rank+10, mcapUSD:p.mcapUSD+1200, verifiedAt:new Date().toISOString() };
      S.places.push(v);
      S.pending = S.pending.filter(x=>x.id!==id);
      localStorage.setItem("places", JSON.stringify(S.places));
    }
    localStorage.setItem("pending", JSON.stringify(S.pending));
    renderPending(); renderList(); drawGlobePins();
  }

  // ====== Globe (Cesium) ======
  let viewer=null;
  const initGlobe = dbg('initGlobe', function(){
    logStep('initGlobe start');
    try{
      if(typeof Cesium==='undefined' || !Cesium.Viewer){ console.warn('Cesium not loaded - globe disabled'); const b = document.getElementById('diagBanner'); if(b){ b.textContent = 'Warning: Cesium not loaded — globe disabled'; b.classList.remove('diag-hidden'); } logStep('initGlobe aborted: Cesium missing'); return; }
      // Safely construct terrainProvider: some Cesium builds may not expose createWorldTerrain()
      let terrainProvider = null;
      try{
        terrainProvider = (typeof Cesium.createWorldTerrain === 'function') ? Cesium.createWorldTerrain() : new Cesium.EllipsoidTerrainProvider();
      }catch(e){ console.warn('terrainProvider selection failed, using EllipsoidTerrainProvider', e); terrainProvider = new Cesium.EllipsoidTerrainProvider(); }
      viewer = new Cesium.Viewer('globe',{terrainProvider:terrainProvider,animation:false,timeline:false,baseLayerPicker:false,geocoder:false,homeButton:false,sceneModePicker:false,navigationHelpButton:false});
      S.watchers.globe = true;
      if(navigator.geolocation){
        navigator.geolocation.getCurrentPosition(pos=>{
          try{ viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(pos.coords.longitude, pos.coords.latitude, 300000.0) }); }catch(e){ logStep('viewer.camera.flyTo failed: '+(e?.message||String(e))); }
        });
      }
      drawGlobePins();
    }catch(err){ console.warn('initGlobe error', err); logStep('initGlobe caught error: '+(err?.message||String(err))); }
    logStep('initGlobe end');
  });
  function bubbleSize(m){ const base=Math.log10(Math.max(100,m||1000))-2; return Math.min(28, 6+base*9); }
  function drawGlobePins(){
    if(!viewer) return;
    viewer.entities.removeAll();
    S.places.forEach(p=>{
      const size = bubbleSize(p.mcapUSD);
      const isOG = S.offGrid.has(p.id);
      const color = isOG ? "rgba(20,241,149,0.95)" : "rgba(249,200,70,0.85)";
      viewer.entities.add({
        position: Cesium.Cartesian3.fromDegrees(p.lon, p.lat),
        point: { pixelSize:size, color: Cesium.Color.fromCssColorString(color), outlineColor: Cesium.Color.BLACK, outlineWidth: isOG?2:0 },
        label: {
          text: p.name, font:'12px Inter, sans-serif',
          fillColor: Cesium.Color.WHITE, outlineColor: Cesium.Color.BLACK, outlineWidth:2,
          style: Cesium.LabelStyle.FILL_AND_OUTLINE, pixelOffset: new Cesium.Cartesian2(0, -(14+size))
        },
        description: `
          <b>${p.name}</b><br/>${p.address||""}<br/>
          Light: ${p.rank||0}<br/>mcap est: $${(p.mcapUSD||0).toFixed(0)}<br/>
          <button onclick="window.__peace('${p.id}')">Mark At Peace ✌️</button>
          <button onclick="window.__offgrid('${p.id}')">${isOG?'Unmark off‑grid':'Mark off‑grid'}</button>
        `
      });
    });
  }
  window.__peace = (id)=>{ logPeace(id); };
  window.__offgrid = (id)=>{ toggleOffGrid(id); };

  // ====== Three.js Double Helix with bloom ======
  const initHelix3D = dbg('initHelix3D', function(){
    logStep('initHelix3D start');
    if(typeof THREE==='undefined' || !THREE.Scene){ console.warn('Three.js not available - helix disabled'); const b = document.getElementById('diagBanner'); if(b){ b.textContent = 'Warning: Three.js not available — helix disabled'; b.classList.remove('diag-hidden'); } logStep('initHelix3D aborted: THREE missing'); return; }
    const container = document.getElementById("helix3d");
    if(!container){ console.warn('helix3d container missing'); logStep('initHelix3D aborted: container missing'); return; }
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x05060b);

    const camera = new THREE.PerspectiveCamera(48, container.clientWidth/container.clientHeight, 0.1, 3000);
    camera.position.set(0, 0, 260);

    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:"high-performance" });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.innerHTML=""; container.appendChild(renderer.domElement);

    // Try to initialize EffectComposer and passes. If unavailable or not a constructor, fall back to direct renderer.render
    let composer = null;

    // Expose renderer and canvas for higher-fidelity capture (composer will be assigned later if available)
    try{
      S.helix = S.helix || {};
      S.helix.renderer = renderer;
      S.helix.canvas = renderer && renderer.domElement ? renderer.domElement : null;
      S.helix.scene = scene;
      S.helix.camera = camera;
      // composer will be assigned after EffectComposer init
      window.getHelixCanvas = function(){ return (S && S.helix && (S.helix.canvas || (S.helix.renderer && S.helix.renderer.domElement))) || null; };
    }catch(e){ console.warn('Failed to expose helix renderer for capture', e); }
    try{
      if(typeof THREE.EffectComposer === 'function'){
        composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(container.clientWidth, container.clientHeight), 0.9, 0.45, 0.85);
        composer.addPass(renderPass); composer.addPass(bloomPass);
        // assign composer to shared state so external capture/resize logic can reference it
        try{ S.helix.composer = composer; }catch(e){ /* ignore */ }
      }else{
        console.warn('EffectComposer not available — using renderer fallback');
      }
    }catch(e){ console.warn('EffectComposer init failed — renderer fallback will be used', e); composer = null; }

    scene.add(new THREE.AmbientLight(0xffffff, 0.55));
    const key = new THREE.DirectionalLight(0xffffff, 0.7); key.position.set(80,120,100); scene.add(key);

    const nebulaGeo = new THREE.PlaneGeometry(1200, 800);
    const nebulaMat = new THREE.MeshBasicMaterial({ color:0x0b0c1a, transparent:true, opacity:0.35 });
    const nebula = new THREE.Mesh(nebulaGeo, nebulaMat); nebula.position.set(0,0,-260); scene.add(nebula);

    const radius=42, pitch=26, turns=7, points=600;
    const matA = new THREE.MeshStandardMaterial({ color:0x9945FF, emissive:0x331155, metalness:0.6, roughness:0.25 });
    const matB = new THREE.MeshStandardMaterial({ color:0x00D1FF, emissive:0x113355, metalness:0.6, roughness:0.25 });

    function helixCurve(phase=0){
      const path = new THREE.Curve();
      path.getPoint = function(t){
        const angle = t * turns * Math.PI * 2 + phase;
        const x = radius*Math.cos(angle);
        const y = (t-0.5)*turns*pitch;
        const z = radius*Math.sin(angle);
        return new THREE.Vector3(x,y,z);
      };
      return path;
    }
    function makeTube(path, mat){
      const geom = new THREE.TubeGeometry(path, points, 1.6, 24, false);
      return new THREE.Mesh(geom, mat);
    }
    const tubeA = makeTube(helixCurve(0), matA);
    const tubeB = makeTube(helixCurve(Math.PI), matB);
    scene.add(tubeA); scene.add(tubeB);

    const maxParticles = 700;
    const pGeo = new THREE.SphereGeometry(1.2, 12, 12);
    const pMat = new THREE.MeshBasicMaterial({ color:0xffffff });
    const instanced = new THREE.InstancedMesh(pGeo, pMat, maxParticles);
    scene.add(instanced);

    const particles = [];
    const palette = {
      buy: new THREE.Color(0x14F195),
      sell: new THREE.Color(0xFF3B3B),
      xfer: new THREE.Color(0x00D1FF),
      peace: new THREE.Color(0xffffff)
    };
    const dummy = new THREE.Object3D();

    function addParticle(kind="xfer", magnitude=40){
      const t = Math.random();
      const angle = t*turns*Math.PI*2;
      const x = (radius-3)*Math.cos(angle);
      const y = (t-0.5)*turns*pitch;
      const z = (radius-3)*Math.sin(angle);
      const s = 0.8 + Math.min(2.2, Math.sqrt(magnitude)/12);
      particles.push({ kind, t, speed: 0.0045 + Math.random()*0.010, x, y, z, s });
      markOk("t-helix"); S.watchers.helix = true;
      if(particles.length>maxParticles) particles.shift();
    }
  S.addParticle = addParticle;

    function renderParticles(){
      for(let i=0;i<particles.length;i++){
        const p = particles[i];
        p.t += p.speed; if(p.t>1) p.t=0;
        const angle = p.t*turns*Math.PI*2 + (p.kind==="peace" ? Math.sin(Date.now()*0.003)*0.25 : 0);
        const x = (radius-3)*Math.cos(angle);
        const z = (radius-3)*Math.sin(angle);
        const y = (p.t-0.5)*turns*pitch;

        dummy.position.set(x,y,z);
        dummy.scale.setScalar(p.s);
        dummy.updateMatrix();
        instanced.setMatrixAt(i, dummy.matrix);
        const col = palette[p.kind] || palette.xfer;
        instanced.setColorAt?.(i, col);
      }
      instanced.instanceMatrix.needsUpdate = true;
      if(instanced.instanceColor) instanced.instanceColor.needsUpdate = true;
    }

    function animate(){
      requestAnimationFrame(animate);
      tubeA.rotation.y += 0.0018;
      tubeB.rotation.y -= 0.0018;
      nebula.rotation.z += 0.0003;
      renderParticles();
  if(composer && typeof composer.render === 'function') composer.render(); else renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', ()=>{
      const w=container.clientWidth, h=container.clientHeight;
      try{ renderer.setSize(w,h); }catch(e){}
      try{ if(composer && typeof composer.setSize === 'function') composer.setSize(w,h); }catch(e){}
      try{ camera.aspect=w/h; camera.updateProjectionMatrix(); }catch(e){}
    });
    logStep('initHelix3D end');
  });

  // ====== TX Stream poll ======
  // Throttle log when there are no addresses to avoid spamming the boot log.
  let _lastNoAddrLog = 0;
  // Track consecutive empty poll cycles so we can mark idle state after a threshold
  let _consecutiveEmptyPolls = 0;
  let pollIdle = false;
  const POLL_EMPTY_THRESHOLD = 5; // after ~5 cycles (~17.5s) mark idle
  const pollTx = dbg('pollTx', async function(){
    const addrs = Array.from(S.txFeedAddrs);
    // If connection is shimmed (no real RPC), do not simulate — instead show a clear diagnostic
    if(S.connectionIsShim){
      try{
        const b = document.getElementById('diagBanner'); if(b){
          b.innerHTML = 'Solana web3 not available — on‑chain features disabled. <button class="btn" id="_inject_web3">Inject web3 bundle</button> <button class="btn btn-ghost" id="_qr_web3">Show QR</button>';
          b.classList.remove('diag-hidden');
        }
        const dsSim = document.getElementById('diagStatus'); if(dsSim) dsSim.textContent = 'Status: web3 missing';
        // Wire up inject button
        setTimeout(()=>{
          const ib = document.getElementById('_inject_web3'); if(ib){ ib.addEventListener('click', ()=>{ try{ const r = SelfHeal.analyzeAndFix('inject-web3-umd'); if(r){ S.rewards = (S.rewards||0)+1; localStorage.setItem('rewards', String(S.rewards)); const rv=document.getElementById('rewardView'); if(rv) rv.textContent='Rewards: '+S.rewards; logStep('User triggered web3 inject via SelfHeal'); } }catch(e){ console.warn('inject web3 clicked', e); } }); }
          const qb = document.getElementById('_qr_web3'); if(qb){ qb.addEventListener('click', ()=>{
            try{
              // Show a QR for phantom install deep link
              const url = 'https://phantom.app/download';
              const canvas=document.getElementById('qrCanvas'); if(canvas){ canvas.style.display='block'; if(window.QRCode && typeof window.QRCode.toCanvas==='function'){ window.QRCode.toCanvas(canvas, url, { width:260, margin:0 }, ()=>{ const dl=document.getElementById('dlQR'); if(dl) dl.disabled=false; }); } }
            }catch(e){ console.warn('qr web3 failed', e); }
          }); }
        },50);
        // Do not proceed to polling when shimmed
        return;
      }catch(e){ console.warn('pollTx shim diagnostic error', e); }
    }
    if(addrs.length===0) {
      _consecutiveEmptyPolls++;
      const now = Date.now();
      // only log the empty state at most once every 30 seconds
      if(now - _lastNoAddrLog > 30000){ logStep('pollTx: no addresses to poll'); _lastNoAddrLog = now; }
      if(!pollIdle && _consecutiveEmptyPolls >= POLL_EMPTY_THRESHOLD){
        pollIdle = true;
        const b = document.getElementById('diagBanner'); if(b){ b.textContent = 'Polling: idle (no addresses)'; b.classList.remove('diag-hidden'); }
        const ds = document.getElementById('diagStatus'); if(ds) ds.textContent = 'Status: poll idle';
        // mark helix watcher as inactive so heartbeat reflects it
        S.watchers.helix = false;
        logStep('pollTx: marked pollIdle after consecutive empty cycles');
      }
      return;
    }
    // If addresses now exist and previously idle, clear idle UI
    if(pollIdle){ pollIdle = false; _consecutiveEmptyPolls = 0; const b=document.getElementById('diagBanner'); if(b){ b.classList.add('diag-hidden'); } const ds=document.getElementById('diagStatus'); if(ds) ds.textContent='Status: polling'; logStep('pollTx: addresses found — cleared pollIdle'); }
    try{
      _consecutiveEmptyPolls = 0;
      for(const a of addrs){
        try{
          const pk = new PublicKey(a);
          const sigs = await S.connection.getSignaturesForAddress(pk, { limit: 4 });
          sigs.slice(0,3).forEach(()=> S.addParticle(Math.random()<0.33?'buy':(Math.random()<0.5?'sell':'xfer'), 60));
        }catch(inner){ console.warn('pollTx per-address error', inner); }
      }
    }catch(e){ logStep('pollTx error: '+(e?.message||String(e))); console.warn('pollTx error', e); }
  });
  setInterval(pollTx, 3500);

  // ====== Peace / Off-grid ======
  const logPeace = dbg('logPeace', function(placeId){
    const who = S.wallet ? S.wallet.toBase58() : "anonymous";
    const key = "peace:"+placeId+":"+who+":"+new Date().toISOString().slice(0,10);
    if(localStorage.getItem(key)) { alert("Already marked today."); return; }
    localStorage.setItem(key, "1");
    S.addParticle("peace", 100);
    drawGlobePins();
  });
  const toggleOffGrid = dbg('toggleOffGrid', function(id){
    if(S.offGrid.has(id)) S.offGrid.delete(id); else S.offGrid.add(id);
    localStorage.setItem("offgrid", JSON.stringify(Array.from(S.offGrid)));
    drawGlobePins(); renderList();
  });
  window.logPeace = logPeace;
  window.toggleOffGrid = toggleOffGrid;

  // ====== Lists ======
  const renderList = dbg('renderList', function(){
    const root=document.getElementById("list");
    root.innerHTML = S.places
      .sort((a,b)=>(b.mcapUSD||0)-(a.mcapUSD||0))
      .map(s=>`
      <div class="item">
        <div class="name">${s.name}</div>
        <div class="addr">${s.address||""}</div>
        <div class="small">
          <span class="pill">Light ${s.rank||0}</span>
          <span class="pill">mcap $${(s.mcapUSD||0).toFixed(0)}</span>
          ${S.offGrid.has(s.id)?'<span class="pill offgrid">Off‑grid ⚡</span>':''}
        </div>
        <div class="row row-flex-wrap">
          <button class="btn" data-peace="${s.id}">Mark At Peace ✌️</button>
          <button class="btn btn-secondary" data-og="${s.id}">${S.offGrid.has(s.id)?'Unmark off‑grid':'Mark off‑grid'}</button>
          <a class="btn btn-secondary" target="_blank" rel="noopener" href="https://solscan.io/account/${encodeURIComponent(S.mainVault)}">Vault</a>
        </div>
      </div>
    `).join("");
    root.querySelectorAll("[data-peace]").forEach(b=> b.onclick=()=> logPeace(b.getAttribute("data-peace")));
    root.querySelectorAll("[data-og]").forEach(b=> b.onclick=()=> toggleOffGrid(b.getAttribute("data-og")));
    renderHub();
  });
  const renderPending = dbg('renderPending', function(){
    const root=document.getElementById("pendingList");
    if(!S.pending.length){ root.textContent="None pending."; return; }
    root.innerHTML = S.pending.map(p=>`
      <div class="item">
        <div class="name">${p.name}</div>
        <div class="addr">${p.address||""}</div>
        <div class="small">Submitted by: <span class="mono">${p.submittedBy}</span> • Verifiers: ${p.verifiers.length}/3</div>
        <div class="row"><button class="btn" data-verify="${p.id}">Verify Sanctum</button></div>
      </div>
    `).join("");
    root.querySelectorAll("[data-verify]").forEach(b=> b.onclick=()=> verifyPending(b.getAttribute("data-verify")));
  });

  // ====== Hub: Pump.fun link, QR, link checks ======
  const renderHub = dbg('renderHub', function(){
    const top=document.getElementById("topList");
    const arr = [...S.places].sort((a,b)=>(b.mcapUSD||0)-(a.mcapUSD||0)).slice(0,6);
    if(top) top.innerHTML = arr.map(p=>`<div class="item"><div class="name">${p.name}</div><div class="small">mcap: $${(p.mcapUSD||0).toFixed(0)}</div></div>`).join("");
    const sel=document.getElementById("qrSelect");
    if(sel) sel.innerHTML = S.places.map(s=>`<option value="${s.id}">${s.name}</option>`).join("");
    const ord = document.getElementById("ordSanctum"); if(ord && sel) ord.innerHTML = sel.innerHTML;
    const plq = document.getElementById("plqSanctum"); if(plq && sel) plq.innerHTML = sel.innerHTML;
  });
  // Show helpful links in the diagnostic banner when wallet is missing
  function showWalletInstallLinks(){
    const b = document.getElementById('diagBanner');
    if(!b) return;
    const phantomUrl = 'https://phantom.app/download';
    const pumpCoinUrl = `https://pump.fun/coin/${encodeURIComponent(S.mainVault)}`;
    // Provide a deep-link attempt: phantom:// or provider.open()
    const isMobile = /Mobi|Android/i.test(navigator.userAgent || '');
    const deepLinkBtn = `<button class="btn btn-secondary" id="_dl_phantom">Open Phantom (try)</button>`;
    b.innerHTML = `Phantom wallet not detected. <a href="${phantomUrl}" target="_blank">Install Phantom</a> — <a href="${pumpCoinUrl}" target="_blank">Open Pump.fun (coin)</a> ${deepLinkBtn}`;
    b.classList.remove('diag-hidden');
    // Add a SelfHeal control to the banner
    const healBtn = document.createElement('button'); healBtn.className='btn btn-ghost'; healBtn.style.marginLeft='8px'; healBtn.textContent='Run Self‑Heal';
    healBtn.addEventListener('click', ()=>{
      try{
        const applied = SelfHeal.runAutoHeal(6);
        if(applied>0){ S.rewards = (S.rewards||0) + applied; localStorage.setItem('rewards', String(S.rewards)); const rv=document.getElementById('rewardView'); if(rv) rv.textContent='Rewards: '+S.rewards; logStep('SelfHeal applied '+applied+' fixes');
          const b = document.getElementById('diagBanner'); if(b){ b.textContent = `SelfHeal applied ${applied} fixes — rewards +${applied}`; b.classList.remove('diag-hidden'); }
        }else{ const b2=document.getElementById('diagBanner'); if(b2){ b2.textContent='SelfHeal: no known fixes applied'; b2.classList.remove('diag-hidden'); } }
      }catch(e){ console.warn('SelfHeal run failed', e); }
    });
    b.appendChild(healBtn);
    const ds = document.getElementById('diagStatus'); if(ds) ds.textContent='Status: wallet missing';
    // Attach click handler to attempt opening Phantom via deep link or provider API
    setTimeout(()=>{
      const btn = document.getElementById('_dl_phantom'); if(!btn) return;
      btn.addEventListener('click', ()=>{
        try{
          const p = getPhantomProvider();
          // provider.open is available in some integrations
          if(p && typeof p.open === 'function'){ try{ p.open(); return; }catch(e){} }
          if(isMobile){ window.location.href = 'phantom://'; return; }
          // Desktop: open Phantom's universal link (browser will attempt to open the extension/native app)
          window.open('https://phantom.app/ul/browse');
        }catch(e){ console.warn('Deep link attempt failed', e); }
      });
    }, 50);
  }
  function markOk(id){ const el=document.getElementById(id); if(el){ el.className="ok"; } }
  const mkQRBtn = document.getElementById("mkQR");
  if(mkQRBtn) mkQRBtn.addEventListener("click", ()=>{
    const sel = document.getElementById("qrSelect"); if(!sel) return; const id = sel.value;
    const url=`https://sanctum.link/place/${encodeURIComponent(id)}`;
    const canvas=document.getElementById("qrCanvas"); if(canvas) canvas.style.display="block";
    if(window.QRCode && typeof window.QRCode.toCanvas==='function'){
      try{
        window.QRCode.toCanvas(canvas, url, { width:260, margin:0 }, ()=>{ const dl=document.getElementById("dlQR"); if(dl) dl.disabled=false; markOk("t-qr"); S.watchers.qr = true; });
      }catch(err){ console.warn('QR generation failed', err); }
    }else{ console.warn('QRCode lib missing'); }
  });
  const dlQRBtn = document.getElementById("dlQR");
  if(dlQRBtn) dlQRBtn.addEventListener("click", ()=>{
    try{
      const canvas = document.getElementById("qrCanvas");
      if(!canvas) return; const a=document.createElement("a"); a.download="SanctumQR.png"; a.href=canvas.toDataURL(); a.click();
    }catch(err){ console.warn('QR download failed', err); }
  });
  const openPumpBtn = document.getElementById("openPump");
  if(openPumpBtn) openPumpBtn.addEventListener("click", ()=>{
    const name = (document.getElementById("pfName").value||"").trim();
    const ref = S.wallet ? S.wallet.toBase58() : "";
    let href;
    if(!name){
      // If no custom name provided, go directly to the coin page for the mainVault
      href = `https://pump.fun/coin/${encodeURIComponent(S.mainVault)}`;
    }else{
      href = `https://pump.fun/?name=${encodeURIComponent(name)}${ref?`&referrer=${encodeURIComponent(ref)}`:""}`;
    }
    window.open(href, "_blank");
  });
  async function testURL(url, fillEl, timeoutMs=8000){
    const fill = document.getElementById(fillEl);
    if(!url || !/^https?:\/\//.test(url)){ fill.style.width='100%'; fill.className='fill bad'; return false; }
    const ctrl = new AbortController(); const timer=setTimeout(()=>ctrl.abort(),timeoutMs);
    try{
      // try a normal GET first; some servers may reject no-cors
      let res;
      try{ res = await fetch(url, { method:'GET', signal:ctrl.signal }); }
      catch(e){
        // fallback to no-cors mode for opaque responses
        try{ res = await fetch(url, { method:'GET', mode:'no-cors', signal:ctrl.signal }); }catch(e2){ throw e2; }
      }
      clearTimeout(timer); fill.style.width='100%';
      if(res && res.type==='opaque'){ fill.className='fill warn'; return true; }
      if(res && res.ok){ fill.className='fill'; return true; }
      fill.className='fill bad'; return false;
    }catch{ clearTimeout(timer); fill.style.width='100%'; fill.className='fill bad'; return false; }
  }
  const testAllBtn = document.getElementById("testAll");
  if(testAllBtn) testAllBtn.addEventListener("click", async ()=>{
    const ok = await Promise.all([
      testURL(document.getElementById("linkSolscan").value.trim(),'sbSolscan'),
      testURL(document.getElementById("linkSite").value.trim(),'sbSite'),
      testURL(document.getElementById("linkAPI").value.trim(),'sbAPI')
    ]);
    document.getElementById("testAllResult").textContent = `${ok.filter(Boolean).length}/${ok.length} reachable`;
  });
  document.getElementById("linkSolscan").value = `https://solscan.io/account/${S.mainVault}`;

  // ====== Orders & trust ======
  function renderOrderLedger(){
    const root=document.getElementById("orderLedger");
    if(!S.orders.length){ root.textContent="No orders yet."; return; }
    root.innerHTML = S.orders.slice().reverse().map(o=>{
      const when = o.fulfilledAt ? new Date(o.fulfilledAt).toLocaleString() : "-";
      if(o.type==='qr_order'){
        return `<div>• [Stickers] ${o.orderId} — Sanctum: ${o.placeId} — Qty: ${o.qty} — Status: ${o.status} — TXID ${o.txid?.slice(0,8)||'-'}… — DS: ${o.dropShipper||'-'} — ${when}</div>`;
      } else {
        return `<div>• [Plaque] ${o.orderId} — Sanctum: ${o.placeId} — ${o.material} — ${o.size} — Mount: ${o.mount} — Status: ${o.status} — Maker: ${o.dropShipper||'-'} — ${when}</div>`;
      }
    }).join("");
  }
  function renderTrustBoard(){
    const root=document.getElementById("trustBoard");
    const entries = Object.entries(S.trust||{});
    if(!entries.length){ root.textContent="No data yet."; return; }
    root.innerHTML = entries.sort((a,b)=>b[1]-a[1]).map(([w,s])=>`<div>• ${w} — Trust score: ${s}</div>`).join("");
  }
  function genNonce(){ return Math.floor(100000 + Math.random()*900000).toString(); }
  const genNonceBtn = document.getElementById("genNonce");
  if(genNonceBtn) genNonceBtn.addEventListener("click", ()=>{
    const n=genNonce(); localStorage.setItem("lastNonce", n);
    document.getElementById("nonceView").textContent = n;
  });
  const validateOrderBtn = document.getElementById("validateOrder");
  if(validateOrderBtn) validateOrderBtn.addEventListener("click", ()=>{
    const placeId=document.getElementById("ordSanctum").value;
    const qty=parseInt(document.getElementById("ordQty").value||"50",10);
    const ship=document.getElementById("ordShip").value.trim();
    const txid=document.getElementById("donTxid").value.trim();
    const memo=document.getElementById("donMemo").value.trim();
    const nonce=localStorage.getItem("lastNonce");
    const st=document.getElementById("orderStatus");
    if(!placeId||!qty||!ship||!txid||!memo||!nonce){ st.textContent="Fill all fields + generate nonce"; return; }
    if(memo!==nonce){ st.textContent="Nonce mismatch"; return; }
    const orderId = "ord-"+Math.random().toString(36).slice(2);
    S.orders.push({ type:"qr_order", orderId, placeId, wallet:S.wallet?.toBase58()||"anonymous", qty, ship, txid, memo, status:"validated", createdAt:new Date().toISOString() });
    localStorage.setItem("orders", JSON.stringify(S.orders));
    st.textContent="Order validated. Awaiting drop‑shipper signature.";
    renderOrderLedger();
    S.txFeedAddrs.add(S.mainVault);
  });
  const fulfillOrderBtn = document.getElementById("fulfillOrder");
  if(fulfillOrderBtn) fulfillOrderBtn.addEventListener("click", ()=>{
    const dsWallet=document.getElementById("dsWallet").value.trim();
    const dsSig=document.getElementById("dsSig").value.trim();
    const st=document.getElementById("fulfillStatus");
    const last = S.orders.slice().reverse().find(o=>o.type==='qr_order' && o.status==='validated');
    if(!last){ st.textContent="No validated order to fulfill"; return; }
    if(!dsWallet||!dsSig){ st.textContent="Enter drop‑shipper wallet + signature"; return; }
    last.status="fulfilled"; last.dropShipper=dsWallet; last.signature=dsSig; last.fulfilledAt=new Date().toISOString();
    S.trust[dsWallet]=(S.trust[dsWallet]||0)+1;
    localStorage.setItem("orders", JSON.stringify(S.orders));
    localStorage.setItem("trust", JSON.stringify(S.trust));
    st.textContent="Fulfilled. Trust updated.";
    renderOrderLedger(); renderTrustBoard();
  });
  });
  const plqNonceBtn = document.getElementById("plqNonce");
  if(plqNonceBtn) plqNonceBtn.addEventListener("click", ()=>{
    const n=genNonce(); localStorage.setItem("lastNoncePlaque", n);
    document.getElementById("plqNonceView").textContent = n;
  });
  const placePlaqueBtn = document.getElementById("placePlaque");
  if(placePlaqueBtn) placePlaqueBtn.addEventListener("click", ()=>{
    const placeId=document.getElementById("plqSanctum").value;
    const material=document.getElementById("plqMaterial").value;
    const size=document.getElementById("plqSize").value.trim();
    const mount=document.getElementById("plqMount").value.trim();
    const ship=document.getElementById("plqShip").value.trim();
    const txid=document.getElementById("plqTxid").value.trim();
    const memo=document.getElementById("plqMemo").value.trim();
    const thaiWallet=document.getElementById("thaiWallet").value.trim();
    const thaiSig=document.getElementById("thaiSig").value.trim();
    const nonce=localStorage.getItem("lastNoncePlaque");
    const st=document.getElementById("plqStatus");
    if(!placeId||!material||!size||!mount||!ship||!txid||!memo||!thaiWallet||!thaiSig||!nonce){ st.textContent='Fill all fields + generate nonce'; return; }
    if(memo!==nonce){ st.textContent='Nonce mismatch'; return; }
    const orderId='plq-'+Math.random().toString(36).slice(2);
    S.orders.push({ type:'plaque_order', orderId, placeId, wallet:S.wallet?.toBase58()||"anonymous", material, size, mount, ship, txid, memo, dropShipper:thaiWallet, signature:thaiSig, status:'fulfilled', fulfilledAt:new Date().toISOString() });
    S.trust[thaiWallet]=(S.trust[thaiWallet]||0)+2;
    localStorage.setItem("orders", JSON.stringify(S.orders));
    localStorage.setItem("trust", JSON.stringify(S.trust));
    st.textContent='Plaque order placed & signed.';
    renderOrderLedger(); renderTrustBoard();
    const s=S.places.find(x=>x.id===placeId); if(s){ s.mcapUSD+=(material==='titanium'?1400:900); localStorage.setItem("places", JSON.stringify(S.places)); renderList(); drawGlobePins(); }
  });

  // ====== Export/Import ======
  const exportStateBtn = document.getElementById("exportState");
  if(exportStateBtn) exportStateBtn.addEventListener("click", ()=>{
    const state = {
      createdAt: localStorage.getItem("createdAt") || CREATED_AT,
      places: S.places, pending: S.pending, offGrid: Array.from(S.offGrid),
      orders: S.orders, trust: S.trust
    };
    const a=document.createElement("a");
    a.href=URL.createObjectURL(new Blob([JSON.stringify(state,null,2)],{type:"application/json"}));
    a.download=`sanctumlink_state_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.json`;
    a.click();
  });
  const importStateBtn = document.getElementById("importState");
  if(importStateBtn) importStateBtn.addEventListener("click", ()=>{
    const imp = document.getElementById("importFile"); if(imp) imp.click();
  });
  const importFileEl = document.getElementById("importFile");
  if(importFileEl) importFileEl.addEventListener("change", async (e)=>{
    const file = e.target.files[0]; if(!file) return;
    const txt = await file.text(); const data = JSON.parse(txt);
    S.places = data.places||S.places; S.pending = data.pending||S.pending; S.offGrid = new Set(data.offGrid||Array.from(S.offGrid));
    S.orders = data.orders||S.orders; S.trust = data.trust||S.trust;
    localStorage.setItem("places", JSON.stringify(S.places));
    localStorage.setItem("pending", JSON.stringify(S.pending));
    localStorage.setItem("offgrid", JSON.stringify(Array.from(S.offGrid)));
    localStorage.setItem("orders", JSON.stringify(S.orders));
    localStorage.setItem("trust", JSON.stringify(S.trust));
    renderList(); renderPending(); renderOrderLedger(); renderTrustBoard(); drawGlobePins();
  });

  // ====== Watchdog (uptime) ======
  function heartbeat(){
    const ok = S.watchers.wallet && S.watchers.globe && S.watchers.helix && S.watchers.qr && S.watchers.seed;
    const el = document.getElementById("t-watch");
    el.className = ok ? "ok" : "warn";
    try{ updateActionStatusColors(); }catch(e){}
  }
  setInterval(heartbeat, 30000);

  // Update checklist colors based on what actions are completed
  function updateActionStatusColors(){
    try{
      const map = {
        't-wallet': S.watchers.wallet,
        't-geo': S.places && S.places.length>0,
        't-qr': S.watchers.qr,
        't-helix': S.watchers.helix,
        't-watch': S.watchers.wallet && S.watchers.globe && S.watchers.helix,
        't-seed': S.watchers.seed
      };
      Object.keys(map).forEach(id=>{
        const el=document.getElementById(id); if(!el) return;
        el.className = map[id] ? 'ok' : 'warn';
      });
      const rewardEl = document.getElementById('rewardView'); if(rewardEl) rewardEl.textContent = 'Rewards: '+(S.rewards||0);
    }catch(e){ console.warn('updateActionStatusColors failed', e); }
  }

  // ====== Tabs ======
  document.querySelectorAll('.tab').forEach(b=>{
    b.addEventListener('click', ()=>{
      document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
      b.classList.add('active');
      const tab = b.dataset.tab;
      document.querySelectorAll('.panel').forEach(p=>p.style.display='none');
      document.getElementById(`panel-${tab}`).style.display='block';
      if(tab==='hub') renderHub();
      if(tab==='orders'){ renderOrderLedger(); renderTrustBoard(); }
    });
  });

  // ====== Boot ======
  function boot(){
    logStep('boot start');
    try{
      document.getElementById("linkSolscan").value = `https://solscan.io/account/${S.mainVault}`;
      initGlobe();
      initHelix3D();
      renderList();
      renderPending();
      renderHub();
      // Start polling for provider injection so connect button can be enabled automatically
      try{ startProviderPoll(); }catch(e){ console.warn('startProviderPoll failed', e); }
      const ds = document.getElementById('diagStatus'); if(ds) ds.textContent = 'Status: boot complete';
      logStep('boot complete');
    }catch(err){
      console.error('boot() failed', err);
      const b = document.getElementById('diagBanner'); if(b){ b.textContent = 'Boot failed: '+(err?.message||String(err)); b.classList.remove('diag-hidden'); }
      const ds = document.getElementById('diagStatus'); if(ds) ds.textContent = 'Status: boot failed';
    }
  }
      window.addEventListener('DOMContentLoaded', boot);
  // MARKER: end of main script block
  try{ const el = document.getElementById('bootLog'); const ts=new Date().toISOString().slice(11,23); if(el) el.textContent=(el.textContent||'')+`\n[${ts}] MARKER: end of main script block`; console.log('MARKER: end of main script block'); }catch(e){}
  </script>
  <div id="debugFooter" class="diag-hidden">
    <div class="debug-header">
      <div class="small mono">Debug / Boot Log</div>
      <div>
        <button class="btn btn-ghost" id="dbgToggle">Collapse</button>
      </div>
    </div>
    <div id="bootLog" class="small mono boot-log">Boot log:</div>
  </div>
  <script>
    // Console capture buffer
    const orig = { log: console.log, warn: console.warn, error: console.error };
    window.__consoleHistory = [];
    function push(type, args){ try{ window.__consoleHistory.push({ ts: new Date().toISOString(), type, msg: Array.from(args).map(a=>{ try{ return typeof a==='string'?a: JSON.stringify(a); }catch(e){ return String(a); } }).join(' ') }); if(window.__consoleHistory.length>2000) window.__consoleHistory.shift(); }catch(e){}
    console.log = function(){ push('log', arguments); orig.log.apply(console, arguments); };
    console.warn = function(){ push('warn', arguments); orig.warn.apply(console, arguments); };
    console.error = function(){ push('error', arguments); orig.error.apply(console, arguments); };

    // Debug capture helpers
    async function captureStageImage(){
      const stage = document.getElementById('stage');
      if(!stage) return null;
      // First try to capture any WebGL canvas if present (preferred)
      try{
        const webglDataUrl = await captureWebGLCanvasDataUrl();
        if(webglDataUrl) return await dataUrlToCanvas(webglDataUrl);
      }catch(e){ console.warn('WebGL capture failed', e); }

      // Try html2canvas CDN if available
      if(window.html2canvas){ try{ return await window.html2canvas(stage, { backgroundColor: null }); }catch(e){} }
      // Load html2canvas then retry
      try{
        await new Promise((res, rej)=>{ const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js'; s.onload=res; s.onerror=rej; document.head.appendChild(s); });
        if(window.html2canvas) return await window.html2canvas(stage, { backgroundColor: null });
      }catch(e){ console.warn('html2canvas failed', e); }
      return null;
    }

    // Convert dataURL to canvas element
    async function dataUrlToCanvas(dataUrl){
      return new Promise((resolve,reject)=>{
        try{
          const img = new Image(); img.onload = ()=>{
            try{ const c = document.createElement('canvas'); c.width = img.width; c.height = img.height; const ctx = c.getContext('2d'); ctx.drawImage(img,0,0); resolve(c); }catch(e){ reject(e); }
          };
          img.onerror = reject;
          img.src = dataUrl;
        }catch(e){ reject(e); }
      });
    }

    // Try to capture WebGL canvas as data URL. Best effort; may fail if canvas is tainted.
    async function captureWebGLCanvasDataUrl(){
      try{
        // Prefer explicit helix canvas if the renderer stored it on S.helix
        let canv = null;
        try{ if(typeof getHelixCanvas === 'function'){ canv = getHelixCanvas(); } }catch(e){}
        if(!canv){
          // Fallback to DOM queries
          const selectors = ['#helix3d canvas', '#stage canvas', 'canvas'];
          for(const s of selectors){ const el = document.querySelector(s); if(el){ canv = el; break; } }
        }
        if(!canv) return null;
        // Try simple toDataURL first
        try{ const url = canv.toDataURL('image/png'); if(url && url.indexOf('data:image')===0) return url; }catch(e){ /* toDataURL may throw if tainted */ }

        // Attempt pixel read via WebGL readPixels
        const gl = canv.getContext('webgl') || canv.getContext('experimental-webgl');
        if(!gl) return null;
        const w = canv.width || canv.clientWidth || 512;
        const h = canv.height || canv.clientHeight || 512;
        const pixels = new Uint8Array(w * h * 4);
        try{
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
        }catch(e){ console.warn('gl.readPixels failed', e); return null; }

        // Create an offscreen canvas and put flipped pixels (WebGL Y is bottom-left)
        const oc = document.createElement('canvas'); oc.width = w; oc.height = h; const ctx = oc.getContext('2d');
        const imageData = ctx.createImageData(w, h);
        // flip vertically
        for(let y=0;y<h;y++){
          const srcRow = (h - 1 - y) * w * 4;
          const dstRow = y * w * 4;
          for(let x=0;x<w*4;x++) imageData.data[dstRow + x] = pixels[srcRow + x];
        }
        ctx.putImageData(imageData, 0, 0);
        return oc.toDataURL('image/png');
      }catch(err){ console.warn('captureWebGLCanvasDataUrl error', err); return null; }
    }

    function downloadText(filename, text){ const a=document.createElement('a'); a.href = URL.createObjectURL(new Blob([text],{type:'text/plain'})); a.download = filename; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href), 2000); }

    async function downloadDebugBundle(){
      try{
        const imgCanvas = await captureStageImage();
        const logs = (window.__consoleHistory||[]).map(l=>`[${l.ts}] ${l.type.toUpperCase()}: ${l.msg}`).join('\n');
        const pre = `URL: ${location.href}\nUserAgent: ${navigator.userAgent}\nCreated: ${new Date().toISOString()}\n\n`;
        if(imgCanvas){
          // try to use JSZip; if not available, download image and logs separately
          if(!window.JSZip){
            await new Promise((res, rej)=>{ const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/jszip@3.10.0/dist/jszip.min.js'; s.onload=res; s.onerror=rej; document.head.appendChild(s); });
          }
          if(window.JSZip){
            const zip = new window.JSZip();
            const dataUrl = imgCanvas.toDataURL('image/png');
            const bin = atob(dataUrl.split(',')[1]);
            const arr = new Uint8Array(bin.length);
            for(let i=0;i<bin.length;i++) arr[i]=bin.charCodeAt(i);
            zip.file('stage.png', arr);
            zip.file('console.txt', pre+logs);
            const blob = await zip.generateAsync({type:'blob'});
            const a=document.createElement('a'); a.href = URL.createObjectURL(blob); a.download='debug-bundle.zip'; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href), 2500);
            return;
          }
        }
        // Fallback: download logs and image (if available) separately
        if(imgCanvas){ imgCanvas.toBlob(b=>{ const a=document.createElement('a'); a.href = URL.createObjectURL(b); a.download='stage.png'; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),2000); }); }
        downloadText('console.txt', pre+logs);
      }catch(e){ console.error('downloadDebugBundle failed', e); alert('Debug capture failed: '+e.message); }
    }

    // Add UI control in footer
    document.addEventListener('DOMContentLoaded', function(){
      try{
        const df = document.getElementById('debugFooter'); if(!df) return; df.classList.remove('diag-hidden');
        const controls = document.createElement('div'); controls.style.display='flex'; controls.style.justifyContent='flex-end'; controls.style.gap='8px';
        const btn = document.createElement('button'); btn.className='btn-ghost'; btn.textContent='Capture Debug Bundle';
        btn.addEventListener('click', downloadDebugBundle);
        controls.appendChild(btn);
        df.querySelector('.debug-header').appendChild(controls);
      }catch(e){ console.warn('debug UI init failed', e); }
    });
  </script>
      <script>
        // Augment SelfHeal: stronger buffer shim, node: prefix handling, local ESM loader
        (function(){
          function applyBufferShim(){
            try{
              if(window.Buffer) return 'already';
              window.Buffer = window.Buffer || {
                from: function(s){ try{ if(typeof s === 'string') return new TextEncoder().encode(s); if(s instanceof ArrayBuffer) return new Uint8Array(s); return new TextEncoder().encode(String(s)); }catch(e){ return new Uint8Array(0); } },
                alloc: function(n){ return new Uint8Array(n); }
              };
              console.log('SelfHeal: buffer shim applied');
              return 'applied-buffer-shim';
            }catch(e){ console.warn('buffer shim failed', e); return 'buffer-shim-failed'; }
          }

          async function tryLoadLocalEsm(){
            // Apply buffer shim early to avoid module specifier 'buffer' failures
            try{ applyBufferShim(); }catch(e){}
            // Prefer ESM and UMD browser builds; skip CommonJS files (.cjs.js)
            const candidates = ['/vendor/index.browser.esm.js','/vendor/index.browser.umd.js','/vendor/solana-web3.umd.js'];
            for(const p of candidates){
              try{
                // Check availability with HEAD
                const r = await fetch(p, { method:'HEAD' });
                if(!r.ok) continue;
                // If file is ESM, try dynamic import
                try{
                  if(p.endsWith('.esm.js') || p.indexOf('.esm')>=0){
                    const mod = await import(p);
                    const umd = { Connection: mod.Connection, PublicKey: mod.PublicKey, clusterApiUrl: mod.clusterApiUrl };
                    window.solanaWeb3 = window.solanaWeb3 || umd; console.log('Loaded local ESM web3 from', p); return {ok:true, path:p};
                  } else {
                    // For UMD, inject script tag and wait for onload to wire globals
                    await new Promise((res, rej)=>{
                      const s = document.createElement('script'); s.src = p; s.crossOrigin='anonymous';
                      s.onload = ()=>{ console.log('Injected UMD script', p); res(); };
                      s.onerror = (e)=>{ console.warn('UMD script load failed', p, e); rej(e); };
                      document.head.appendChild(s);
                    });
                    // wait a tick for globals to be set
                    await new Promise(r=>setTimeout(r, 50));
                    return {ok:true, path:p};
                  }
                }catch(e){ console.warn('dynamic import of local vendor failed', p, e); continue; }
              }catch(e){ continue; }
            }
            return {ok:false};
          }

          function fixNodeSpecifiers(msg){
            // Some libs use node:buffer specifier; rewrite by injecting mapping
            try{
              if(typeof msg !== 'string') msg = String(msg);
              if(/node:buffer/i.test(msg) || /Failed to resolve module specifier 'buffer'/i.test(msg)){
                return applyBufferShim();
              }
              return null;
            }catch(e){ return null; }
          }

          // Wire UI controls in debug header
          document.addEventListener('DOMContentLoaded', function(){
            try{
              const hdr = document.querySelector('#debugFooter .debug-header');
              if(!hdr) return;
              const wrap = document.createElement('div'); wrap.style.display='flex'; wrap.style.gap='8px'; wrap.style.alignItems='center';
              // Auto-heal toggle
              const autoLabel = document.createElement('label'); autoLabel.className='small'; autoLabel.style.display='flex'; autoLabel.style.alignItems='center';
              const chk = document.createElement('input'); chk.type='checkbox'; chk.id='autoHealToggle'; chk.style.marginRight='8px';
              autoLabel.appendChild(chk); autoLabel.appendChild(document.createTextNode('Auto‑Heal Errors'));
              wrap.appendChild(autoLabel);
              const runBtn = document.createElement('button'); runBtn.className='btn-ghost'; runBtn.id='runSelfHealNow'; runBtn.textContent='Run SelfHeal';
              runBtn.addEventListener('click', ()=>{
                try{
                  // attempt buffer shim and local vendor load
                  const r1 = applyBufferShim();
                  tryLoadLocalEsm().then(res=>{ if(res.ok) console.log('Local vendor loaded', res.path); else console.log('Local vendor not found'); });
                  alert('SelfHeal run: '+r1+' — check console for details.');
                }catch(e){ console.warn('Run SelfHeal failed', e); }
              });
              wrap.appendChild(runBtn);
              hdr.appendChild(wrap);

              // Auto-heal: listen to console history and window errors
              let lastSeen = 0; setInterval(()=>{
                try{
                  if(!document.getElementById('autoHealToggle')) return;
                  if(!document.getElementById('autoHealToggle').checked) return;
                  const hist = window.__consoleHistory || [];
                  for(let i=Math.max(0,lastSeen); i<hist.length; i++){
                    const entry = hist[i]; lastSeen = i+1;
                    if(!entry) continue;
                    const applied = fixNodeSpecifiers(entry.msg);
                    if(applied) console.log('AutoHeal applied:', applied);
                    // attempt to dynamically load local vendor when web3 missing
                    if(/web3|solana/i.test(entry.msg) || /Failed to resolve module specifier/i.test(entry.msg)){
                      tryLoadLocalEsm().then(res=>{ if(res.ok) console.log('AutoHeal loaded local vendor', res.path); });
                    }
                  }
                }catch(e){/* ignore */}
              }, 1500);
            }catch(e){ console.warn('SelfHeal UI init failed', e); }
          });
          // Also expose helpers for manual use
          window.SelfHeal = window.SelfHeal || {};
          window.SelfHeal.applyBufferShim = applyBufferShim;
          window.SelfHeal.tryLoadLocalEsm = tryLoadLocalEsm;
          window.SelfHeal.fixNodeSpecifiers = fixNodeSpecifiers;
        })();
      </script>
  <script>
    // Footer debug toggle
    try{
      const df = document.getElementById('debugFooter');
      const btn = document.getElementById('dbgToggle');
      if(df){ df.classList.remove('diag-hidden'); }
      if(btn){ btn.addEventListener('click', ()=>{
        if(df.style.height && df.style.height!=='140px'){ df.style.height='140px'; btn.textContent='Collapse'; }
        else { df.style.height='28px'; btn.textContent='Expand'; }
      }); }
    }catch(e){ console.warn('debug footer init failed', e); }
  }
  </script>
</body>
</html>
