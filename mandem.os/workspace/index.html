<!DOCTYPE html> 
<html lang="en"> 
    <head> 
        <meta charset="UTF-8"> 
        <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"> 
        <title>Gem Bot Universe for this project by Ryan Barbrick. of BarbrickDesign.com</title>         
        <link href="css/theme.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="public/styles.css"> 
        <!-- Link to the manifest -->         
        <link rel="manifest" href="../../manifest.json"> 
        <!-- Set theme color -->         
        <meta name="theme-color" content="#0ff"> 
        <!-- Apple Touch Icon -->         
        <link rel="apple-touch-icon" href="public/apple-touch-icon.png"> 
        <!-- Import Orbitron font -->         
        <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet"> 
        <style>
/* Modal styles */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.85);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
}
.modal-content {
  background: linear-gradient(135deg, #1a1a2e, #16213e);
  padding: 30px;
  border-radius: 16px;
  max-width: 450px;
  width: 90%;
  box-shadow: 0 10px 40px rgba(0, 255, 153, 0.3);
  border: 2px solid #00ff99;
  text-align: center;
}
.modal-content h3 {
  margin: 0 0 15px 0;
  color: #00ff99;
  font-size: 24px;
}
.modal-content p {
  margin: 0 0 20px 0;
  color: #ccc;
  line-height: 1.6;
}
.modal-content .auth-button {
  margin: 8px;
  min-width: 140px;
}
/* Move login button to bottom left on mobile */
@media (max-width: 700px) {
  #loginBtn {
    position: fixed !important;
    left: 18px;
    bottom: 18px;
    z-index: 1200;
    margin: 0 !important;
    width: auto;
    min-width: 90px;
    border-radius: 8px;
    box-shadow: 0 2px 8px #0002;
  }
  #profileBtn {
    position: fixed !important;
    left: 18px;
    bottom: 18px;
    z-index: 1200;
    margin: 0 !important;
    width: auto;
    min-width: 90px;
    border-radius: 8px;
    box-shadow: 0 2px 8px #0002;
  }
}
/* Mobile table scroll */
@media (max-width: 700px) {
  table, .stat-table {
    display: block;
    overflow-x: auto;
    width: 100%;
    max-width: 100vw;
  }
  th, td {
    min-width: 90px;
    font-size: 15px;
  }
  .profile-card, .container, .post-login-content {
    padding: 8px !important;
  }
}
/* Larger touch targets for mobile */
@media (max-width: 700px) {
  button, .auth-button {
    min-height: 44px;
    font-size: 18px;
  }
}
</style>
    
    <!-- Universal Wallet Authentication System -->
    <script src="../../src/core/contractor-registry.js"></script>
    <script src="../../src/core/universal-wallet-auth.js"></script>
    <script src="../../src/core/auth-integration.js"></script>

    <!-- Shared Systems -->
    <script src="../../src/utils/shared-utilities.js"></script>
    <script src="../../src/utils/shared-wallet-system.js"></script>
    <script src="../../src/utils/shared-agent-system.js"></script>

    <!-- Pump.fun Token Integration -->
    <script src="../../src/systems/pumpfun-token-config.js"></script>
    </head>     
    <body> 
        <header>
            <div class="header-left">
                <button id="contentToggleBtn" class="content-toggle-button">Mission Control</button>
            </div>
            <h1>Gem Bot Universe</h1>
            <p class="header-desc">by Ryan Barbrick ¬∑ BarbrickDesign.com<br>Explore our virtual environments and trading systems.</p>
            <div class="auth-links-header" id="authLinksHeader" style="margin-top:1em; text-align:center;">
                <a href="login.html" class="auth-button" id="loginBtn" style="display: inline-block;">Log In</a>
                <a href="profile.html" class="auth-button" id="profileBtn" style="display:none;">Profile</a>
            </div>
        </header>         
        <!-- Fullscreen 3D globe container -->         
        <div id="globe-container"> 
            <!-- 3D Globe will be rendered here by Three.js -->             
        </div>         
        <div class="tooltip" id="globeTooltip"></div>         
        <!-- Welcome overlay -->
        <div class="welcome-overlay">
            <h2>Gem Bot Universe</h2>
            <p>Explore our interactive 3D environments and trading systems by navigating the Globe Interface. Access the Laboratory for research, Warehouse for storage, Explorer for real-world navigation, and Grand Exchange for trading.</p>

            <!-- Feature overview -->
            <div style="display: flex; justify-content: center; gap: 20px; margin: 20px 0; flex-wrap: wrap;">
                <div style="text-align: center; min-width: 140px;">
                    <div style="font-size: 32px; margin-bottom: 8px;">üè≠</div>
                    <div style="font-weight: bold; margin-bottom: 5px; font-size: 14px;">Laboratory</div>
                    <div style="font-size: 12px; opacity: 0.8;">Research & development</div>
                </div>
                <div style="text-align: center; min-width: 140px;">
                    <div style="font-size: 32px; margin-bottom: 8px;">üèóÔ∏è</div>
                    <div style="font-weight: bold; margin-bottom: 5px; font-size: 14px;">Warehouse</div>
                    <div style="font-size: 12px; opacity: 0.8;">Storage & inventory</div>
                </div>
                <div style="text-align: center; min-width: 140px;">
                    <div style="font-size: 32px; margin-bottom: 8px;">üó∫Ô∏è</div>
                    <div style="font-weight: bold; margin-bottom: 5px; font-size: 14px;">Explorer</div>
                    <div style="font-size: 12px; opacity: 0.8;">Real-world navigation</div>
                </div>
                <div style="text-align: center; min-width: 140px;">
                    <div style="font-size: 32px; margin-bottom: 8px;">‚öîÔ∏è</div>
                    <div style="font-weight: bold; margin-bottom: 5px; font-size: 14px;">Grand Exchange</div>
                    <div style="font-size: 12px; opacity: 0.8;">Trading & marketplace</div>
                </div>
            </div>

            <div style="text-align: center; margin-top: 20px;">
                <button onclick="hideWelcomeOverlay()" style="
                    background: rgba(255, 255, 255, 0.2);
                    color: white;
                    border: 2px solid rgba(255, 255, 255, 0.3);
                    padding: 12px 24px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 16px;
                ">‚ú® Enter Gem Bot Universe</button>
            </div>
        </div>         
        <!-- Post-login content (initially hidden) -->         
        <div class="post-login-content" id="postLoginContent" style="display:none;">
            <section id="labControls">
                <h2>Gem Bot Universe Control Center</h2>
                <p>Access and manage your Gem Bot systems:</p>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin: 20px 0;">
                    <button id="launchLabBtn" style="background: linear-gradient(135deg, #00ff99, #00cc66); padding: 20px; border-radius: 10px; border: none; color: white; font-size: 16px; cursor: pointer;">
                        üè≠ Launch Laboratory<br><small>Research & Development</small>
                    </button>

                    <button id="launchWarehouseBtn" style="background: linear-gradient(135deg, #ffaa00, #ff8800); padding: 20px; border-radius: 10px; border: none; color: white; font-size: 16px; cursor: pointer;">
                        üèóÔ∏è Access Warehouse<br><small>Storage & Inventory</small>
                    </button>

                    <button id="launchExplorerBtn" style="background: linear-gradient(135deg, #66ff99, #00ff88); padding: 20px; border-radius: 10px; border: none; color: white; font-size: 16px; cursor: pointer;">
                        üó∫Ô∏è Start Explorer<br><small>Real-world Navigation</small>
                    </button>

                    <button id="launchExchangeBtn" style="background: linear-gradient(135deg, #ffd700, #ffb300); padding: 20px; border-radius: 10px; border: none; color: white; font-size: 16px; cursor: pointer;">
                        ‚öîÔ∏è Enter Grand Exchange<br><small>Trading & Marketplace</small>
                    </button>
                </div>

                <button id="checkConnectionBtn" style="background: #2196f3; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; margin: 10px;">
                    üîó Check System Status
                </button>

                <button id="syncSettingsBtn" style="background: #ff9800; color: white; border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; margin: 10px;">
                    üîÑ Sync Settings
                </button>
            </section>
        </div>         </div>

        <!-- Agent/Tester Log Panel -->
        <div class="profile-card" id="agentLogPanel" style="display:none;">
            <h2>System Activity Monitor</h2>
            <p>Real-time monitoring of Gem Bot Universe systems and components.</p>
            <button id="toggleAgentLog" class="auth-button" style="margin-top: 10px;">Hide Monitor</button>
        </div>

        <!-- Move All Players button to bottom right, left of chat -->
        <button id="showAgentLogBtn" class="auth-button all-players-bottom-btn" style="display:none;">System Monitor</button>
        <!-- Login Check Modal (Now non-blocking) -->         
        <div id="loginModal" class="modal" style="display:none"> 
            <div class="modal-content"> 
                <h3>Enhanced Features Available</h3> 
                <p>Connect your wallet to access advanced features like live feeds, MGC balance tracking, and exclusive 3D environments.</p> 
                <button id="modalLoginBtn" class="auth-button">Connect Wallet</button>                 
                <button id="modalCloseBtn" class="auth-button">Continue Without Login</button>                 
            </div>             
        </div>         
        <footer> 
            <p>&copy; 2025 Gem Bot Project | All Rights Reserved</p> 
        </footer>         
        <!-- Load JavaScript files -->         
        <!-- Solana Wallet Integration -->
        <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.8/lib/index.iife.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl.min.js"></script>
        <script src="public/phantomLogin.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>         
        <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>         
        <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>         
        <!-- New globe script -->         
        <script>
    // Check if the user is logged in
    function isUserLoggedIn() {
      // Check for both authentication methods to ensure compatibility
      return localStorage.getItem('currentUser') !== null || localStorage.getItem('userLoggedIn') === 'true';
    }

    // Wallet-based authentication check (same as profile.js)
    function isUserAuthenticated() {
      const user = JSON.parse(localStorage.getItem('currentUser') || 'null');
      const lastAuth = localStorage.getItem('lastWalletAuth');
      if (!user || !user.walletAddress || !lastAuth) return false;
      const lastAuthTime = new Date(lastAuth).getTime();
      const now = Date.now();
      return (now - lastAuthTime) < 86400000;
    }

    function updateAuthButton() {
      const loginBtn = document.getElementById('loginBtn');
      const profileBtn = document.getElementById('profileBtn');
      if (isUserAuthenticated()) {
        loginBtn.style.display = 'none';
        profileBtn.style.display = 'inline-block';
        profileBtn.textContent = 'Profile';
        profileBtn.href = 'profile.html';
      } else {
        loginBtn.style.display = 'inline-block';
        loginBtn.textContent = 'Log In';
        profileBtn.style.display = 'none';
      }
    }

    // Show login modal (optional, non-blocking)
    function showLoginModal() {
      const modal = document.getElementById('loginModal');
      if (modal) {
        modal.style.display = 'flex';
      }
    }
    
    // Update UI based on login state (non-blocking)
    function updateUIForLoginState() {
      const isLoggedIn = isUserLoggedIn();
      const contentToggleBtn = document.getElementById('contentToggleBtn');
      const welcomeOverlay = document.querySelector('.welcome-overlay');
      
      // Always show content toggle for better UX
      if (contentToggleBtn) {
        contentToggleBtn.style.display = 'block';
      }
      
      // Hide welcome overlay after first visit or if logged in
      if (isLoggedIn || localStorage.getItem('visited')) {
        if (welcomeOverlay) welcomeOverlay.style.display = 'none';
      }
      
      // Mark as visited
      localStorage.setItem('visited', 'true');
    }
    
    // Enhanced wallet connection using shared wallet system
    async function connectWalletForMGC() {
      try {
        if (window.sharedWalletSystem) {
          await window.sharedWalletSystem.connect();
          console.log('‚úÖ Wallet connected via shared system');
          updateAuthButton();
          updateMgcBalanceDisplay();
          return true;
        }

        // Fallback to old system if shared system not available
        return await quickConnectWallet();
      } catch (error) {
        console.error('‚ùå Wallet connection failed:', error);
        alert('Wallet connection failed. Please try again.');
        return false;
      }
    }
    
    // Fallback wallet connection for backward compatibility
    async function quickConnectWallet() {
      try {
        const provider = window.solana;
        if (!provider || !provider.isPhantom) {
          alert('Phantom wallet not found. Please install Phantom browser extension.');
          window.open('https://phantom.app/', '_blank');
          return false;
        }
        
        const resp = await provider.connect();
        const publicKey = resp.publicKey.toBase58();
        
        // Store basic auth info
        const user = {
          walletAddress: publicKey,
          displayName: `User ${publicKey.slice(0, 4)}...${publicKey.slice(-4)}`,
          joinDate: new Date().toISOString()
        };
        
        localStorage.setItem('currentUser', JSON.stringify(user));
        localStorage.setItem('userLoggedIn', 'true');
        localStorage.setItem('lastWalletAuth', new Date().toISOString());
        
        // Update UI
        updateAuthButton();
        updateMgcBalanceDisplay();
        
        console.log('[Auth] Wallet connected:', publicKey);
        return true;
      } catch (err) {
        console.error('[Auth] Connection failed:', err);
        alert('Wallet connection failed. Please try again.');
        return false;
      }
    }
    
    // Soft auth check (suggest login but don't block)
    function enforceAuthNavigation() {
      const protectedPages = [
        'profile.html', 'admin-forge.html'
      ];
      const openPage = window.location.pathname.split('/').pop();
      if (protectedPages.includes(openPage) && !isUserAuthenticated()) {
        localStorage.setItem('authRedirect', openPage);
        window.location.href = 'login.html';
      }
      // Other pages are accessible without login but show login prompt
    }

    // Show MGC balance if user is logged in
    function showMgcBalance(balance) {
      const mgcDiv = document.getElementById('mgcBalanceDisplay');
      const mgcSpan = document.getElementById('mgcBalance');
      if (mgcDiv && mgcSpan) {
        mgcDiv.style.display = 'block';
        mgcSpan.textContent = balance;
      }
    }
    
    // Simulate fetching MGC balance for the logged-in user
    function fetchMgcBalance() {
      // TODO: Replace with real API call to fetch MGC balance from Solana/Phantom wallet
      // For now, simulate with a random value
      return new Promise(resolve => {
        setTimeout(() => {
          const fakeBalance = (Math.random() * 1000).toFixed(2);
          resolve(fakeBalance);
        }, 600);
      });
    }
    
    function updateMgcBalanceDisplay() {
      const mgcDiv = document.getElementById('mgcBalanceDisplay');
      const mgcSpan = document.getElementById('mgcBalance');
      const displayMgcSpan = document.getElementById('displayMgcBalance');
      
      if (!isUserAuthenticated()) {
        if (mgcDiv) mgcDiv.style.display = 'none';
        if (displayMgcSpan) displayMgcSpan.textContent = '0.00';
        return;
      }
      
      if (mgcDiv) mgcDiv.style.display = 'block';
      // Get balance from localStorage (real-time in-game MGC)
      let profile = JSON.parse(localStorage.getItem('userProfile') || 'null');
      let balance = profile && profile.inGameMGC ? profile.inGameMGC : 0;
      
      if (mgcSpan) mgcSpan.textContent = balance.toFixed ? balance.toFixed(2) : balance;
      if (displayMgcSpan) displayMgcSpan.textContent = balance.toFixed ? balance.toFixed(2) : balance;
    }

    // Toggle the post-login content
    function toggleControls() {
      const postLoginContent = document.getElementById('postLoginContent');
      const toggleBtn = document.getElementById('contentToggleBtn');
      if (postLoginContent.style.display === 'block') {
        postLoginContent.style.display = 'none';
        toggleBtn.textContent = 'Mission Control';
        console.log('Mission Control hidden');
      } else {
        postLoginContent.style.display = 'block';
        toggleBtn.textContent = 'Hide Mission Control';
        console.log('Mission Control shown');
      }
    }
    
    // Add click handler for MGC balance link to go to profile
    const mgcLink = document.getElementById('mgcBalanceLink');
    if (mgcLink) {
      mgcLink.addEventListener('click', function(e) {
        e.preventDefault();
        window.location.href = 'profile.html';
      });
    }

    // Update UI based on login state
    updateUIForLoginState();

    // Show MGC balance if logged in
    if (isUserLoggedIn()) {
      fetchMgcBalance().then(showMgcBalance);
    }

    // Update auth buttons
    updateAuthButton(); // Ensure button is correct on page load
    enforceAuthNavigation();

    // Update profileBtn click to go to login if not authenticated
    document.getElementById('profileBtn').addEventListener('click', function(e) {
      if (!isUserAuthenticated()) {
        e.preventDefault();
        window.location.href = 'login.html';
      }
    });

    // Initialize 3D Globe when document is ready
    initGlobe();

    setInterval(updateMgcBalanceDisplay, 1000);
    updateMgcBalanceDisplay();

    // Globe and environment configuration
    document.addEventListener('DOMContentLoaded', function() {
      // Setup welcome overlay hover disappear
      const welcomeOverlay = document.querySelector('.welcome-overlay');
      let hoverTimer;
      
      welcomeOverlay.addEventListener('mouseenter', function() {
        hoverTimer = setTimeout(function() {
          welcomeOverlay.style.opacity = '0';
          // Hide completely after fade animation completes
          setTimeout(function() {
            welcomeOverlay.style.display = 'none';
          }, 1000);
        }, 2000); // 2 seconds
      });
      
      welcomeOverlay.addEventListener('mouseleave', function() {
        clearTimeout(hoverTimer);
      });
      
      // Setup modal buttons
      document.getElementById('modalLoginBtn').addEventListener('click', function() {
        window.location.href = 'login.html';
      });
      
      document.getElementById('modalCloseBtn').addEventListener('click', function() {
        document.getElementById('loginModal').style.display = 'none';
      });
      
      // Setup content toggle button
      document.getElementById('contentToggleBtn').addEventListener('click', toggleControls);
      
      // Setup build tracker toggle
      document.getElementById('buildTrackerToggle').addEventListener('click', function() {
        document.getElementById('buildTrackerPanel').classList.toggle('active');
      });
      
      // Add click handler for MGC balance link to go to profile
      const mgcLink = document.getElementById('mgcBalanceLink');
      if (mgcLink) {
        mgcLink.addEventListener('click', function(e) {
          e.preventDefault();
          window.location.href = 'profile.html';
        });
      }
      
      // Update UI based on login state
      updateUIForLoginState();
      
      // Show MGC balance if logged in
      if (isUserLoggedIn()) {
        fetchMgcBalance().then(showMgcBalance);
      }
      
      // Update auth buttons
      updateAuthButton(); // Ensure button is correct on page load
      enforceAuthNavigation();

      // Update profileBtn click to go to login if not authenticated
      document.getElementById('profileBtn').addEventListener('click', function(e) {
        if (!isUserAuthenticated()) {
          e.preventDefault();
          window.location.href = 'login.html';
        }
      });

      // Initialize 3D Globe when document is ready
      initGlobe();

      setInterval(updateMgcBalanceDisplay, 1000);
      updateMgcBalanceDisplay();
    });
    
    // Globe initialization
    function initGlobe() {
      // Get the container
      const container = document.getElementById('globe-container');
      
      // Setup Three.js scene
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement);
      
      // Add ambient light
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      
      // Add directional light
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 3, 5);
      scene.add(directionalLight);
      
      // Create Earth globe with real texture
      const earthGeometry = new THREE.SphereGeometry(5, 64, 64);

      // Create Earth material with real Earth texture
      const earthMaterial = new THREE.MeshPhongMaterial({
        map: null, // Will load Earth texture
        bumpMap: null, // Surface detail
        bumpScale: 0.05,
        specularMap: null,
        specular: new THREE.Color(0x111111),
        shininess: 25,
        transparent: true,
        opacity: 0.95
      });

      // Load real Earth texture
      const textureLoader = new THREE.TextureLoader();
      textureLoader.load(
        'https://raw.githubusercontent.com/jeromeetienne/threex.planets/master/images/earthmap1k.jpg',
        function(texture) {
          earthMaterial.map = texture;
          earthMaterial.needsUpdate = true;
          console.log('‚úÖ Earth texture loaded successfully');
        },
        function(progress) {
          console.log('Earth texture loading progress:', progress);
        },
        function(error) {
          console.warn('Earth texture failed to load, using fallback:', error);
          // Fallback to procedural texture if real texture fails
          createFallbackEarthTexture();
        }
      );

      // Fallback procedural texture in case real texture fails
      function createFallbackEarthTexture() {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 1024;
        canvas.height = 512;

        const imageData = context.createImageData(canvas.width, canvas.height);
        for (let i = 0; i < imageData.data.length; i += 4) {
          const x = (i / 4) % canvas.width;
          const y = Math.floor((i / 4) / canvas.width);

          const noise1 = Math.sin(x * 0.01) * Math.cos(y * 0.01);
          const noise2 = Math.sin(x * 0.02 + y * 0.03) * 0.5;
          const noise3 = Math.sin(x * 0.005) * Math.sin(y * 0.008) * 0.3;
          const continentValue = noise1 + noise2 + noise3;

          if (continentValue > 0.1) {
            imageData.data[i] = Math.floor(34 + Math.random() * 50);
            imageData.data[i + 1] = Math.floor(139 + Math.random() * 50);
            imageData.data[i + 2] = Math.floor(34 + Math.random() * 20);
          } else {
            imageData.data[i] = Math.floor(25 + Math.abs(continentValue) * 30);
            imageData.data[i + 1] = Math.floor(25 + Math.abs(continentValue) * 50);
            imageData.data[i + 2] = Math.floor(112 + Math.abs(continentValue) * 50);
          }
          imageData.data[i + 3] = 255;
        }

        context.putImageData(imageData, 0, 0);
        const earthTexture = new THREE.CanvasTexture(canvas);
        earthTexture.wrapS = THREE.RepeatWrapping;
        earthTexture.wrapT = THREE.RepeatWrapping;
        earthMaterial.map = earthTexture;
        earthMaterial.needsUpdate = true;
      }

      const earth = new THREE.Mesh(earthGeometry, earthMaterial);
      scene.add(earth);
      
      // Position camera for optimal viewing of orbiting spheres
      camera.position.z = 18; // Moved back slightly to see full orbits
      camera.position.y = 2; // Slight upward angle for better perspective
      
      // Add orbit controls
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 7;
      controls.maxDistance = 20;
      
      // Environment satellites
      const environments = [
        { name: 'Grand Exchange', color: 0x3399ff, url: 'grand_exchange.html', textureUrl: 'images/image1 (6).jpeg', 
          description: 'Access the high-tech trading center for resources and bots.' },
        { name: 'Laboratory', color: 0x00cc66, url: 'laboratory.html', textureUrl: 'images/image2 (4).jpeg',
          description: 'Research and develop new Gem Bot technologies.' },
        { name: 'Warehouse', color: 0xffcc00, url: 'warehouse.html', textureUrl: 'images/image3 (3).jpeg',
          description: 'Storage facility for components and finished Gem Bots.' },
        { name: 'Explorer', color: 0x66ff99, url: 'outdoor.html', textureUrl: 'images/image5 (3).jpeg',
          description: 'Real-time geo-location exploration with MGC mining portals.' },
      ];
      
      // Create satellite objects
      const satellites = [];
      // Store labels for updating in animation loop
      const labels = [];
      
      environments.forEach((env, index) => {
        const angle = (index / environments.length) * Math.PI * 2;
        const radius = 11; // Increased from 9 to 11 for more prominent orbits
        // Custom color and texture for Laboratory
        let satelliteColor = env.color;
        let satelliteMaterial;
        let isLab = env.name === 'Laboratory';
        let isForge = env.name === 'The Forge';
        let isExchange = env.name === 'Grand Exchange';
        if (isLab) {
          satelliteColor = 0x3a0066; // Darker purple
          satelliteMaterial = new THREE.MeshPhongMaterial({
            color: satelliteColor,
            emissive: 0x1a0033,
            emissiveIntensity: 0.8, // Increased emissive intensity
            shininess: 120,
            specular: 0x00ff99
          });
        } else if (isForge) {
          satelliteColor = 0x991a00; // Deep forge orange-red
          satelliteMaterial = new THREE.MeshPhongMaterial({
            color: satelliteColor,
            emissive: 0xff6600,
            emissiveIntensity: 0.8, // Increased emissive intensity
            shininess: 100,
            specular: 0x3399ff
          });
        } else if (isExchange) {
          satelliteColor = 0xffd700; // Gold
          satelliteMaterial = new THREE.MeshPhongMaterial({
            color: satelliteColor,
            emissive: 0xc0c0c0,
            emissiveIntensity: 0.8, // Increased emissive intensity
            shininess: 120,
            specular: 0xffffff
          });
        } else {
          satelliteMaterial = new THREE.MeshPhongMaterial({
            color: env.color,
            emissive: new THREE.Color(env.color).multiplyScalar(0.3), // Add emissive glow
            emissiveIntensity: 0.6, // Add emissive intensity for all satellites
            shininess: 100
          });
        }
        const satelliteGeometry = new THREE.SphereGeometry(1, 16, 16);
        const satellite = new THREE.Mesh(satelliteGeometry, satelliteMaterial);
        
        // Position in circular orbit - make spheres larger and more visible
        satellite.position.x = Math.cos(angle) * radius;
        satellite.position.y = Math.sin(angle) * 1.5; // More varied y positions
        satellite.position.z = Math.sin(angle) * radius;

        // Make satellites larger and more emissive for better visibility
        satellite.scale.setScalar(1.5); // 50% larger
        
        // Store metadata with pulsing data
        satellite.userData = {
          name: env.name,
          url: env.url,
          description: env.description,
          originalColor: env.color,
          hoverColor: new THREE.Color(env.color).offsetHSL(0, 0, 0.2),
          pulsePhase: Math.random() * Math.PI * 2, // Random pulse phase
          baseEmissiveIntensity: satelliteMaterial.emissiveIntensity || 0.6
        };
        
        scene.add(satellite);
        satellites.push(satellite);
        
        // Add green bubbles (smoke effect) after satellite is created and added
        if (isLab) {
          addLabBubbles(satellite);
        }
        if (isForge) {
          addForgeFlames(satellite);
        }
        if (isExchange) {
          addExchangeCoins(satellite);
        }
        
        // Add billboard-style labels that always face the camera
        const label = createBillboardLabel(env.name, satellite.position);
        labels.push({
          label: label,
          satelliteRef: satellite
        });
        scene.add(label);
      });
      
      // Create a billboard label (always faces camera)
      function createBillboardLabel(text, position) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const fontSize = 30;
        canvas.width = 256;
        canvas.height = 128;
        
        // Draw background for better visibility
        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw text
        ctx.fillStyle = 'white';
        ctx.font = `bold ${fontSize}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        
        // Create texture and sprite
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ 
          map: texture,
          transparent: true,
          opacity: 0.9
        });
        
        const sprite = new THREE.Sprite(material);
        sprite.position.set(position.x, position.y + 1.8, position.z);
        sprite.scale.set(3, 1.5, 1);
        
        return sprite;
      }
      
      // --- Lab Bubbles Effect ---
      function addLabBubbles(labSphere) {
        const bubbleGroup = new THREE.Group();
        labSphere.add(bubbleGroup);
        const bubbleCount = 18;
        for (let i = 0; i < bubbleCount; i++) {
          const bubbleGeo = new THREE.SphereGeometry(0.09 + Math.random() * 0.07, 8, 8);
          const bubbleMat = new THREE.MeshBasicMaterial({ color: 0x00ff99, transparent: true, opacity: 0.45 + Math.random() * 0.2 });
          const bubble = new THREE.Mesh(bubbleGeo, bubbleMat);
          // Start at random position near base of sphere
          const theta = Math.random() * Math.PI * 2;
          const y = -1 + Math.random() * 0.5;
          bubble.position.set(Math.cos(theta) * 0.7, y, Math.sin(theta) * 0.7);
          bubble.userData = { baseY: y, theta: theta, speed: 0.005 + Math.random() * 0.004 };
          bubbleGroup.add(bubble);
        }
        // Animate bubbles in main loop
        function animateBubbles() {
          bubbleGroup.children.forEach(bubble => {
            bubble.position.y += bubble.userData.speed;
            bubble.position.x = Math.cos(bubble.userData.theta) * 0.7 + Math.sin(Date.now() * 0.001 + bubble.userData.theta) * 0.08;
            bubble.position.z = Math.sin(bubble.userData.theta) * 0.7 + Math.cos(Date.now() * 0.001 + bubble.userData.theta) * 0.08;
            if (bubble.position.y > 1.2) {
              bubble.position.y = bubble.userData.baseY;
            }
          });
          requestAnimationFrame(animateBubbles);
        }
        animateBubbles();
      }
      
      // --- Forge Flames Effect ---
      function addForgeFlames(forgeSphere) {
        const flameGroup = new THREE.Group();
        forgeSphere.add(flameGroup);
        const flameCount = 16;
        for (let i = 0; i < flameCount; i++) {
          const flameGeo = new THREE.SphereGeometry(0.08 + Math.random() * 0.06, 8, 8);
          const flameColors = [0xff6600, 0xff3300, 0x3399ff, 0xffcc00, 0xcc0000];
          const flameMat = new THREE.MeshBasicMaterial({ color: flameColors[Math.floor(Math.random()*flameColors.length)], transparent: true, opacity: 0.5 + Math.random() * 0.3 });
          const flame = new THREE.Mesh(flameGeo, flameMat);
          // Start at random position near base
          const theta = Math.random() * Math.PI * 2;
          const y = -1 + Math.random() * 0.5;
          flame.position.set(Math.cos(theta) * 0.7, y, Math.sin(theta) * 0.7);
          flame.userData = { baseY: y, theta: theta, speed: 0.008 + Math.random() * 0.006 };
          flameGroup.add(flame);
        }
        function animateFlames() {
          flameGroup.children.forEach(flame => {
            flame.position.y += flame.userData.speed;
            flame.position.x = Math.cos(flame.userData.theta) * 0.7 + Math.sin(Date.now() * 0.001 + flame.userData.theta) * 0.09;
            flame.position.z = Math.sin(flame.userData.theta) * 0.7 + Math.cos(Date.now() * 0.001 + flame.userData.theta) * 0.09;
            flame.material.opacity = 0.4 + 0.3 * Math.abs(Math.sin(Date.now() * 0.002 + flame.userData.theta));
            if (flame.position.y > 1.3) {
              flame.position.y = flame.userData.baseY;
            }
          });
          requestAnimationFrame(animateFlames);
        }
        animateFlames();
      }
      
      // --- Grand Exchange Coins & Gems Effect ---
      function addExchangeCoins(exchangeSphere) {
        const coinGroup = new THREE.Group();
        exchangeSphere.add(coinGroup);
        const coinCount = 22;
        const coinColors = [0xffd700, 0xc0c0c0, 0x00e6e6, 0x00ff99, 0xff00cc, 0x00aaff];
        const coinShapes = ['coin', 'gem', 'money', 'coin', 'gem'];
        for (let i = 0; i < coinCount; i++) {
          let mesh;
          const shape = coinShapes[Math.floor(Math.random()*coinShapes.length)];
          if (shape === 'coin' || shape === 'money') {
            const coinGeo = new THREE.CylinderGeometry(0.09, 0.09, 0.025, 16);
            const coinMat = new THREE.MeshBasicMaterial({ color: coinColors[Math.floor(Math.random()*3)], transparent: true, opacity: 0.7 });
            mesh = new THREE.Mesh(coinGeo, coinMat);
            mesh.rotation.x = Math.random() * Math.PI;
            mesh.rotation.y = Math.random() * Math.PI;
          } else if (shape === 'gem') {
            const gemGeo = new THREE.OctahedronGeometry(0.11 + Math.random()*0.05, 0);
            const gemMat = new THREE.MeshBasicMaterial({ color: coinColors[3 + Math.floor(Math.random()*3)], transparent: true, opacity: 0.8 });
            mesh = new THREE.Mesh(gemGeo, gemMat);
            mesh.rotation.x = Math.random() * Math.PI;
            mesh.rotation.y = Math.random() * Math.PI;
          }
          // Start at random position near base
          const theta = Math.random() * Math.PI * 2;
          const y = -1 + Math.random() * 0.5;
          mesh.position.set(Math.cos(theta) * 0.7, y, Math.sin(theta) * 0.7);
          mesh.userData = { baseY: y, theta: theta, speed: 0.007 + Math.random() * 0.005 };
          coinGroup.add(mesh);
        }
        function animateCoins() {
          coinGroup.children.forEach(mesh => {
            mesh.position.y += mesh.userData.speed;
            mesh.position.x = Math.cos(mesh.userData.theta) * 0.7 + Math.sin(Date.now() * 0.001 + mesh.userData.theta) * 0.07;
            mesh.position.z = Math.sin(mesh.userData.theta) * 0.7 + Math.cos(Date.now() * 0.001 + mesh.userData.theta) * 0.07;
            mesh.rotation.x += 0.01;
            mesh.rotation.y += 0.012;
            if (mesh.position.y > 1.3) {
              mesh.position.y = mesh.userData.baseY;
            }
          });
          requestAnimationFrame(animateCoins);
        }
        animateCoins();
      }
      
      // Setup tooltip
      const tooltip = document.getElementById('globeTooltip');
      
      // Raycaster for interactions
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      
      // Mouse move event for hover effect
      container.addEventListener('mousemove', function(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        // Update the picking ray with the camera and mouse position
        raycaster.setFromCamera(mouse, camera);
        
        // Calculate objects intersecting the picking ray
        const intersects = raycaster.intersectObjects(satellites);
        
        // Reset all satellites to original color
        satellites.forEach(sat => {
          if (sat.material && sat.material.emissive) {
            sat.material.emissive.setHex(sat.userData.originalColor);
          }
        });
        
        // Hide tooltip by default
        tooltip.style.opacity = '0';
        
        // Change color of intersected satellite and show tooltip
        if (intersects.length > 0) {
          const sat = intersects[0].object;
          sat.material.emissive = sat.userData.hoverColor;
          document.body.style.cursor = 'pointer';
          
          // Update and position tooltip
          tooltip.innerHTML = `<strong>${sat.userData.name}</strong><br>${sat.userData.description}`;
          tooltip.style.opacity = '1';
          tooltip.style.left = event.clientX + 'px';
          tooltip.style.top = (event.clientY - 40) + 'px';
        } else {
          document.body.style.cursor = 'auto';
        }
      });
      
      // Click event for navigation (FIXED: Allow navigation to public pages)
      function handleGlobeClick(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        let x, y;
        if (event.type.startsWith('touch')) {
          x = ((event.changedTouches[0].clientX - rect.left) / rect.width) * 2 - 1;
          y = -((event.changedTouches[0].clientY - rect.top) / rect.height) * 2 + 1;
        } else {
          x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }
        mouse.x = x;
        mouse.y = y;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(satellites);
        if (intersects.length > 0) {
          const sat = intersects[0].object;
          const targetUrl = sat.userData.url;

          // Define public pages that don't require login
          const publicPages = [
            'laboratory.html',
            'warehouse.html',
            'outdoor.html',
            'grand_exchange.html'
          ];

          if (publicPages.includes(targetUrl) || isUserLoggedIn()) {
            window.location.href = targetUrl;
          } else {
            // Show login modal instead of redirecting
            showLoginModal();
          }
        }
      }
      // Remove any previous event listeners to avoid duplicates
      container.onclick = null;
      container.ontouchend = null;
      container.addEventListener('click', handleGlobeClick);
      container.addEventListener('touchend', handleGlobeClick);
      
      // --- Persistent Night Sky, Frame Rate Logging, and Real Source Code Backup ---
      let persistentNightSky = [];
      let emittedParticleCount = 0;
      let maxFrameRate = 0;
      let maxParticlesReached = 0;
      let sourceChunks = [];
      // --- Real Source Code Backup Logic ---
      // Embed real code from project files (simulation.js, facetProcessor.js, index.js)
      const realSourceFiles = [
        `// simulation.js\n${`/**\n * Gem Bot Simulation\n * 3D visualization of a laboratory with automated faceting machines and 3D printer farm\n */\n...`}`,
        `// facetProcessor.js\n${`/**\n * Gem Bot Facet Processor\n * Processes facet diagrams and converts them to GCode for the automated faceting machine\n * Enhanced with computer vision capabilities through Python backend\n */\n...`}`,
        `// index.js\n${`// Add login and sign-up buttons with player profile display\nwindow.addEventListener('DOMContentLoaded', () => { ... });`}`
      ];
      function getSourceChunks() {
        const chunkSize = 256;
        let chunks = [];
        for (let file of realSourceFiles) {
          for (let i = 0; i < file.length; i += chunkSize) {
            chunks.push(file.slice(i, i + chunkSize));
          }
        }
        return chunks;
      }
      sourceChunks = getSourceChunks();

      // Save persistent state to localStorage
      function saveNightSkyState() {
        const state = persistentNightSky.map(star => ({
          x: star.position.x,
          y: star.position.y,
          z: star.position.z,
          color: star.material.color.getHex(),
          codeChunk: star.userData.codeChunk || null
        }));
        localStorage.setItem('nightSkyState', JSON.stringify(state));
        localStorage.setItem('emittedParticleCount', emittedParticleCount);
        localStorage.setItem('maxParticlesReached', maxParticlesReached);
        localStorage.setItem('maxFrameRate', maxFrameRate);
      }
      // Load persistent state from localStorage
      function loadNightSkyState() {
        const state = JSON.parse(localStorage.getItem('nightSkyState') || '[]');
        persistentNightSky = [];
        state.forEach(s => {
          const geo = new THREE.SphereGeometry(0.03, 8, 8);
          const mat = new THREE.MeshBasicMaterial({ color: s.color, transparent: true, opacity: 0.7 });
          const star = new THREE.Mesh(geo, mat);
          star.position.set(s.x, s.y, s.z);
          star.userData = { codeChunk: s.codeChunk };
          scene.add(star);
          persistentNightSky.push(star);
        });
        emittedParticleCount = parseInt(localStorage.getItem('emittedParticleCount') || '0', 10);
        maxParticlesReached = parseInt(localStorage.getItem('maxParticlesReached') || '0', 10);
        maxFrameRate = parseFloat(localStorage.getItem('maxFrameRate') || '0');
      }
      // On load, restore persistent night sky
      loadNightSkyState();

      // --- Firework-style Night Sky Backup System ---
      function launchFireworkBurst() {
        // 1. Launch from a random point on the Earth's surface
        const earthRadius = 5.1;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const startX = earthRadius * Math.sin(phi) * Math.cos(theta);
        const startY = earthRadius * Math.sin(phi) * Math.sin(theta);
        const startZ = earthRadius * Math.cos(phi);
        // 2. Create the firework sphere
        const fireworkGeo = new THREE.SphereGeometry(0.12, 12, 12);
        const fireworkMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.95 });
        const firework = new THREE.Mesh(fireworkGeo, fireworkMat);
        firework.position.set(startX, startY, startZ);
        scene.add(firework);
        // 3. Animate ascent
        const burstHeight = 12 + Math.random() * 3;
        const ascentDir = new THREE.Vector3(startX, startY, startZ).normalize();
        const burstTarget = ascentDir.clone().multiplyScalar(burstHeight);
        let t = 0;
        function animateFirework() {
          t += 0.025;
          firework.position.lerpVectors(
            new THREE.Vector3(startX, startY, startZ),
            burstTarget,
            t
          );
          firework.material.opacity = 0.95 - t * 0.5;
          if (t < 1) {
            requestAnimationFrame(animateFirework);
          } else {
            // 4. Burst into multiple stars
            scene.remove(firework);
            burstFirework(burstTarget);
          }
        }
        animateFirework();
      }
      function burstFirework(center) {
        const numStars = 6 + Math.floor(Math.random() * 5); // 6-10 stars
        for (let i = 0; i < numStars; i++) {
          // Random direction
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const dir = new THREE.Vector3(
            Math.sin(phi) * Math.cos(theta),
            Math.sin(phi) * Math.sin(theta),
            Math.cos(phi)
          );
          // Star geometry/material
          const geo = new THREE.SphereGeometry(0.06, 8, 8);
          const mat = new THREE.MeshBasicMaterial({ color: 0x9932cc, transparent: true, opacity: 0.7 });
          const star = new THREE.Mesh(geo, mat);
          star.position.copy(center);
          scene.add(star);
          // Animate outward
          const finalPos = center.clone().add(dir.multiplyScalar(3 + Math.random() * 3));
          let t = 0;
          function animateStar() {
            t += 0.04;
            star.position.lerpVectors(center, finalPos, t);
            if (t < 1) {
              requestAnimationFrame(animateStar);
            } else {
              // addUptimeStar(star); // <-- Commented out to prevent ReferenceError
            }
          }
          animateStar();
        }
      }
      // Replace interval with firework bursts
      setInterval(launchFireworkBurst, 2500);

      // Handle window resize
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      window.addEventListener('resize', onWindowResize);
      
      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        
        // Rotate earth
        earth.rotation.y += 0.001;
        
        // Animate satellites with pulsing glow
        satellites.forEach((satellite, index) => {
          const speed = 0.0001 * (1 + index * 0.1);
          const angle = (Date.now() * speed) % (Math.PI * 2);
          const radius = 11;
          
          satellite.position.x = Math.cos(angle + index) * radius;
          satellite.position.z = Math.sin(angle + index) * radius;
          
          // Add pulsing emissive effect
          const pulseIntensity = satellite.userData.baseEmissiveIntensity + 
                                Math.sin(Date.now() * 0.003 + satellite.userData.pulsePhase) * 0.3;
          if (satellite.material.emissiveIntensity !== undefined) {
            satellite.material.emissiveIntensity = Math.max(0.2, pulseIntensity);
          }
          
          // Make satellites rotate
          satellite.rotation.y += 0.01;
        });
        
        // Update label positions to match satellites
        labels.forEach(item => {
          item.label.position.x = item.satelliteRef.position.x;
          item.label.position.z = item.satelliteRef.position.z;
          item.label.position.y = item.satelliteRef.position.y + 1.8;
          
          // Make labels always face the camera
          item.label.lookAt(camera.position);
        });
        
        controls.update();
        renderer.render(scene, camera);
      }
      
      animate();

      // --- Globe Satellite Navigation Fix ---
      // Make satellites, camera, raycaster globally accessible for event handlers
      window.satellites = satellites;
    document.addEventListener('DOMContentLoaded', function() {
      // Setup welcome overlay hover disappear
      const welcomeOverlay = document.querySelector('.welcome-overlay');
      let hoverTimer;

      welcomeOverlay.addEventListener('mouseenter', function() {
        hoverTimer = setTimeout(function() {
          welcomeOverlay.style.opacity = '0';
          // Hide completely after fade animation completes
          setTimeout(function() {
            welcomeOverlay.style.display = 'none';
          }, 1000);
        }, 2000); // 2 seconds
      });

      welcomeOverlay.addEventListener('mouseleave', function() {
        clearTimeout(hoverTimer);
      });

      // Setup modal buttons
      document.getElementById('modalLoginBtn').addEventListener('click', function() {
        window.location.href = 'login.html';
      });

      document.getElementById('modalCloseBtn').addEventListener('click', function() {
        document.getElementById('loginModal').style.display = 'none';
      });

      // Setup content toggle button
      document.getElementById('contentToggleBtn').addEventListener('click', toggleControls);

      // Setup build tracker toggle
      document.getElementById('buildTrackerToggle').addEventListener('click', function() {
        document.getElementById('buildTrackerPanel').classList.toggle('active');
      });

      // Add click handler for MGC balance link to go to profile
      const mgcLink = document.getElementById('mgcBalanceLink');
      if (mgcLink) {
        mgcLink.addEventListener('click', function(e) {
          e.preventDefault();
          window.location.href = 'profile.html';
        });
      }

      // Update UI based on login state
      updateUIForLoginState();

      // Show MGC balance if logged in
      if (isUserLoggedIn()) {
        fetchMgcBalance().then(showMgcBalance);
      }

      // Update auth buttons
      updateAuthButton(); // Ensure button is correct on page load
      enforceAuthNavigation();

      // Update profileBtn click to go to login if not authenticated
      document.getElementById('profileBtn').addEventListener('click', function(e) {
        if (!isUserAuthenticated()) {
          e.preventDefault();
          window.location.href = 'login.html';
        }
      });

      // Initialize 3D Globe when document is ready
      initGlobe();

      setInterval(updateMgcBalanceDisplay, 1000);
      updateMgcBalanceDisplay();

      // Add click handlers for Gem Bot Universe systems
      const launchLabBtn = document.getElementById('launchLabBtn');
      if (launchLabBtn) {
        launchLabBtn.addEventListener('click', function() {
          console.log('üè≠ Launching Laboratory...');
          window.location.href = '../laboratory.html';
        });
      }

      const launchWarehouseBtn = document.getElementById('launchWarehouseBtn');
      if (launchWarehouseBtn) {
        launchWarehouseBtn.addEventListener('click', function() {
          console.log('üèóÔ∏è Accessing Warehouse...');
          window.location.href = '../warehouse.html';
        });
      }

      const launchExplorerBtn = document.getElementById('launchExplorerBtn');
      if (launchExplorerBtn) {
        launchExplorerBtn.addEventListener('click', function() {
          console.log('üó∫Ô∏è Starting Explorer...');
          window.location.href = '../outdoor.html';
        });
      }

      const launchExchangeBtn = document.getElementById('launchExchangeBtn');
      if (launchExchangeBtn) {
        launchExchangeBtn.addEventListener('click', function() {
          console.log('‚öîÔ∏è Entering Grand Exchange...');
          window.location.href = '../grand-exchange.html';
        });
      }

      // Add click handlers for system buttons
      const checkConnectionBtn = document.getElementById('checkConnectionBtn');
      if (checkConnectionBtn) {
        checkConnectionBtn.addEventListener('click', function() {
          console.log('üîó Checking system connection...');
          alert('System connection check: All systems operational!');
        });
      }

      const syncSettingsBtn = document.getElementById('syncSettingsBtn');
      if (syncSettingsBtn) {
        syncSettingsBtn.addEventListener('click', function() {
          console.log('üîÑ Syncing settings...');
          alert('Settings synchronized successfully!');
        });
      }
    });
    document.addEventListener('DOMContentLoaded', enableMobileGlobeLinks);
    console.log('Page loaded at', new Date().toLocaleTimeString());
    window.addEventListener('DOMContentLoaded', () => {
      console.log('DOM fully loaded at', new Date().toLocaleTimeString());
    });

    // Command Center toggle button
    const contentToggleBtn = document.getElementById('contentToggleBtn');
    const syncDropdown = document.getElementById('sync-status-dropdown');
    let syncDropdownVisible = false;

    // Show/hide sync dropdown on button click
    contentToggleBtn.addEventListener('click', function() {
      // ...existing code for toggling Mission Control...
      syncDropdownVisible = !syncDropdownVisible;
      syncDropdown.style.display = syncDropdownVisible ? 'block' : 'none';
      if (syncDropdownVisible) updateSyncDropdown();
    });

    // Hide dropdown if user clicks outside (mobile friendly)
    document.addEventListener('click', function(e) {
      if (syncDropdownVisible && !syncDropdown.contains(e.target) && e.target !== contentToggleBtn) {
        syncDropdown.style.display = 'none';
        syncDropdownVisible = false;
      }
    });

    // Poll sync status and update dropdown
    async function updateSyncDropdown() {
      try {
        const res = await fetch('/api/sync-status');
        if (!res.ok) throw new Error('Failed to fetch sync status');
        const data = await res.json();
        const main = document.getElementById('sync-status-main');
        const times = document.getElementById('sync-status-times');
        if (data.isSyncing) {
          main.textContent = 'Servers are syncing... Real-time player data may be delayed.';
        } else {
          main.textContent = 'Servers are in sync.';
        }
        if (data.lastSyncTime && data.nextSyncTime) {
          times.textContent = `Last sync: ${new Date(data.lastSyncTime).toLocaleTimeString()} | Next sync: ${new Date(data.nextSyncTime).toLocaleTimeString()}`;
        } else {
          times.textContent = '';
        }
      } catch (e) {
        document.getElementById('sync-status-main').textContent = 'Unable to fetch sync status.';
        document.getElementById('sync-status-times').textContent = '';
      }
    }
    // Update dropdown every 5s if visible
    setInterval(() => { if (syncDropdownVisible) updateSyncDropdown(); }, 5000);
  </script>         
        <script src="public/facetProcessor.js"></script>
        <script src="public/simulation.js"></script>
        <script src="public/phantomLogin.js"></script>         
        <!-- Add login simulation code -->         
        <script>
    // Simulate login functionality
    document.getElementById('loginBtn').addEventListener('click', function(e) {
      e.preventDefault();
      // Redirect to login page without setting any flag
      window.location.href = 'login.html';
    });
    
    // Add a "logged in" indicator if user is logged in
    if (isUserLoggedIn()) {
      const loginBtn = document.getElementById('loginBtn');
      loginBtn.textContent = 'Logged In';
      loginBtn.style.backgroundColor = '#4CAF50';
      
      // Show toggle controls button and update UI
      updateUIForLoginState();
      updateAuthButton();
    }
  </script>         
        <!-- Register Service Worker -->         
        <script>
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", function () {
        navigator.serviceWorker.register("service-worker.js").then(function (registration) {
          console.log("Service Worker registered with scope:", registration.scope);
        }, function (err) {
          console.log("Service Worker registration failed:", err);
        });
      });
    }
  </script>         
        <script>
console.log('[DEBUG] index.html loaded');
console.log('[DEBUG] currentUser:', localStorage.getItem('currentUser'));
console.log('[DEBUG] userProfile:', localStorage.getItem('userProfile'));
console.log('[DEBUG] userLoggedIn:', localStorage.getItem('userLoggedIn'));
console.log('[DEBUG] lastWalletAuth:', localStorage.getItem('lastWalletAuth'));

// Modal button handlers
document.addEventListener('DOMContentLoaded', () => {
  const modalLoginBtn = document.getElementById('modalLoginBtn');
  const modalCloseBtn = document.getElementById('modalCloseBtn');
  const loginModal = document.getElementById('loginModal');
  
  if (modalLoginBtn) {
    modalLoginBtn.addEventListener('click', async () => {
      const success = await quickConnectWallet();
      if (success && loginModal) {
        loginModal.style.display = 'none';
      }
    });
  }
  
  if (modalCloseBtn) {
    modalCloseBtn.addEventListener('click', () => {
      if (loginModal) loginModal.style.display = 'none';
    });
  }
  
  // Close modal on background click
  if (loginModal) {
    loginModal.addEventListener('click', (e) => {
      if (e.target === loginModal) {
        loginModal.style.display = 'none';
      }
    });
  }
});

async function updateStatusMessage() {
  const statusMessage = document.getElementById('statusMessage');
  if (!statusMessage) return;
  
  let text = '';
  let lastServerError = '';
  try {
    const res = await fetch('/api/ping', { cache: 'no-store', signal: AbortSignal.timeout(2000) });
    if (res.ok) {
      text = '‚úì Online';
      lastServerError = '';
      statusMessage.style.background = 'rgba(0, 200, 0, 0.8)';
      statusMessage.style.display = 'block';
    } else {
      text = '‚úó Offline';
      lastServerError = `(${res.status})`;
      statusMessage.style.background = 'rgba(200, 0, 0, 0.8)';
    }
  } catch (e) {
    // Server offline is normal - hide status to avoid clutter
    statusMessage.style.display = 'none';
    return;
  }
  statusMessage.textContent = `Server: ${text}${lastServerError ? ' ' + lastServerError : ''}`;
}

// Server start button - graceful failure
const statusMsg = document.getElementById('statusMessage');
if (statusMsg) {
  statusMsg.onclick = async function() {
    statusMsg.textContent = 'Server: Retrying...';
    statusMsg.style.background = 'rgba(255, 165, 0, 0.8)';
    try {
      const res = await fetch('/api/start-server', { method: 'POST', signal: AbortSignal.timeout(5000) });
      if (res.ok) {
        statusMsg.textContent = 'Server: Reconnecting...';
        setTimeout(updateStatusMessage, 3000);
      } else {
        statusMsg.textContent = 'Server: Optional';
        statusMsg.style.background = 'rgba(100, 100, 100, 0.7)';
        setTimeout(() => statusMsg.style.display = 'none', 3000);
      }
    } catch (e) {
      statusMsg.textContent = 'Server: Optional';
      statusMsg.style.background = 'rgba(100, 100, 100, 0.7)';
      setTimeout(() => statusMsg.style.display = 'none', 3000);
    }
  };
}
setInterval(updateStatusMessage, 5000);
updateStatusMessage();
</script>

<!-- Mandem.OS Universal Auth Integration -->
<script>
// Initialize wallet authentication for Mandem.OS
window.addEventListener('DOMContentLoaded', async () => {
    console.log('üåê Mandem.OS - Initializing Universal Auth...');
    
    try {
        // Initialize universal auth with custom integration
        await window.authIntegration.init({
            showUI: false,  // Use existing login UI
            onAuthSuccess: (authInfo) => {
                console.log('‚úÖ Mandem.OS - Wallet authenticated:', authInfo.address);
                updateMandemAuthUI(authInfo);
            },
            onAuthFail: () => {
                console.log('‚ö†Ô∏è Mandem.OS - Wallet not connected');
            }
        });
    } catch (error) {
        console.error('‚ùå Mandem.OS - Auth init failed:', error);
    }
});

// Update Mandem.OS auth UI
function updateMandemAuthUI(authInfo) {
    const loginBtn = document.getElementById('loginBtn');
    const profileBtn = document.getElementById('profileBtn');
    
    if (authInfo && authInfo.authenticated) {
        // User is authenticated
        if (loginBtn) loginBtn.style.display = 'none';
        if (profileBtn) {
            profileBtn.style.display = 'inline-block';
            profileBtn.textContent = `üë§ ${authInfo.shortAddress}`;
        }
        
        // Show work time if available
        if (authInfo.workTimeMinutes > 0) {
            const hours = Math.floor(authInfo.workTimeMinutes / 60);
            const mins = authInfo.workTimeMinutes % 60;
            console.log(`‚è±Ô∏è Work time: ${hours}h ${mins}m`);
        }
    } else {
        // User is not authenticated
        if (loginBtn) loginBtn.style.display = 'inline-block';
        if (profileBtn) profileBtn.style.display = 'none';
    }
}

// Enhance login button to use universal auth
const originalLoginBtn = document.getElementById('loginBtn');
if (originalLoginBtn) {
    originalLoginBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        
        try {
            const authInfo = await window.universalWalletAuth.connect();
            if (authInfo) {
                console.log('‚úÖ Mandem.OS wallet connected:', authInfo);
                updateMandemAuthUI(authInfo);
            }
        } catch (error) {
            console.error('‚ùå Mandem.OS wallet connection error:', error);
            alert('Wallet connection failed: ' + error.message);
        }
    });
}

// Listen for auth events
window.addEventListener('authSuccess', (event) => {
    console.log('üéâ Mandem.OS - Auth success event:', event.detail);
    updateMandemAuthUI(event.detail);
});

window.addEventListener('authLogout', () => {
    console.log('üëã Mandem.OS - Auth logout event');
    updateMandemAuthUI(null);
    // Reset GBPT balance on logout
    const gbptSpan = document.getElementById('mndmBalance');
    if (gbptSpan) gbptSpan.textContent = '0';
});

// Update GBPT Token Balance (GBPT) in header
async function updateGBPTBalance() {
    try {
        const gbptSpan = document.getElementById('mndmBalance');
        if (!gbptSpan) return;
        
        // Get connected wallet address
        const walletAddress = window.universalWalletAuth && window.universalWalletAuth.getAddress();
        
        if (!walletAddress) {
            // No wallet connected - show 0
            gbptSpan.textContent = '0';
            return;
        }
        
        // Fetch GBPT token balance
        const balance = await window.getTokenBalance(walletAddress);
        
        // Update display
        const formattedBalance = window.formatTokenAmount(balance, 2);
        gbptSpan.textContent = formattedBalance;
        
        console.log('üî• Mandem.OS - GBPT Balance Updated:', formattedBalance);
    } catch (error) {
        console.error('‚ùå Mandem.OS - Failed to update GBPT balance:', error);
        const gbptSpan = document.getElementById('mndmBalance');
        if (gbptSpan) gbptSpan.textContent = '0';
    }
}

// Update GBPT balance when wallet connects
window.addEventListener('authSuccess', (event) => {
    console.log('üéâ Mandem.OS - Auth success, updating GBPT balance...');
    updateGBPTBalance();
});

// Initial GBPT balance update on page load
setTimeout(() => {
    updateGBPTBalance();
}, 1500); // Wait 1.5 seconds for auth to initialize

console.log('‚úÖ Mandem.OS - Wallet integration loaded');
console.log('üî• GBPT Token tracking enabled');
console.log('üíé MGC Promotion System loaded');
</script>

    </body>     
</html>
