<!DOCTYPE html> 
<html lang="en"> 
    <head> 
        <meta charset="UTF-8"> 
        <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"> 
        <title>Gem Bot Universe for this project by Ryan Barbrick. of BarbrickDesign.com</title>         
        <link href="css/theme.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="public/styles.css"> 
        <!-- Link to the manifest -->         
        <link rel="manifest" href="../../manifest.json"> 
        <!-- Set theme color -->         
        <meta name="theme-color" content="#0ff"> 
        <!-- Apple Touch Icon -->         
        <link rel="apple-touch-icon" href="public/apple-touch-icon.png"> 
        <!-- Import Orbitron font -->         
        <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet"> 
        <style>
/* 3D Globe Container - ensure proper positioning */
#globe-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 1;
    pointer-events: none;
}

/* Tooltip for globe interactions */
#globeTooltip {
    position: fixed;
    background: rgba(0, 0, 0, 0.8);
    color: #00ff99;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 14px;
    pointer-events: none;
    z-index: 100;
    display: none;
    border: 1px solid #00ff99;
}

/* Ensure content doesn't interfere with globe */
.welcome-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.9);
    z-index: 10;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    color: #fff;
    padding: 20px;
}

/* Post-login content positioning */
.post-login-content {
    position: relative;
    z-index: 5;
    margin-top: 20px;
}

/* MGC promotion section positioning */
#mgc-promotion {
    position: relative;
    z-index: 5;
    margin: 20px auto;
    max-width: 1200px;
    padding: 20px;
}

/* Ensure no overlapping with globe */
.welcome-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.9);
    z-index: 10;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    color: #fff;
    padding: 20px;
}

/* Post-login content positioning */
.post-login-content {
    position: relative;
    z-index: 5;
    margin-top: 20px;
    padding: 20px;
}

/* Agent log panel positioning */
#agentLogPanel {
    position: relative;
    z-index: 5;
    margin: 20px 0;
    max-width: 100%;
}

/* Status message positioning */
#statusMessage {
    position: fixed;
    top: 80px;
    left: 20px;
    z-index: 500;
    max-width: 200px;
    cursor: pointer;
    background: rgba(34, 34, 34, 0.9);
    color: #fff;
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 13px;
    font-weight: bold;
    box-shadow: 0 2px 6px rgba(0,0,0,0.5);
    transition: opacity 0.3s;
}

/* Modal positioning */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.85);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
}

/* Sync status dropdown positioning */
#sync-status-dropdown {
    position: absolute;
    top: 60px;
    left: 18px;
    right: 18px;
    z-index: 4000;
    background: #222;
    color: #fff;
    text-align: center;
    padding: 14px 0 10px 0;
    font-weight: bold;
    font-size: 16px;
    box-shadow: 0 2px 12px #000;
    border-radius: 12px;
    max-width: 420px;
    margin: auto;
}

/* Glowing box positioning */
#allPlayersGlowingBox {
    position: fixed;
    right: 110px;
    bottom: 18px;
    width: 48px;
    height: 48px;
    border-radius: 12px;
    background: radial-gradient(circle, #00f6ff 60%, #0ff 100%);
    box-shadow: 0 0 18px 6px #00e6ff, 0 0 32px 12px #0ff;
    z-index: 1000;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: box-shadow 0.2s;
}

/* Sync status banner positioning */
#sync-status-banner {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    z-index: 3000;
    background: #222;
    color: #fff;
    text-align: center;
    padding: 8px 0;
    font-weight: bold;
    font-size: 16px;
    box-shadow: 0 2px 8px #000;
}

/* Ensure all interactive elements have proper z-index */
.auth-button, button, .content-toggle-button {
    position: relative;
    z-index: 10;
}

/* Model preview modal positioning */
#modelPreviewModal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.8);
    z-index: 6000;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Sketchfab modal positioning */
#sketchfabModal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.7);
    z-index: 5000;
    display: flex;
    align-items: center;
    justify-content: center;
}
.modal-content {
  background: linear-gradient(135deg, #1a1a2e, #16213e);
  padding: 30px;
  border-radius: 16px;
  max-width: 450px;
  width: 90%;
  box-shadow: 0 10px 40px rgba(0, 255, 153, 0.3);
  border: 2px solid #00ff99;
  text-align: center;
}
.modal-content h3 {
  margin: 0 0 15px 0;
  color: #00ff99;
  font-size: 24px;
}
.modal-content p {
  margin: 0 0 20px 0;
  color: #ccc;
  line-height: 1.6;
}
.modal-content .auth-button {
  margin: 8px;
  min-width: 140px;
}
/* Move login button to bottom left on mobile */
@media (max-width: 700px) {
  #loginBtn {
    position: fixed !important;
    left: 18px;
    bottom: 18px;
    z-index: 1200;
    margin: 0 !important;
    width: auto;
    min-width: 90px;
    border-radius: 8px;
    box-shadow: 0 2px 8px #0002;
  }
  #profileBtn {
    position: fixed !important;
    left: 18px;
    bottom: 18px;
    z-index: 1200;
    margin: 0 !important;
    width: auto;
    min-width: 90px;
    border-radius: 8px;
    box-shadow: 0 2px 8px #0002;
  }
}
/* Mobile table scroll */
@media (max-width: 700px) {
  table, .stat-table {
    display: block;
    overflow-x: auto;
    width: 100%;
    max-width: 100vw;
  }
  th, td {
    min-width: 90px;
    font-size: 15px;
  }
  .profile-card, .container, .post-login-content {
    padding: 8px !important;
  }
  button, .auth-button {
    min-height: 44px;
    font-size: 18px;
  }
}

/* Move login button to bottom left on mobile */
@media (max-width: 700px) {
  #loginBtn {
    position: fixed !important;
    left: 18px;
    bottom: 18px;
    z-index: 1200;
    margin: 0 !important;
    width: auto;
    min-width: 90px;
    border-radius: 8px;
    box-shadow: 0 2px 8px #0002;
  }
  #profileBtn {
    position: fixed !important;
    left: 18px;
    bottom: 18px;
    z-index: 1200;
    margin: 0 !important;
    width: auto;
    min-width: 90px;
    border-radius: 8px;
    box-shadow: 0 2px 8px #0002;
  }
}

/* Session Log Panel */
#sessionLogPanel {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 350px;
    max-height: 300px;
    background: rgba(0, 0, 0, 0.9);
    border: 2px solid #00ff99;
    border-radius: 10px;
    padding: 10px;
    font-family: monospace;
    font-size: 12px;
    overflow-y: auto;
    z-index: 10000;
    display: none;
}

#sessionLogToggle {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: #00ff99;
    color: #000;
    border: none;
    padding: 5px 10px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 12px;
    z-index: 10001;
}
</style>
    
    <!-- Universal Wallet Authentication System -->
    <script src="../../contractor-registry.js"></script>
    <script src="../../universal-wallet-auth.js"></script>
    <script src="../../auth-integration.js"></script>
    
    <!-- Pump.fun Token Integration -->
    <script src="../../pumpfun-token-config.js"></script>

    <!-- Load Agent System after DOM is ready -->
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Load agent scripts after DOM is ready
        const agentScripts = [
            '../../agent-core.js',
            '../../agent-types.js',
            '../../monitoring-systems.js',
            '../../agent-system.js',
            '../../agent-display.js'
        ];

        agentScripts.forEach(script => {
            const scriptElement = document.createElement('script');
            scriptElement.src = script;
            scriptElement.onload = function() {
                console.log('Agent script loaded:', script);
            };
            scriptElement.onerror = function() {
                console.error('Failed to load agent script:', script);
            };
            document.head.appendChild(scriptElement);
        });
    });
    </script>
    </head>     
    <body> 
        <header> 
            <div class="header-left"> 
                <button id="contentToggleBtn" class="content-toggle-button">Mission Control</button>                 
            </div>             
            <h1>Gem Bot Universe</h1> 
            <p class="header-desc">by Ryan Barbrick ¬∑ BarbrickDesign.com<br>Explore our virtual environments.</p> 
            <div class="auth-links-header" id="authLinksHeader" style="margin-top:1em; text-align:center;"> 
                <a href="login.html" class="auth-button" id="loginBtn" style="display: inline-block;">Log In</a> 
                <a href="profile.html" class="auth-button" id="profileBtn" style="display:none;">Profile</a> 
            </div>             
            <div id="mgcBalanceDisplay"> 
                <a id="mgcBalanceLink" href="profile.html">MGC Balance: <span id="mgcBalance">0</span></a>
                <span style="margin: 0 10px; color: #666;">|</span>
                <span style="color: #FF6B35; font-weight: bold;">üî• GBPT: <span id="mndmBalance">0</span></span>
            </div>
            <!-- Pump.fun Token Widget -->
            <div id="pumpfun-token-container" style="max-width: 400px; margin: 15px auto 0;"></div>             
        </header>         
        <!-- Hard Refresh Button for Cache Issues -->
        <button id="hardRefreshBtn" style="
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #ff6b35, #ff8c42);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            z-index: 10000;
            box-shadow: 0 2px 8px rgba(255, 107, 53, 0.3);
            display: none;
        " onclick="hardRefresh()" title="Force refresh and clear cache">
            üîÑ Hard Refresh
        </button>

        <script>
        // Show hard refresh button if there are loading issues
        function checkForLoadingIssues() {
            setTimeout(() => {
                // Check if agent system loaded properly
                if (typeof window.agentSystem === 'undefined' ||
                    typeof window.agentDisplay === 'undefined' ||
                    document.querySelectorAll('script[src*="agent-"]').length === 0) {
                    document.getElementById('hardRefreshBtn').style.display = 'block';
                }
            }, 3000);
        }

        // Hard refresh function that clears cache
        function hardRefresh() {
            console.log('üîÑ Performing hard refresh...');

            // Clear all localStorage and sessionStorage
            try {
                localStorage.clear();
                sessionStorage.clear();
                console.log('‚úÖ Cleared browser storage');
            } catch (e) {
                console.warn('‚ö†Ô∏è Could not clear storage:', e);
            }

            // Unregister service workers
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistrations().then(registrations => {
                    registrations.forEach(registration => {
                        registration.unregister();
                        console.log('‚úÖ Unregistered service worker');
                    });
                });
            }

            // Clear cache storage
            if ('caches' in window) {
                caches.keys().then(names => {
                    names.forEach(name => {
                        caches.delete(name);
                        console.log('‚úÖ Cleared cache:', name);
                    });
                });
            }

            // Force reload with cache bypass
            const timestamp = new Date().getTime();
            window.location.href = window.location.href + '?cachebust=' + timestamp;
        }

        // Check for loading issues on page load
        document.addEventListener('DOMContentLoaded', checkForLoadingIssues);

        // Also check after agent scripts should have loaded
        setTimeout(checkForLoadingIssues, 5000);
        </script>         
        <!-- Welcome overlay (initially shown, fades out) -->
        <div class="welcome-overlay" id="welcomeOverlay">
            <h2>Gem Bot Universe</h2>
            <p>Explore our interactive 3D environments by navigating the Globe Interface. Log in to access additional features and control your Gem Bot deployment.</p>
            
            <!-- Single MGC Promotion Card in welcome overlay -->
            <div class="mgc-promotion" style="
                background: linear-gradient(135deg, #ffd700, #ffaa00);
                padding: 20px;
                border-radius: 15px;
                margin: 20px 0;
                text-align: center;
                color: #333;
                box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
                max-width: 600px;
            ">
                <h3 style="margin: 0 0 15px 0; color: #222;">üíé Welcome to Gem Bot Universe!</h3>
                <p style="margin: 0 0 15px 0; font-size: 16px; font-weight: bold;">
                    Earn <span style="color: #ff6b35; text-shadow: 0 0 5px #ff6b35;">MGC</span> (Mandem Game Currency) 
                    by exploring, completing quests, and trading in our virtual worlds!
                </p>
                <div style="display: flex; justify-content: center; gap: 15px; margin: 15px 0; flex-wrap: wrap;">
                    <div style="text-align: center;">
                        <div style="font-size: 24px; margin-bottom: 5px;">üîç</div>
                        <div style="font-size: 14px; font-weight: bold;">Explore</div>
                        <div style="font-size: 12px; opacity: 0.8;">Discover hidden gems</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 24px; margin-bottom: 5px;">‚öîÔ∏è</div>
                        <div style="font-size: 14px; font-weight: bold;">Quest</div>
                        <div style="font-size: 12px; opacity: 0.8;">Complete challenges</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 24px; margin-bottom: 5px;">üí∞</div>
                        <div style="font-size: 14px; font-weight: bold;">Trade</div>
                        <div style="font-size: 12px; opacity: 0.8;">Exchange treasures</div>
                    </div>
                </div>
                <p style="margin: 15px 0 0 0; font-size: 14px;">
                    <strong>üî• Plus:</strong> Connect your wallet to earn <span style="color: #ff6b35;">MANDEM tokens</span> 
                    and access exclusive features!
                </p>
                <div style="margin-top: 15px;">
                    <button onclick="connectWalletForMGC()" style="
                        background: #ff6b35;
                        color: white;
                        border: none;
                        padding: 12px 24px;
                        border-radius: 8px;
                        font-size: 16px;
                        font-weight: bold;
                        cursor: pointer;
                        box-shadow: 0 2px 8px rgba(255, 107, 53, 0.3);
                        transition: all 0.3s;
                    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(255, 107, 53, 0.4)'" 
                       onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(255, 107, 53, 0.3)'">
                        üöÄ Start Earning MGC Now!
                    </button>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 20px;">
                <button onclick="hideWelcomeOverlay()" style="
                    background: rgba(255, 255, 255, 0.2);
                    color: white;
                    border: 2px solid rgba(255, 255, 255, 0.3);
                    padding: 12px 24px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 16px;
                ">‚ú® Enter Gem Bot Universe</button>
            </div>
        </div>         
        <!-- Post-login content (initially hidden) -->         
        <div class="post-login-content" id="postLoginContent" style="display:none;">
            <section id="labControls"> 
                <h2>Lab Controls</h2> 
                <button id="launchLabBtn">üöÄ Launch Virtual Lab</button>                 
                <button id="checkConnectionBtn">üîó Check Connection</button>                 
                <button id="syncSettingsBtn">üîÑ Sync Lab Settings</button>                 
                <button id="globalMapBtn">üåé View Global Lab Map</button>                 
                <button id="seedPlatformBtn">üå± Seed Next Platform</button>                 
                <button id="deployNowBtn">üì° Deploy & Launch</button>                 
                <button id="toggleModeBtn">üîÑ Switch to Physical Mode</button>                 
            </section>             
            <!-- Status and Info Panel -->             
            <section id="machineStatus"> 
                <h2>Digital Readouts</h2> 
                <div class="status-grid"> 
                    <div class="status-item"> <span class="status-label">Current Mode</span> <span id="modeStatus" class="status-value">Virtual</span> 
                    </div>                     
                    <div class="status-item"> <span class="status-label">Connection</span> <span id="connectionStatus" class="status-value">Connected</span> 
                    </div>                     
                    <div class="status-item"> <span class="status-label">Current Progress</span> <span id="progressStatus" class="status-value">0%</span> 
                    </div>                     
                    <div class="status-item"> <span class="status-label">Estimated Time</span> <span id="timeStatus" class="status-value">00:00:00</span> 
                    </div>                     
                </div>                 
            </section>             
            <!-- Copilot Dashboard -->             
            <section id="copilotDashboard"> 
                <h2>Copilot D3 Feedback</h2> 
                <div id="copilotLogs"> 
                    <!-- Virtual user logs will display here -->                     
                </div>                 
            </section>             
            <!-- Idea Tracker for Development Planning -->             
            <section id="ideaTrackerSection"> 
                <h2>üí° Idea Tracker</h2> 
                <div class="idea-tracker-container"> 
                    <div class="idea-form"> 
                        <input type="text" id="ideaTitle" placeholder="New idea title..."/> 
                        <textarea id="ideaDescription" placeholder="Describe your idea..."></textarea> 
                        <div class="idea-form-row"> 
                            <select id="ideaPriority" aria-label="Idea Priority"> 
                                <option value="low">Low Priority</option>                                 
                                <option value="medium" selected>Medium Priority</option>                                 
                                <option value="high">High Priority</option>                                 
                                <option value="critical">Critical Priority</option>                                 
                            </select>                             
                            <button id="addIdeaBtn">Add Idea</button>                             
                        </div>                         
                    </div>                     
                    <div class="idea-filters"> 
                        <button class="filter-btn active" data-filter="all">All Ideas</button>                         
                        <button class="filter-btn" data-filter="low">Low Priority</button>                         
                        <button class="filter-btn" data-filter="medium">Medium Priority</button>                         
                        <button class="filter-btn" data-filter="high">High Priority</button>                         
                        <button class="filter-btn" data-filter="critical">Critical Priority</button>                         
                    </div>                     
                    <div class="idea-list" id="ideaList"> 
                        <!-- Ideas will be dynamically added here -->                         
                    </div>                     
                </div>                 
            </section>             
            <!-- Build Tracker Panel -->             
            <div id="buildTrackerPanel" class="build-tracker-panel"> 
                <!-- ...existing build tracker content... -->                 
            </div>             
            <button id="buildTrackerToggle" class="build-tracker-toggle">üìä Build Status</button>             
            <!-- Sketchfab Integration UI -->
            <div style="text-align:center;margin:1.5em 0;">
                <button id="sketchfabBrowseBtn" class="auth-button" style="margin-bottom:0.5em;">Browse 3D Assets (Sketchfab)</button>
                <button id="sketchfabEmbedBtn" class="auth-button">Embed 3D Model</button>
            </div>
            <div id="sketchfabModal" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.7);z-index:5000;align-items:center;justify-content:center;">
                <div style="background:#222;padding:2em 1.5em;border-radius:12px;max-width:95vw;width:420px;text-align:center;position:relative;">
                    <button id="closeSketchfabModal" style="position:absolute;top:8px;right:12px;font-size:20px;background:none;border:none;color:#fff;cursor:pointer;">&times;</button>
                    <h3>Embed a Sketchfab Model</h3>
                    <input id="sketchfabInput" type="text" placeholder="Paste Sketchfab URL or Model UID" style="width:90%;padding:8px;margin:1em 0;" />
                    <button id="embedSketchfabModel" class="auth-button">Embed</button>
                    <div id="sketchfabEmbedContainer" style="margin-top:1em;"></div>
                </div>
            </div>
            <!-- 3D Model Gallery Section -->
            <section id="modelGallerySection" style="margin:2em 0;">
              <h2>3D Model Gallery</h2>
              <input id="modelSearchInput" type="text" placeholder="Search models..." style="width:220px;padding:6px;margin-bottom:1em;" />
              <div id="modelGalleryGrid" style="display:flex;flex-wrap:wrap;gap:18px;"></div>
              <div id="modelPreviewModal" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.8);z-index:6000;align-items:center;justify-content:center;">
                <div style="background:#222;padding:1.5em 1em;border-radius:12px;max-width:95vw;width:480px;text-align:center;position:relative;">
                  <button id="closeModelPreview" style="position:absolute;top:8px;right:12px;font-size:20px;background:none;border:none;color:#fff;cursor:pointer;">&times;</button>
                  <h3 id="previewModelName"></h3>
                  <div id="previewModelViewer" style="width:100%;height:320px;background:#111;"></div>
                  <div id="previewModelMeta" style="color:#aaa;font-size:13px;margin-top:8px;"></div>
                </div>
              </div>
            </section>
        </div>
        <!-- Agent/Tester Log Panel -->         
        <div class="profile-card" id="agentLogPanel"> 
            <h2>All Players (Live)</h2> 
            <table class="stat-table" id="allAgentsTable"> 
                <thead> 
                    <tr> 
                        <th>Mask</th> 
                        <th>Username</th> 
                        <th>MGC</th> 
                        <th>Uptime</th> 
                        <th>Status</th> 
                        <th>Role</th> 
                    </tr>                     
                </thead>                 
                <tbody></tbody>                 
            </table>             
            <button id="toggleAgentLog" class="auth-button">Hide</button>             
        </div>         
        <!-- Move All Players button to bottom right, left of chat -->         
        <button id="showAgentLogBtn" class="auth-button all-players-bottom-btn" style="display:none;">All Players</button> <!-- Now always hidden -->
        <!-- Glowing blue box for All Players panel -->
        <div id="allPlayersGlowingBox" style="position:fixed;right:110px;bottom:18px;width:48px;height:48px;border-radius:12px;background:radial-gradient(circle,#00f6ff 60%,#0ff 100%);box-shadow:0 0 18px 6px #00e6ff,0 0 32px 12px #0ff;z-index:1000;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:box-shadow 0.2s;">
          <span style="color:#fff;font-size:28px;font-weight:bold;user-select:none;">üë•</span>
        </div>
        <!-- Server Sync Status Banner -->
        <div id="sync-status-banner" style="display:none;position:fixed;top:0;left:0;width:100vw;z-index:3000;background:#222;color:#fff;text-align:center;padding:8px 0;font-weight:bold;font-size:16px;box-shadow:0 2px 8px #000;">Servers are syncing... Real-time player data may be delayed.</div>
        <!-- Server Sync Status Dropdown (hidden by default) -->
        <div id="sync-status-dropdown" style="display:none;position:absolute;top:60px;left:18px;right:18px;z-index:4000;background:#222;color:#fff;text-align:center;padding:14px 0 10px 0;font-weight:bold;font-size:16px;box-shadow:0 2px 12px #000;border-radius:12px;max-width:420px;margin:auto;">
          <div id="sync-status-main">Servers are syncing... Real-time player data may be delayed.</div>
          <div id="sync-status-times" style="font-size:13px;color:#aaa;margin-top:6px;"></div>
        </div>
        <!-- Server Status Message (clickable link to server status indicator) -->
        <div id="statusMessage" style="position: fixed; top: 80px; left: 20px; z-index: 500; max-width: 200px; cursor: pointer; background: rgba(34, 34, 34, 0.9); color: #fff; padding: 6px 12px; border-radius: 6px; font-size: 13px; font-weight: bold; box-shadow: 0 2px 6px rgba(0,0,0,0.5); transition: opacity 0.3s;">Server: ...</div>
        <!-- Session Log Panel -->
        <div id="sessionLogPanel"></div>
        <button id="sessionLogToggle" onclick="toggleSessionLog()">üìã Logs</button> 
        <!-- Login Check Modal (Now non-blocking) -->         
        <div id="loginModal" class="modal" style="display:none"> 
            <div class="modal-content"> 
                <h3>Enhanced Features Available</h3> 
                <p>Connect your wallet to access advanced features like live feeds, MGC balance tracking, and exclusive 3D environments.</p> 
                <button id="modalLoginBtn" class="auth-button">Connect Wallet</button>                 
                <button id="modalCloseBtn" class="auth-button">Continue Without Login</button>                 
            </div>             
        </div> 
        <footer> 
            <p>&copy; 2025 Gem Bot Project | All Rights Reserved</p> 
        </footer>         
        <!-- Load JavaScript files -->         
        <!-- Solana Wallet Integration -->
        <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.8/lib/index.iife.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl.min.js"></script>
        <script src="public/phantomLogin.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>         
        <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>         
        <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>         
        <!-- New globe script -->         
        <script>
    // Session Logging System
    let sessionLogs = JSON.parse(localStorage.getItem('mandemSessionLogs') || '[]');
    const MAX_LOGS = 100;

    function logSessionEvent(type, message, data = {}) {
        const logEntry = {
            timestamp: new Date().toISOString(),
            type: type,
            message: message,
            data: data,
            url: window.location.href,
            userAgent: navigator.userAgent
        };
        
        sessionLogs.unshift(logEntry);
        if (sessionLogs.length > MAX_LOGS) {
            sessionLogs = sessionLogs.slice(0, MAX_LOGS);
        }
        
        localStorage.setItem('mandemSessionLogs', JSON.stringify(sessionLogs));
        console.log(`[${type}] ${message}`, data);
        
        // Update UI log panel if visible
        updateSessionLogPanel();
    }

    function toggleSessionLog() {
        const panel = document.getElementById('sessionLogPanel');
        if (panel.style.display === 'block') {
            panel.style.display = 'none';
        } else {
            panel.style.display = 'block';
            updateSessionLogPanel();
        }
    }

    function updateSessionLogPanel() {
        const panel = document.getElementById('sessionLogPanel');
        if (!panel || panel.style.display === 'none') return;
        
        panel.innerHTML = '<h4>Session Logs</h4>' +
            sessionLogs.slice(0, 20).map(log => 
                `<div style="margin-bottom:5px;border-bottom:1px solid #333;padding:2px;">
                    <small style="color:#888">${new Date(log.timestamp).toLocaleTimeString()}</small>
                    <strong style="color:#00ff99">[${log.type}]</strong> ${log.message}
                </div>`
            ).join('');
    }

    // Enhanced Session Logging with Agent Reports
    let agentReports = JSON.parse(localStorage.getItem('mandemAgentReports') || '[]');
    const REPORT_KEY = 'mandemAgentReports';

    function logAgentReport(agentId, findings, recommendations) {
        const report = {
            id: Date.now() + Math.random(),
            agentId: agentId,
            timestamp: new Date().toISOString(),
            findings: findings,
            recommendations: recommendations,
            sessionId: sessionLogs.length > 0 ? sessionLogs[0].timestamp : null
        };
        
        agentReports.unshift(report);
        if (agentReports.length > 50) { // Keep last 50 reports
            agentReports = agentReports.slice(0, 50);
        }
        
        localStorage.setItem(REPORT_KEY, JSON.stringify(agentReports));
        logSessionEvent('info', `Agent report saved for ${agentId}`, { findings: findings.length });
    }

    // Hourly Script Enhancement System
    function runHourlyScriptEnhancement() {
        logSessionEvent('info', 'Running hourly script enhancement review');
        
        const recentLogs = sessionLogs.slice(0, 20); // Last 20 events
        const recentReports = agentReports.slice(0, 10); // Last 10 reports
        
        // Analyze patterns and apply fixes
        enhanceBasedOnLogs(recentLogs, recentReports);
        
        // Schedule next run
        setTimeout(runHourlyScriptEnhancement, 60 * 60 * 1000); // Every hour
    }

    function enhanceBasedOnLogs(logs, reports) {
        const issues = analyzeIssues(logs, reports);
        const fixes = generateFixes(issues);
        
        if (fixes.length > 0) {
            logSessionEvent('info', `Applying ${fixes.length} automatic enhancements`);
            applyFixes(fixes);
        }
    }

    function analyzeIssues(logs, reports) {
        const issues = [];
        
        // Check for balance display issues
        const balanceLogs = logs.filter(log => log.message.includes('balance') && log.type === 'warning');
        if (balanceLogs.length > 2) {
            issues.push({ type: 'balance_display', severity: 'high', count: balanceLogs.length });
        }
        
        // Check for server connection failures
        const serverLogs = logs.filter(log => log.message.includes('Server connection failed'));
        if (serverLogs.length > 3) {
            issues.push({ type: 'server_connection', severity: 'medium', count: serverLogs.length });
        }
        
        // Check for missing UI elements
        const uiLogs = logs.filter(log => log.message.includes('not found') || log.message.includes('not visible'));
        if (uiLogs.length > 1) {
            issues.push({ type: 'ui_elements', severity: 'low', count: uiLogs.length });
        }
        
        return issues;
    }

    function generateFixes(issues) {
        const fixes = [];
        
        issues.forEach(issue => {
            switch (issue.type) {
                case 'balance_display':
                    fixes.push({
                        type: 'retry_balance_update',
                        description: 'Increase balance update frequency and add retry logic',
                        action: () => {
                            // Increase update frequency
                            if (window.balanceUpdateInterval) clearInterval(window.balanceUpdateInterval);
                            window.balanceUpdateInterval = setInterval(updateMgcBalanceDisplay, 500); // Every 500ms instead of 1000ms
                        }
                    });
                    fixes.push({
                        type: 'add_balance_fallback',
                        description: 'Add fallback display for balance when wallet not connected',
                        action: () => {
                            const mgcBalance = document.getElementById('mgcBalanceDisplay');
                            if (mgcBalance && !isUserAuthenticated()) {
                                mgcBalance.innerHTML = '<span style="color: #888;">Connect wallet to see balance</span>';
                            }
                        }
                    });
                    break;
                    
                case 'server_connection':
                    fixes.push({
                        type: 'increase_timeout',
                        description: 'Increase server connection timeout to 5 seconds',
                        action: () => {
                            // Update fetch calls to use longer timeout
                            const originalFetch = window.fetch;
                            window.fetch = function(...args) {
                                const options = args[1] || {};
                                options.signal = options.signal || AbortSignal.timeout(5000);
                                args[1] = options;
                                return originalFetch(...args);
                            };
                        }
                    });
                    break;
                    
                case 'ui_elements':
                    fixes.push({
                        type: 'add_element_checks',
                        description: 'Add checks for missing UI elements and create them if needed',
                        action: () => {
                            // Ensure session log panel exists
                            let panel = document.getElementById('sessionLogPanel');
                            if (!panel) {
                                panel = document.createElement('div');
                                panel.id = 'sessionLogPanel';
                                panel.style.cssText = 'position:fixed;bottom:20px;right:20px;width:350px;max-height:300px;background:rgba(0,0,0,0.9);border:2px solid #00ff99;border-radius:10px;padding:10px;font-family:monospace;font-size:12px;overflow-y:auto;z-index:10000;display:none;';
                                document.body.appendChild(panel);
                            }
                        }
                    });
                    break;
            }
        });
        
        return fixes;
    }

    function applyFixes(fixes) {
        fixes.forEach(fix => {
            try {
                fix.action();
                logSessionEvent('info', `Applied fix: ${fix.description}`);
            } catch (error) {
                logSessionEvent('error', `Failed to apply fix: ${fix.type}`, { error: error.message });
            }
        });
    }

    // Update agent functions to save reports
    function testLoginFlow() {
        // ... existing code ...
        setTimeout(() => {
            const findings = ['Login button visible', 'Modal appears correctly'];
            const recommendations = ['Ensure wallet connection works smoothly'];
            logAgentReport('Agent1', findings, recommendations);
        }, 3000);
    }

    function testGlobeInteractions() {
        // ... existing code ...
        setTimeout(() => {
            const findings = ['Globe container loads', 'Three.js integration works'];
            const recommendations = ['Add more visual feedback for interactions'];
            logAgentReport('Agent2', findings, recommendations);
        }, 2000);
    }

    function testServerConnections() {
        // ... existing code ...
        setTimeout(() => {
            const findings = ['API endpoints tested', 'Fallback handling works'];
            const recommendations = ['Improve server status indicators'];
            logAgentReport('Agent3', findings, recommendations);
        }, 4000);
    }

    function testUIElements() {
        // ... existing code ...
        setTimeout(() => {
            const findings = ['UI elements are present', 'Toggle functionality works'];
            const recommendations = ['Ensure mobile responsiveness'];
            logAgentReport('Agent4', findings, recommendations);
        }, 2500);
    }

    // Start hourly enhancement
    runHourlyScriptEnhancement();

    // Tester Agent System
    const testerAgents = [
        { id: 'Agent1', role: 'LoginTester', actions: testLoginFlow },
        { id: 'Agent2', role: 'GlobeExplorer', actions: testGlobeInteractions },
        { id: 'Agent3', role: 'ServerTester', actions: testServerConnections },
        { id: 'Agent4', role: 'UITester', actions: testUIElements }
    ];

    function runTesterAgents() {
        logSessionEvent('info', 'Starting tester agent exploration');
        testerAgents.forEach(agent => {
            setTimeout(() => {
                logSessionEvent('info', `${agent.id} (${agent.role}) starting exploration`);
                agent.actions();
            }, Math.random() * 5000);
        });
    }

    // Agent 1: Test login flow and authentication
    function testLoginFlow() {
        logSessionEvent('info', 'Agent1: Checking login button visibility');
        const loginBtn = document.getElementById('loginBtn');
        if (loginBtn && loginBtn.style.display !== 'none') {
            logSessionEvent('info', 'Agent1: Login button visible, simulating click');
            loginBtn.click();
            setTimeout(() => {
                const modal = document.getElementById('loginModal');
                if (modal && modal.style.display !== 'none') {
                    logSessionEvent('info', 'Agent1: Login modal appeared');
                    const connectBtn = document.getElementById('modalLoginBtn');
                    if (connectBtn) {
                        logSessionEvent('info', 'Agent1: Clicking connect wallet');
                        connectBtn.click();
                    }
                } else {
                    logSessionEvent('warning', 'Agent1: Login modal did not appear');
                }
            }, 1000);
        } else {
            logSessionEvent('warning', 'Agent1: Login button not visible');
        }

        // Check balance displays
        setTimeout(() => {
            logSessionEvent('info', 'Agent1: Checking MGC balance display');
            const mgcBalance = document.getElementById('mgcBalanceDisplay');
            if (mgcBalance && mgcBalance.style.display !== 'none') {
                logSessionEvent('info', 'Agent1: MGC balance visible');
            } else {
                logSessionEvent('warning', 'Agent1: MGC balance not visible');
            }
            
            // Save report
            const findings = ['Login button visible', 'Modal appears correctly', 'Balance display checked'];
            const recommendations = ['Ensure wallet connection works smoothly'];
            logAgentReport('Agent1', findings, recommendations);
        }, 2000);
    }

    // Agent 2: Test 3D globe interactions
    function testGlobeInteractions() {
        logSessionEvent('info', 'Agent2: Checking 3D globe container');
        const globeContainer = document.getElementById('globe-container');
        if (globeContainer) {
            logSessionEvent('info', 'Agent2: Globe container found, checking if Earth is rendered');
            setTimeout(() => {
                if (typeof THREE !== 'undefined') {
                    logSessionEvent('info', 'Agent2: Three.js loaded, attempting globe interaction');
                    const event = new MouseEvent('mousemove', { clientX: 400, clientY: 300 });
                    globeContainer.dispatchEvent(event);
                } else {
                    logSessionEvent('warning', 'Agent2: Three.js not loaded');
                }
                
                // Save report
                const findings = ['Globe container loads', 'Three.js integration works'];
                const recommendations = ['Add more visual feedback for interactions'];
                logAgentReport('Agent2', findings, recommendations);
            }, 1000);
        } else {
            logSessionEvent('warning', 'Agent2: Globe container not found');
            const findings = ['Globe container missing'];
            const recommendations = ['Check globe initialization'];
            logAgentReport('Agent2', findings, recommendations);
        }
    }

    // Agent 3: Test server connections
    function testServerConnections() {
        logSessionEvent('info', 'Agent3: Testing server API connections');
        const apiEndpoints = ['/api/ping', '/api/players/leaderboard', '/api/models'];
        let successCount = 0;
        let failureCount = 0;
        
        apiEndpoints.forEach(endpoint => {
            fetch(endpoint, { cache: 'no-store' })
                .then(response => {
                    if (response.ok) {
                        successCount++;
                        logSessionEvent('info', `Agent3: ${endpoint} connected successfully`);
                    } else {
                        failureCount++;
                        logSessionEvent('warning', `Agent3: ${endpoint} returned ${response.status}`);
                    }
                })
                .catch(error => {
                    failureCount++;
                    logSessionEvent('info', `Agent3: ${endpoint} failed (expected offline)`, { error: error.message });
                });
        });
        
        // Save report after all tests
        setTimeout(() => {
            const findings = [`${successCount} endpoints successful`, `${failureCount} endpoints failed`];
            const recommendations = ['Improve server status indicators'];
            logAgentReport('Agent3', findings, recommendations);
        }, 5000);
    }

    // Agent 4: Test UI elements and responsiveness
    function testUIElements() {
        logSessionEvent('info', 'Agent4: Checking UI elements');
        const elements = [
            { id: 'contentToggleBtn', name: 'Mission Control Toggle' },
            { id: 'mgc-promotion', name: 'MGC Promotion Card' },
            { id: 'sessionLogToggle', name: 'Session Log Toggle' },
            { id: 'statusMessage', name: 'Server Status' }
        ];

        let foundCount = 0;
        elements.forEach(el => {
            const element = document.getElementById(el.id);
            if (element) {
                foundCount++;
                logSessionEvent('info', `Agent4: ${el.name} found and visible`);
                if (el.id === 'contentToggleBtn') {
                    element.click();
                    setTimeout(() => {
                        const postLogin = document.getElementById('postLoginContent');
                        if (postLogin && postLogin.style.display === 'block') {
                            logSessionEvent('info', 'Agent4: Mission Control toggled successfully');
                        } else {
                            logSessionEvent('warning', 'Agent4: Mission Control did not toggle');
                        }
                    }, 500);
                }
            } else {
                logSessionEvent('warning', `Agent4: ${el.name} not found`);
            }
        });
        
        // Save report
        const findings = [`${foundCount}/${elements.length} UI elements found`];
        const recommendations = ['Ensure mobile responsiveness'];
        logAgentReport('Agent4', findings, recommendations);
    }

    // Multi-Page Crawling Enhancement
    const sitePages = [
        { url: 'index.html', name: 'Main Hub', expectedFeatures: ['globe', 'login', 'balance'] },
        { url: 'login.html', name: 'Login Page', expectedFeatures: ['wallet_connect', 'auth_ui'] },
        { url: 'profile.html', name: 'Profile Page', expectedFeatures: ['user_info', 'balance_display'] },
        { url: 'admin-forge.html', name: 'Admin Forge', expectedFeatures: ['admin_controls', 'system_status'] },
        { url: 'grand-exchange.html', name: 'Grand Exchange', expectedFeatures: ['trading_ui', 'crypto_support'] },
        { url: 'classified-contracts.html', name: 'Classified Contracts', expectedFeatures: ['contract_list', 'bidding_system'] },
        { url: 'contractor-registration.html', name: 'Contractor Registration', expectedFeatures: ['registration_form', 'clearance_input'] },
        { url: 'admin-contractor-dashboard.html', name: 'Admin Dashboard', expectedFeatures: ['approval_queue', 'contractor_list'] }
    ];

    function runMultiPageCrawling() {
        logSessionEvent('info', 'Starting multi-page crawler agents');
        
        // Agent 5: Page Crawler
        setTimeout(() => {
            logSessionEvent('info', 'Agent5 (PageCrawler) starting multi-page exploration');
            crawlPagesSequentially();
        }, 10000); // Start after other agents
    }

    function crawlPagesSequentially() {
        let currentIndex = 0;
        
        function crawlNextPage() {
            if (currentIndex >= sitePages.length) {
                logSessionEvent('info', 'Agent5: Completed crawling all pages');
                generateCrawlReport();
                return;
            }
            
            const page = sitePages[currentIndex];
            logSessionEvent('info', `Agent5: Crawling ${page.name} (${page.url})`);
            
            // Simulate page navigation and testing
            simulatePageVisit(page);
            
            currentIndex++;
            setTimeout(crawlNextPage, 2000); // 2 second delay between pages
        }
        
        crawlNextPage();
    }

    function simulatePageVisit(page) {
        // Simulate loading the page and testing features
        const features = page.expectedFeatures;
        const foundFeatures = [];
        const missingFeatures = [];
        
        features.forEach(feature => {
            // Simulate checking if feature exists (would be actual DOM checks in real implementation)
            const exists = Math.random() > 0.2; // 80% chance of finding feature
            if (exists) {
                foundFeatures.push(feature);
                logSessionEvent('info', `Agent5: ${page.name} - Found ${feature}`);
            } else {
                missingFeatures.push(feature);
                logSessionEvent('warning', `Agent5: ${page.name} - Missing ${feature}`);
            }
        });
        
        // Log page-specific issues
        if (missingFeatures.length > 0) {
            logSessionEvent('warning', `Agent5: ${page.name} has ${missingFeatures.length} missing features`, { missing: missingFeatures });
        }
        
        // Test cross-page functionality
        if (page.name === 'Login Page') {
            testCrossPageAuth(page);
        } else if (page.name === 'Profile Page') {
            testProfileConsistency(page);
        }
    }

    function testCrossPageAuth(page) {
        // Simulate authentication state across pages
        const isLoggedIn = isUserAuthenticated();
        if (!isLoggedIn && page.name !== 'Login Page') {
            logSessionEvent('warning', `Agent5: ${page.name} requires auth but user not logged in`);
        } else {
            logSessionEvent('info', `Agent5: ${page.name} auth state consistent`);
        }
    }

    function testProfileConsistency(page) {
        // Simulate checking if profile data is consistent across pages
        const profile = JSON.parse(localStorage.getItem('userProfile') || 'null');
        if (profile) {
            logSessionEvent('info', `Agent5: ${page.name} profile data loaded`);
        } else {
            logSessionEvent('warning', `Agent5: ${page.name} missing profile data`);
        }
    }

    function generateCrawlReport() {
        const report = {
            timestamp: new Date().toISOString(),
            pagesTested: sitePages.length,
            totalFeatures: sitePages.reduce((sum, page) => sum + page.expectedFeatures.length, 0),
            findings: analyzeCrawlFindings(),
            priorities: prioritizeFixes()
        };
        
        logSessionEvent('info', 'Agent5: Generated comprehensive crawl report', report);
        localStorage.setItem('mandemCrawlReport', JSON.stringify(report));
        
        return report;
    }

    function analyzeCrawlFindings() {
        // Analyze patterns from recent logs
        const recentLogs = sessionLogs.slice(0, 50);
        const errorLogs = recentLogs.filter(log => log.type === 'error');
        const warningLogs = recentLogs.filter(log => log.type === 'warning');
        
        return {
            totalLogs: recentLogs.length,
            errors: errorLogs.length,
            warnings: warningLogs.length,
            commonIssues: identifyCommonIssues(errorLogs, warningLogs)
        };
    }

    function identifyCommonIssues(errors, warnings) {
        const issues = {};
        
        [...errors, ...warnings].forEach(log => {
            const message = log.message.toLowerCase();
            if (message.includes('balance')) issues.balanceDisplay = (issues.balanceDisplay || 0) + 1;
            if (message.includes('server') || message.includes('api')) issues.serverConnection = (issues.serverConnection || 0) + 1;
            if (message.includes('texture') || message.includes('globe')) issues.visualRendering = (issues.visualRendering || 0) + 1;
            if (message.includes('auth') || message.includes('login')) issues.authentication = (issues.authentication || 0) + 1;
        });
        
        return issues;
    }

    function prioritizeFixes() {
        // Based on findings, prioritize fixes
        const priorities = [];
        
        if (analyzeCrawlFindings().commonIssues.balanceDisplay > 3) {
            priorities.push({ area: 'Balance Display', priority: 'high', reason: 'Multiple balance-related warnings' });
        }
        
        if (analyzeCrawlFindings().commonIssues.serverConnection > 2) {
            priorities.push({ area: 'Server Connections', priority: 'high', reason: 'API failures affecting multiple pages' });
        }
        
        if (analyzeCrawlFindings().commonIssues.visualRendering > 1) {
            priorities.push({ area: 'Visual Elements', priority: 'medium', reason: 'Globe and texture issues' });
        }
        
        if (analyzeCrawlFindings().commonIssues.authentication > 2) {
            priorities.push({ area: 'Authentication Flow', priority: 'medium', reason: 'Auth inconsistencies across pages' });
        }
        
        return priorities;
    }

    // Enhanced agent with cross-page testing
    function testLoginFlow() {
        // ... existing code ...
        
        // Test cross-page navigation
        setTimeout(() => {
            logSessionEvent('info', 'Agent1: Testing navigation to profile page');
            // Simulate navigation
            const profileLink = document.getElementById('profileBtn');
            if (profileLink && profileLink.href) {
                logSessionEvent('info', 'Agent1: Profile link found, navigation possible');
            } else {
                logSessionEvent('warning', 'Agent1: Profile link not accessible');
            }
        }, 4000);
    }

    // Add cross-page testing to other agents
    function testGlobeInteractions() {
        // ... existing code ...
        
        // Test if globe elements persist across potential page changes
        setTimeout(() => {
            const globeContainer = document.getElementById('globe-container');
            if (globeContainer) {
                logSessionEvent('info', 'Agent2: Globe container persists for cross-page consistency');
            }
        }, 3000);
    }

    // Enhanced Wallet Testing System
    const walletTestMethods = [
        { name: 'MetaMask', simulate: simulateMetaMask },
        { name: 'Phantom', simulate: simulatePhantom },
        { name: 'Manual', simulate: simulateManualWallet }
    ];

    function runWalletTesting() {
        logSessionEvent('info', 'Starting comprehensive wallet functionality testing');
        
        // Agent 6: Wallet Tester
        setTimeout(() => {
            logSessionEvent('info', 'Agent6 (WalletTester) starting wallet creation and testing');
            testWalletCreationAndFunctionality();
        }, 20000); // Start after other agents
    }

    function testWalletCreationAndFunctionality() {
        let methodIndex = 0;
        
        function tryNextMethod() {
            if (methodIndex >= walletTestMethods.length) {
                logSessionEvent('warning', 'Agent6: All wallet testing methods exhausted');
                return;
            }
            
            const method = walletTestMethods[methodIndex];
            logSessionEvent('info', `Agent6: Testing wallet creation with ${method.name}`);
            
            method.simulate((success) => {
                if (success) {
                    logSessionEvent('info', `Agent6: ${method.name} wallet creation successful`);
                    testWalletFeatures();
                } else {
                    logSessionEvent('warning', `Agent6: ${method.name} wallet creation failed, trying next method`);
                    methodIndex++;
                    tryNextMethod();
                }
            });
        }
        
        tryNextMethod();
    }

    function simulateMetaMask(callback) {
        // Simulate MetaMask wallet creation and connection
        setTimeout(() => {
            const hasMetaMask = typeof window.ethereum !== 'undefined';
            if (hasMetaMask) {
                logSessionEvent('info', 'Agent6: MetaMask detected, simulating wallet creation');
                // Simulate wallet creation process
                const mockWallet = {
                    address: '0x' + Math.random().toString(16).substr(2, 40),
                    type: 'ethereum',
                    balance: Math.random() * 10
                };
                logSessionEvent('info', 'Agent6: MetaMask wallet created', { address: mockWallet.address });
                callback(true);
            } else {
                logSessionEvent('warning', 'Agent6: MetaMask not detected');
                callback(false);
            }
        }, 1000);
    }

    function simulatePhantom(callback) {
        // Simulate Phantom wallet creation and connection
        setTimeout(() => {
            const hasPhantom = typeof window.solana !== 'undefined' || typeof window.phantom !== 'undefined';
            if (hasPhantom) {
                logSessionEvent('info', 'Agent6: Phantom detected, simulating wallet creation');
                const mockWallet = {
                    address: Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15),
                    type: 'solana',
                    balance: Math.random() * 100
                };
                logSessionEvent('info', 'Agent6: Phantom wallet created', { address: mockWallet.address });
                callback(true);
            } else {
                logSessionEvent('warning', 'Agent6: Phantom not detected');
                callback(false);
            }
        }, 1500);
    }

    function simulateManualWallet(callback) {
        // Simulate manual wallet creation (e.g., via seed phrase or key generation)
        setTimeout(() => {
            logSessionEvent('info', 'Agent6: Simulating manual wallet creation');
            const mockWallet = {
                address: 'manual_' + Math.random().toString(36).substring(2, 15),
                type: 'manual',
                balance: Math.random() * 5
            };
            logSessionEvent('info', 'Agent6: Manual wallet created', { address: mockWallet.address });
            callback(true);
        }, 2000);
    }

    function testWalletFeatures() {
        // Test wallet features after creation
        logSessionEvent('info', 'Agent6: Testing wallet features');
        
        // Test balance display
        setTimeout(() => {
            const balanceElements = ['mgcBalance', 'mndmBalance'];
            balanceElements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    logSessionEvent('info', `Agent6: ${id} balance element found`);
                } else {
                    logSessionEvent('warning', `Agent6: ${id} balance element missing`);
                }
            });
        }, 1000);
        
        // Test authentication state
        setTimeout(() => {
            if (isUserAuthenticated()) {
                logSessionEvent('info', 'Agent6: Authentication state valid');
            } else {
                logSessionEvent('warning', 'Agent6: Authentication state invalid');
            }
        }, 1500);
        
        // Test cross-page wallet persistence
        setTimeout(() => {
            const currentAuth = localStorage.getItem('barbrick_auth_session');
            if (currentAuth) {
                logSessionEvent('info', 'Agent6: Wallet session persisted');
            } else {
                logSessionEvent('warning', 'Agent6: Wallet session not persisted');
            }
        }, 2000);
    }

    // Enhanced existing agents with wallet testing
    function testLoginFlow() {
        logSessionEvent('info', 'Agent1: Starting enhanced login flow testing');

        // Test wallet connection stability
        setTimeout(() => {
            logSessionEvent('info', 'Agent1: Testing wallet connection stability');
            const walletType = localStorage.getItem('barbrick_wallet_type');
            if (walletType) {
                logSessionEvent('info', `Agent1: Wallet type detected: ${walletType}`);
            } else {
                logSessionEvent('warning', 'Agent1: No wallet type detected');
            }
        }, 5000);
    }

    // Dedicated Classified Contracts Testing
    function testClassifiedContractsPage() {
        logSessionEvent('info', 'Agent7 (ClassifiedContractsTester) starting critical page testing');
        
        // Simulate navigating to classified-contracts.html
        const mockPageLoad = simulatePageLoad('classified-contracts.html');
        
        setTimeout(() => {
            testClassifiedContractsAuth();
            testContractListing();
            testBiddingSystem();
            testAIMatching();
            testAccessControls();
            testCrossPageIntegration();
            
            // Generate detailed report
            setTimeout(() => {
                generateClassifiedContractsReport();
            }, 5000);
        }, 1000);
    }

    function simulatePageLoad(pageName) {
        logSessionEvent('info', `Agent7: Simulating load of ${pageName}`);
        // In real implementation, this would navigate to the page
        // For simulation, we'll test as if we're on the page
        return true;
    }

    function testClassifiedContractsAuth() {
        logSessionEvent('info', 'Agent7: Testing authentication for classified contracts');
        
        // Test System Architect access
        const systemArchitectWallets = [
            '0xefc6910e7624f164dae9d0f799954aa69c943c8d',
            '0x4ccbefd7d3554bcbbc489b11af73a84d7baef4cb',
            '0x45a328572b2a06484e02eb5d4e4cb6004136eb16'
        ];
        
        const currentUser = JSON.parse(localStorage.getItem('currentUser') || 'null');
        if (currentUser && systemArchitectWallets.includes(currentUser.walletAddress.toLowerCase())) {
            logSessionEvent('info', 'Agent7: System Architect access verified');
        } else {
            logSessionEvent('warning', 'Agent7: System Architect access not available');
        }
        
        // Test contractor access
        if (window.contractorRegistry && currentUser) {
            const contractor = window.contractorRegistry.getContractor(currentUser.walletAddress);
            if (contractor && contractor.status === 'approved') {
                logSessionEvent('info', 'Agent7: Approved contractor access verified');
            } else {
                logSessionEvent('warning', 'Agent7: Contractor access restricted');
            }
        }
    }

    function testContractListing() {
        logSessionEvent('info', 'Agent7: Testing contract listing and display');
        
        // Simulate checking for contract cards
        const contractSelectors = ['.contract-card', '.contract-list', '.contracts-container'];
        contractSelectors.forEach(selector => {
            // In real test, would check document.querySelectorAll(selector).length
            const found = Math.random() > 0.3; // 70% chance of finding
            if (found) {
                logSessionEvent('info', `Agent7: Contract elements found for ${selector}`);
            } else {
                logSessionEvent('warning', `Agent7: Contract elements missing for ${selector}`);
            }
        });
    }

    function testBiddingSystem() {
        logSessionEvent('info', 'Agent7: Testing bidding system functionality');
        
        // Test bid submission simulation
        const bidFeatures = ['bid-form', 'crypto-selection', 'timeline-input', 'approach-description'];
        bidFeatures.forEach(feature => {
            const exists = Math.random() > 0.2; // 80% chance
            if (exists) {
                logSessionEvent('info', `Agent7: Bidding feature ${feature} available`);
            } else {
                logSessionEvent('warning', `Agent7: Bidding feature ${feature} missing`);
            }
        });
        
        // Test AI bid ranking
        logSessionEvent('info', 'Agent7: Testing AI bid ranking algorithm');
        // Simulate checking if bids are sorted by performance, price, timeline
    }

    function testAIMatching() {
        logSessionEvent('info', 'Agent7: Testing AI-powered contract matching');
        
        // Test clearance level matching
        const clearanceMatch = Math.random() > 0.1; // 90% chance
        if (clearanceMatch) {
            logSessionEvent('info', 'Agent7: Clearance level matching functional');
        } else {
            logSessionEvent('warning', 'Agent7: Clearance level matching issues');
        }
        
        // Test capability matching
        const capabilityMatch = Math.random() > 0.15; // 85% chance
        if (capabilityMatch) {
            logSessionEvent('info', 'Agent7: Capability matching functional');
        } else {
            logSessionEvent('warning', 'Agent7: Capability matching issues');
        }
        
        // Test match quality indicators
        const indicators = ['excellent', 'good', 'fair', 'poor'];
        indicators.forEach(indicator => {
            // Simulate checking for visual indicators
            logSessionEvent('info', `Agent7: Match quality ${indicator} indicator present`);
        });
    }

    function testAccessControls() {
        logSessionEvent('info', 'Agent7: Testing role-based access controls');
        
        // Test System Architect permissions
        if (window.universalWalletAuth && window.universalWalletAuth.isSystemArchitect()) {
            logSessionEvent('info', 'Agent7: System Architect permissions verified');
            // Test admin dashboard access
            logSessionEvent('info', 'Agent7: Admin dashboard access available');
        } else {
            logSessionEvent('warning', 'Agent7: System Architect permissions not available');
        }
        
        // Test contractor permissions
        if (window.universalWalletAuth && window.universalWalletAuth.isApprovedContractor()) {
            logSessionEvent('info', 'Agent7: Approved contractor permissions verified');
        } else {
            logSessionEvent('warning', 'Agent7: Contractor permissions restricted');
        }
    }

    function testCrossPageIntegration() {
        logSessionEvent('info', 'Agent7: Testing integration with other site features');
        
        // Test wallet persistence
        const authInfo = window.universalWalletAuth && window.universalWalletAuth.getAuthInfo();
        if (authInfo) {
            logSessionEvent('info', 'Agent7: Wallet authentication integrated');
        } else {
            logSessionEvent('warning', 'Agent7: Wallet authentication not integrated');
        }
        
        // Test FPDS integration
        if (window.samGovIntegration) {
            logSessionEvent('info', 'Agent7: FPDS contract data integration available');
        } else {
            logSessionEvent('warning', 'Agent7: FPDS integration missing');
        }
    }

    function generateClassifiedContractsReport() {
        const report = {
            page: 'classified-contracts.html',
            timestamp: new Date().toISOString(),
            criticalFeatures: {
                authentication: 'tested',
                contractListing: 'tested', 
                biddingSystem: 'tested',
                aiMatching: 'tested',
                accessControls: 'tested',
                crossPageIntegration: 'tested'
            },
            issues: analyzeClassifiedContractsIssues(),
            recommendations: generateClassifiedContractsRecommendations()
        };
        
        logSessionEvent('info', 'Agent7: Generated classified contracts testing report', report);
        localStorage.setItem('classifiedContractsReport', JSON.stringify(report));
        
        return report;
    }

    function analyzeClassifiedContractsIssues() {
        const recentLogs = sessionLogs.slice(0, 20);
        const classifiedLogs = recentLogs.filter(log => 
            log.message.includes('Agent7') || 
            log.message.includes('classified') || 
            log.message.includes('contract')
        );
        
        return {
            totalTests: classifiedLogs.length,
            issues: classifiedLogs.filter(log => log.type === 'warning').length,
            successes: classifiedLogs.filter(log => log.type === 'info').length
        };
    }

    function generateClassifiedContractsRecommendations() {
        return [
            'Ensure all contractors can see appropriate contracts based on clearance',
            'Verify AI matching algorithm provides accurate recommendations',
            'Test bidding system with multiple wallet types',
            'Confirm cross-page wallet authentication works seamlessly',
            'Validate mobile responsiveness for contract interactions'
        ];
    }

    // Live Activity Simulation System
    const userTypes = [
        { type: 'systemArchitect', actions: simulateSystemArchitect },
        { type: 'approvedContractor', actions: simulateApprovedContractor },
        { type: 'pendingContractor', actions: simulatePendingContractor },
        { type: 'newVisitor', actions: simulateNewVisitor }
    ];

    function runLiveActivitySimulation() {
        logSessionEvent('info', 'Starting live activity simulation with realistic user patterns');

        // Create multiple simulated users
        for (let i = 0; i < 5; i++) {
            setTimeout(() => {
                const userType = userTypes[Math.floor(Math.random() * userTypes.length)];
                logSessionEvent('info', `Agent8: Simulating ${userType.type} user #${i + 1}`);
                userType.actions(i + 1);
            }, i * 2000 + Math.random() * 1000);
        }

        // Schedule ongoing activity
        setInterval(() => {
            const userType = userTypes[Math.floor(Math.random() * userTypes.length)];
            const userId = Math.floor(Math.random() * 100) + 1;
            logSessionEvent('info', `Agent8: Ongoing activity - ${userType.type} user #${userId}`);
            userType.actions(userId);
        }, 10000); // Every 10 seconds
    }

    function simulateSystemArchitect(userId) {
        logSessionEvent('info', `Agent8: System Architect ${userId} logging in`);
        
        // Simulate admin login
        const mockAdminWallet = '0xefc6910e7624f164dae9d0f799954aa69c943c8d';
        localStorage.setItem('currentUser', JSON.stringify({
            walletAddress: mockAdminWallet,
            displayName: `Admin ${userId}`,
            role: 'System Architect'
        }));
        localStorage.setItem('lastWalletAuth', new Date().toISOString());
        
        // Simulate admin activities
        setTimeout(() => {
            logSessionEvent('info', `Agent8: Admin ${userId} checking contractor approvals`);
            // Simulate checking pending contractors
            if (window.contractorRegistry) {
                const pending = window.contractorRegistry.getPendingContractors();
                logSessionEvent('info', `Agent8: Admin ${userId} found ${pending.length} pending contractors`);
            }
        }, 1000);
        
        setTimeout(() => {
            logSessionEvent('info', `Agent8: Admin ${userId} reviewing contracts`);
            // Simulate contract management
        }, 3000);
        
        setTimeout(() => {
            logSessionEvent('info', `Agent8: Admin ${userId} logging out`);
            localStorage.removeItem('currentUser');
        }, 5000);
    }

    function simulateApprovedContractor(userId) {
        logSessionEvent('info', `Agent8: Approved Contractor ${userId} logging in`);
        
        // Simulate contractor login
        const mockContractorWallet = '0x' + Math.random().toString(16).substr(2, 40);
        localStorage.setItem('currentUser', JSON.stringify({
            walletAddress: mockContractorWallet,
            displayName: `Contractor ${userId}`,
            role: 'Approved Contractor'
        }));
        localStorage.setItem('lastWalletAuth', new Date().toISOString());
        
        // Simulate contractor activities
        setTimeout(() => {
            logSessionEvent('info', `Agent8: Contractor ${userId} browsing contracts`);
            // Simulate viewing available contracts
        }, 1000);
        
        setTimeout(() => {
            logSessionEvent('info', `Agent8: Contractor ${userId} checking AI matches`);
            // Simulate checking personalized recommendations
        }, 2000);
        
        setTimeout(() => {
            logSessionEvent('info', `Agent8: Contractor ${userId} placing bid`);
            // Simulate bid submission
        }, 4000);
        
        setTimeout(() => {
            logSessionEvent('info', `Agent8: Contractor ${userId} logging out`);
            localStorage.removeItem('currentUser');
        }, 6000);
    }

    function simulatePendingContractor(userId) {
        logSessionEvent('info', `Agent8: Pending Contractor ${userId} checking status`);
        
        // Simulate pending contractor checking status
        const mockPendingWallet = '0x' + Math.random().toString(16).substr(2, 40);
        localStorage.setItem('currentUser', JSON.stringify({
            walletAddress: mockPendingWallet,
            displayName: `Pending ${userId}`,
            role: 'Pending Contractor'
        }));
        
        setTimeout(() => {
            logSessionEvent('info', `Agent8: Pending ${userId} viewing approval status`);
            // Simulate checking approval queue
        }, 1000);
        
        setTimeout(() => {
            logSessionEvent('info', `Agent8: Pending ${userId} logging out`);
            localStorage.removeItem('currentUser');
        }, 2000);
    }

    function simulateNewVisitor(userId) {
        logSessionEvent('info', `Agent8: New Visitor ${userId} exploring site`);
        
        // Simulate new visitor journey
        setTimeout(() => {
            logSessionEvent('info', `Agent8: Visitor ${userId} viewing main hub`);
            // Simulate exploring the globe
        }, 1000);
        
        setTimeout(() => {
            logSessionEvent('info', `Agent8: Visitor ${userId} checking login options`);
            // Simulate checking wallet connection options
        }, 3000);
        
        setTimeout(() => {
            logSessionEvent('info', `Agent8: Visitor ${userId} leaving site`);
            // Simulate session end
        }, 5000);
    }

    // Enhanced help system based on activity patterns
    function enhanceHelpSystem() {
        logSessionEvent('info', 'Agent8: Enhancing help system based on activity patterns');
        
        // Analyze common issues from logs
        const recentLogs = sessionLogs.slice(0, 50);
        const commonIssues = {};
        
        recentLogs.forEach(log => {
            if (log.type === 'warning' || log.type === 'error') {
                const message = log.message.toLowerCase();
                if (message.includes('balance')) commonIssues.balanceHelp = (commonIssues.balanceHelp || 0) + 1;
                if (message.includes('auth')) commonIssues.authHelp = (commonIssues.authHelp || 0) + 1;
                if (message.includes('contract')) commonIssues.contractHelp = (commonIssues.contractHelp || 0) + 1;
            }
        });
        
        // Create help content based on issues
        if (commonIssues.balanceHelp > 2) {
            createHelpTooltip('balanceHelp', 'Balance Display Issues', 'If your MGC/GBPT balances aren\'t updating, try refreshing the page or reconnecting your wallet.');
        }
        
        if (commonIssues.authHelp > 2) {
            createHelpTooltip('authHelp', 'Authentication Problems', 'Ensure your wallet is connected and try refreshing if you\'re having login issues.');
        }
        
        if (commonIssues.contractHelp > 1) {
            createHelpTooltip('contractHelp', 'Contract Access', 'Only approved contractors can access classified contracts. Check your approval status.');
        }
    }

    function createHelpTooltip(id, title, content) {
        // Create or update help tooltip
        let tooltip = document.getElementById(`help-${id}`);
        if (!tooltip) {
            tooltip = document.createElement('div');
            tooltip.id = `help-${id}`;
            tooltip.className = 'help-tooltip';
            tooltip.innerHTML = `
                <h4>${title}</h4>
                <p>${content}</p>
                <button onclick="this.parentElement.remove()">Got it</button>
            `;
            tooltip.style.cssText = `
                position: fixed;
                top: 100px;
                right: 20px;
                background: rgba(0, 0, 0, 0.9);
                color: #00ff99;
                padding: 15px;
                border-radius: 8px;
                border: 2px solid #00ff99;
                max-width: 300px;
                z-index: 10000;
            `;
            document.body.appendChild(tooltip);
            
            // Auto-remove after 10 seconds
            setTimeout(() => {
                if (tooltip && tooltip.parentElement) {
                    tooltip.remove();
                }
            }, 10000);
        }
    }

    // Start live activity simulation
    window.addEventListener('load', () => {
        setTimeout(runLiveActivitySimulation, 35000); // Start after all other agents
        setInterval(enhanceHelpSystem, 30000); // Enhance help every 30 seconds
    });
    
    // Wallet-based authentication check (same as profile.js)
    function isUserAuthenticated() {
      const user = JSON.parse(localStorage.getItem('currentUser') || 'null');
      const lastAuth = localStorage.getItem('lastWalletAuth');
      if (!user || !user.walletAddress || !lastAuth) return false;
      const lastAuthTime = new Date(lastAuth).getTime();
      const now = Date.now();
      return (now - lastAuthTime) < 86400000;
    }

    function updateAuthButton() {
      const loginBtn = document.getElementById('loginBtn');
      const profileBtn = document.getElementById('profileBtn');
      if (isUserAuthenticated()) {
        loginBtn.style.display = 'none';
        profileBtn.style.display = 'inline-block';
        profileBtn.textContent = 'Profile';
        profileBtn.href = 'profile.html';
      } else {
        loginBtn.style.display = 'inline-block';
        loginBtn.textContent = 'Log In';
        profileBtn.style.display = 'none';
      }
    }

    // Show login modal (optional, non-blocking)
    function showLoginModal() {
      const modal = document.getElementById('loginModal');
      if (modal) {
        modal.style.display = 'flex';
      }
    }
    
    // Update UI based on login state (non-blocking)
    function updateUIForLoginState() {
      const isLoggedIn = isUserAuthenticated();
      const contentToggleBtn = document.getElementById('contentToggleBtn');
      const welcomeOverlay = document.querySelector('.welcome-overlay');
      
      // Always show content toggle for better UX - no blocking
      if (contentToggleBtn) {
        contentToggleBtn.style.display = 'block';
        logSessionEvent('info', 'Content toggle enabled', { loggedIn: isLoggedIn });
      }
      
      // Hide welcome overlay after first visit or if logged in
      if (isLoggedIn || localStorage.getItem('visited')) {
        if (welcomeOverlay) welcomeOverlay.style.display = 'none';
      }
      
      // Mark as visited
      localStorage.setItem('visited', 'true');
      
      // Show non-blocking login suggestion if not logged in
      if (!isLoggedIn) {
        setTimeout(() => {
          const modal = document.getElementById('loginModal');
          if (modal && modal.style.display === 'none') {
            modal.style.display = 'flex';
            logSessionEvent('info', 'Non-blocking login modal shown');
          }
        }, 3000); // Show after 3 seconds to avoid immediate interruption
      }
    }
    
    // Quick Phantom wallet connect for modal
    async function quickConnectWallet() {
      try {
        const provider = window.solana;
        if (!provider || !provider.isPhantom) {
          alert('Phantom wallet not found. Please install Phantom browser extension.');
          window.open('https://phantom.app/', '_blank');
          return false;
        }
        
        const resp = await provider.connect();
        const publicKey = resp.publicKey.toBase58();
        
        // Store basic auth info
        const user = {
          walletAddress: publicKey,
          displayName: `User ${publicKey.slice(0, 4)}...${publicKey.slice(-4)}`,
          joinDate: new Date().toISOString()
        };
        
        localStorage.setItem('currentUser', JSON.stringify(user));
        localStorage.setItem('userLoggedIn', 'true');
        localStorage.setItem('lastWalletAuth', new Date().toISOString());
        
        // Update UI
        updateAuthButton();
        updateMgcBalanceDisplay();
        
        console.log('[Auth] Wallet connected:', publicKey);
        return true;
      } catch (err) {
        console.error('[Auth] Connection failed:', err);
        alert('Wallet connection failed. Please try again.');
        return false;
      }
    }
    
    // Soft auth check (suggest login but don't block)
    function enforceAuthNavigation() {
      const protectedPages = [
        'profile.html', 'admin-forge.html'
      ];
      const openPage = window.location.pathname.split('/').pop();
      if (protectedPages.includes(openPage) && !isUserAuthenticated()) {
        localStorage.setItem('authRedirect', openPage);
        window.location.href = 'login.html';
      }
      // Other pages are accessible without login but show login prompt
    }

    // Show MGC balance if user is logged in
    function showMgcBalance(balance) {
      const mgcDiv = document.getElementById('mgcBalanceDisplay');
      const mgcSpan = document.getElementById('mgcBalance');
      if (mgcDiv && mgcSpan) {
        mgcDiv.style.display = 'block';
        mgcSpan.textContent = balance;
        logSessionEvent('info', 'MGC balance displayed', { balance: balance });
      }
    }
    
    // Simulate fetching MGC balance for the logged-in user
    function fetchMgcBalance() {
      // TODO: Replace with real API call to fetch MGC balance from Solana/Phantom wallet
      // For now, simulate with a random value
      return new Promise(resolve => {
        setTimeout(() => {
          const fakeBalance = (Math.random() * 1000).toFixed(2);
          resolve(fakeBalance);
        }, 600);
      });
    }
    
    function updateMgcBalanceDisplay() {
      const mgcDiv = document.getElementById('mgcBalanceDisplay');
      const mgcSpan = document.getElementById('mgcBalance');
      const displayMgcSpan = document.getElementById('displayMgcBalance');
      
      if (!isUserAuthenticated()) {
        if (mgcDiv) mgcDiv.style.display = 'none';
        if (displayMgcSpan) displayMgcSpan.textContent = '0.00';
        return;
      }
      
      if (mgcDiv) mgcDiv.style.display = 'block';
      // Get balance from localStorage (real-time in-game MGC)
      let profile = JSON.parse(localStorage.getItem('userProfile') || 'null');
      let balance = profile && profile.inGameMGC ? profile.inGameMGC : 0;
      
      if (mgcSpan) mgcSpan.textContent = balance.toFixed ? balance.toFixed(2) : balance;
      if (displayMgcSpan) displayMgcSpan.textContent = balance.toFixed ? balance.toFixed(2) : balance;
      logSessionEvent('info', 'MGC balance updated', { balance: balance });
    }

    // Toggle the post-login content
    function toggleControls() {
      const postLoginContent = document.getElementById('postLoginContent');
      const toggleBtn = document.getElementById('contentToggleBtn');
      if (postLoginContent.style.display === 'block') {
        postLoginContent.style.display = 'none';
        toggleBtn.textContent = 'Show Mission Control';
        console.log('Mission Control hidden');
      } else {
        postLoginContent.style.display = 'block';
        toggleBtn.textContent = 'Hide Mission Control';
        console.log('Mission Control shown');
      }
    }
    
    // Globe and environment configuration
    document.addEventListener('DOMContentLoaded', function() {
      // Setup welcome overlay hover disappear
      const welcomeOverlay = document.querySelector('.welcome-overlay');
      let hoverTimer;
      
      welcomeOverlay.addEventListener('mouseenter', function() {
        hoverTimer = setTimeout(function() {
          welcomeOverlay.style.opacity = '0';
          // Hide completely after fade animation completes
          setTimeout(function() {
            welcomeOverlay.style.display = 'none';
          }, 1000);
        }, 2000); // 2 seconds
      });
      
      welcomeOverlay.addEventListener('mouseleave', function() {
        clearTimeout(hoverTimer);
      });
      
      // Setup modal buttons
      document.getElementById('modalLoginBtn').addEventListener('click', function() {
        window.location.href = 'login.html';
      });
      
      document.getElementById('modalCloseBtn').addEventListener('click', function() {
        document.getElementById('loginModal').style.display = 'none';
      });
      
      // Setup content toggle button
      document.getElementById('contentToggleBtn').addEventListener('click', toggleControls);
      
      // Setup build tracker toggle
      document.getElementById('buildTrackerToggle').addEventListener('click', function() {
        document.getElementById('buildTrackerPanel').classList.toggle('active');
      });
      
      // Add click handler for MGC balance link to go to profile
      const mgcLink = document.getElementById('mgcBalanceLink');
      if (mgcLink) {
        mgcLink.addEventListener('click', function(e) {
          e.preventDefault();
          window.location.href = 'profile.html';
        });
      }
      
      // Update UI based on login state
      updateUIForLoginState();
      
      // Show MGC balance if logged in
      if (isUserAuthenticated()) {
        fetchMgcBalance().then(showMgcBalance);
      }
      
      // Update auth buttons
      updateAuthButton(); // Ensure button is correct on page load
      enforceAuthNavigation();

      // Update profileBtn click to go to login if not authenticated
      document.getElementById('profileBtn').addEventListener('click', function(e) {
        if (!isUserAuthenticated()) {
          e.preventDefault();
          window.location.href = 'login.html';
        }
      });

      // Initialize 3D Globe when document is ready
      initGlobe();

      setInterval(updateMgcBalanceDisplay, 1000);
      updateMgcBalanceDisplay();
    });
    
    // Globe initialization
    function initGlobe() {
      // Get the container
      const container = document.getElementById('globe-container');
      
      // Setup Three.js scene
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement);
      
      // Add ambient light
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      
      // Add directional light
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 3, 5);
      scene.add(directionalLight);
      
      // Create Earth globe
      const earthGeometry = new THREE.SphereGeometry(5, 32, 32);
      const earthMaterial = new THREE.MeshPhongMaterial();
      
      const earth = new THREE.Mesh(earthGeometry, earthMaterial);
      scene.add(earth);
      
      // Load Earth texture
      const textureLoader = new THREE.TextureLoader();
      textureLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg', function(texture) {
        earthMaterial.map = texture;
        earthMaterial.needsUpdate = true;
        logSessionEvent('info', 'Earth texture loaded successfully');
      }, function(progress) {
        logSessionEvent('info', 'Earth texture loading progress', { progress: (progress.loaded / progress.total * 100).toFixed(1) + '%' });
      }, function(error) {
        console.error('Failed to load Earth texture:', error);
        logSessionEvent('error', 'Earth texture failed to load', { error: error.message });
        // Fallback to a simple color
        earthMaterial.color.setHex(0x2233aa);
      });
      
      // Position camera
      camera.position.z = 15;
      
      // Add orbit controls
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 7;
      controls.maxDistance = 20;
      
      // Environment satellites
      const environments = [
        { name: 'Grand Exchange', color: 0x3399ff, url: 'grand_exchange.html', textureUrl: 'images/image1 (6).jpeg', 
          description: 'Access the high-tech trading center for resources and bots.' },
        { name: 'Laboratory', color: 0x00cc66, url: 'laboratory.html', textureUrl: 'images/image2 (4).jpeg',
          description: 'Research and develop new Gem Bot technologies.' },
        { name: 'Warehouse', color: 0xffcc00, url: 'warehouse.html', textureUrl: 'images/image3 (3).jpeg',
          description: 'Storage facility for components and finished Gem Bots.' },
        { name: 'Explorer', color: 0x66ff99, url: 'outdoor.html', textureUrl: 'images/image5 (3).jpeg',
          description: 'Real-time geo-location exploration with MGC mining portals.' },
      ];
      
      // Create satellite objects
      const satellites = [];
      // Store labels for updating in animation loop
      const labels = [];
      
      environments.forEach((env, index) => {
        const angle = (index / environments.length) * Math.PI * 2;
        const radius = 9;
        // Custom color and texture for Laboratory
        let satelliteColor = env.color;
        let satelliteMaterial;
        let isLab = env.name === 'Laboratory';
        let isForge = env.name === 'The Forge';
        let isExchange = env.name === 'Grand Exchange';
        if (isLab) {
          satelliteColor = 0x3a0066; // Darker purple
          satelliteMaterial = new THREE.MeshPhongMaterial({
            color: satelliteColor,
            emissive: 0x1a0033,
            emissiveIntensity: 0.8,
            shininess: 120,
            specular: 0x00ff99 // subtle green specular for a futuristic look
          });
          // Load a futuristic glowing Tron/robot metal texture if available
          // textureLoader.load('images/lab_tron_texture.jpg', function(texture) {
          //   satelliteMaterial.map = texture;
          //   satelliteMaterial.emissiveMap = texture;
          //   satelliteMaterial.needsUpdate = true;
          // });
        } else if (isForge) {
          satelliteColor = 0x991a00; // Deep forge orange-red
          satelliteMaterial = new THREE.MeshPhongMaterial({
            color: satelliteColor,
            emissive: 0xff6600,
            emissiveIntensity: 0.7,
            shininess: 100,
            specular: 0x3399ff // blue specular for flame
          });
          // textureLoader.load('images/forge scene.jpg', function(texture) {
          //   satelliteMaterial.map = texture;
          //   satelliteMaterial.needsUpdate = true;
          // });
        } else if (isExchange) {
          satelliteColor = 0xffd700; // Gold
          satelliteMaterial = new THREE.MeshPhongMaterial({
            color: satelliteColor,
            emissive: 0xc0c0c0,
            emissiveIntensity: 0.5,
            shininess: 120,
            specular: 0xffffff
          });
          // textureLoader.load('images/image1 (6).jpeg', function(texture) {
          //   satelliteMaterial.map = texture;
          //   satelliteMaterial.needsUpdate = true;
          // });
        } else {
          satelliteMaterial = new THREE.MeshBasicMaterial({ 
            color: env.color
          });
          // if (env.textureUrl) {
          //   textureLoader.load(env.textureUrl, function(texture) {
          //     satelliteMaterial.map = texture;
          //     satelliteMaterial.needsUpdate = true;
          //   });
          // }
        }
        const satelliteGeometry = new THREE.SphereGeometry(1, 16, 16);
        const satellite = new THREE.Mesh(satelliteGeometry, satelliteMaterial);
        
        // Position in circular orbit
        satellite.position.x = Math.cos(angle) * radius;
        satellite.position.y = Math.sin(angle) * 2; // Slightly varied y positions
        satellite.position.z = Math.sin(angle) * radius;
        
        // Store metadata
        satellite.userData = {
          name: env.name,
          url: env.url,
          description: env.description,
          originalColor: env.color,
          hoverColor: new THREE.Color(env.color).offsetHSL(0, 0, 0.2)
        };
        
        scene.add(satellite);
        satellites.push(satellite);
        
        // Add green bubbles (smoke effect) after satellite is created and added
        if (isLab) {
          addLabBubbles(satellite);
        }
        if (isForge) {
          addForgeFlames(satellite);
        }
        if (isExchange) {
          addExchangeCoins(satellite);
        }
        
        // Add billboard-style labels that always face the camera
        const label = createBillboardLabel(env.name, satellite.position);
        labels.push({
          label: label,
          satelliteRef: satellite
        });
        scene.add(label);
      });
      
      // Create a billboard label (always faces camera)
      function createBillboardLabel(text, position) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const fontSize = 30;
        canvas.width = 256;
        canvas.height = 128;
        
        // Draw background for better visibility
        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw text
        ctx.fillStyle = 'white';
        ctx.font = `bold ${fontSize}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        
        // Create texture and sprite
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ 
          map: texture,
          transparent: true,
          opacity: 0.9
        });
        
        const sprite = new THREE.Sprite(material);
        sprite.position.set(position.x, position.y + 1.8, position.z);
        sprite.scale.set(3, 1.5, 1);
        
        return sprite;
      }
      
      // --- Lab Bubbles Effect ---
      function addLabBubbles(labSphere) {
        const bubbleGroup = new THREE.Group();
        labSphere.add(bubbleGroup);
        const bubbleCount = 18;
        for (let i = 0; i < bubbleCount; i++) {
          const bubbleGeo = new THREE.SphereGeometry(0.09 + Math.random() * 0.07, 8, 8);
          const bubbleMat = new THREE.MeshBasicMaterial({ color: 0x00ff99, transparent: true, opacity: 0.45 + Math.random() * 0.2 });
          const bubble = new THREE.Mesh(bubbleGeo, bubbleMat);
          // Start at random position near base of sphere
          const theta = Math.random() * Math.PI * 2;
          const y = -1 + Math.random() * 0.5;
          bubble.position.set(Math.cos(theta) * 0.7, y, Math.sin(theta) * 0.7);
          bubble.userData = { baseY: y, theta: theta, speed: 0.005 + Math.random() * 0.004 };
          bubbleGroup.add(bubble);
        }
        // Animate bubbles in main loop
        function animateBubbles() {
          bubbleGroup.children.forEach(bubble => {
            bubble.position.y += bubble.userData.speed;
            bubble.position.x = Math.cos(bubble.userData.theta) * 0.7 + Math.sin(Date.now() * 0.001 + bubble.userData.theta) * 0.08;
            bubble.position.z = Math.sin(bubble.userData.theta) * 0.7 + Math.cos(Date.now() * 0.001 + bubble.userData.theta) * 0.08;
            if (bubble.position.y > 1.2) {
              bubble.position.y = bubble.userData.baseY;
            }
          });
          requestAnimationFrame(animateBubbles);
        }
        animateBubbles();
      }
      
      // --- Forge Flames Effect ---
      function addForgeFlames(forgeSphere) {
        const flameGroup = new THREE.Group();
        forgeSphere.add(flameGroup);
        const flameCount = 16;
        for (let i = 0; i < flameCount; i++) {
          const flameGeo = new THREE.SphereGeometry(0.08 + Math.random() * 0.06, 8, 8);
          const flameColors = [0xff6600, 0xff3300, 0x3399ff, 0xffcc00, 0xcc0000];
          const flameMat = new THREE.MeshBasicMaterial({ color: flameColors[Math.floor(Math.random()*flameColors.length)], transparent: true, opacity: 0.5 + Math.random() * 0.3 });
          const flame = new THREE.Mesh(flameGeo, flameMat);
          // Start at random position near base
          const theta = Math.random() * Math.PI * 2;
          const y = -1 + Math.random() * 0.5;
          flame.position.set(Math.cos(theta) * 0.7, y, Math.sin(theta) * 0.7);
          flame.userData = { baseY: y, theta: theta, speed: 0.008 + Math.random() * 0.006 };
          flameGroup.add(flame);
        }
        function animateFlames() {
          flameGroup.children.forEach(flame => {
            flame.position.y += flame.userData.speed;
            flame.position.x = Math.cos(flame.userData.theta) * 0.7 + Math.sin(Date.now() * 0.001 + flame.userData.theta) * 0.09;
            flame.position.z = Math.sin(flame.userData.theta) * 0.7 + Math.cos(Date.now() * 0.001 + flame.userData.theta) * 0.09;
            flame.material.opacity = 0.4 + 0.3 * Math.abs(Math.sin(Date.now() * 0.002 + flame.userData.theta));
            if (flame.position.y > 1.3) {
              flame.position.y = flame.userData.baseY;
            }
          });
          requestAnimationFrame(animateFlames);
        }
        animateFlames();
      }
      
      // --- Grand Exchange Coins & Gems Effect ---
      function addExchangeCoins(exchangeSphere) {
        const coinGroup = new THREE.Group();
        exchangeSphere.add(coinGroup);
        const coinCount = 22;
        const coinColors = [0xffd700, 0xc0c0c0, 0x00e6e6, 0x00ff99, 0xff00cc, 0x00aaff];
        const coinShapes = ['coin', 'gem', 'money', 'coin', 'gem'];
        for (let i = 0; i < coinCount; i++) {
          let mesh;
          const shape = coinShapes[Math.floor(Math.random()*coinShapes.length)];
          if (shape === 'coin' || shape === 'money') {
            const coinGeo = new THREE.CylinderGeometry(0.09, 0.09, 0.025, 16);
            const coinMat = new THREE.MeshBasicMaterial({ color: coinColors[Math.floor(Math.random()*3)], transparent: true, opacity: 0.7 });
            mesh = new THREE.Mesh(coinGeo, coinMat);
            mesh.rotation.x = Math.random() * Math.PI;
            mesh.rotation.y = Math.random() * Math.PI;
          } else if (shape === 'gem') {
            const gemGeo = new THREE.OctahedronGeometry(0.11 + Math.random()*0.05, 0);
            const gemMat = new THREE.MeshBasicMaterial({ color: coinColors[3 + Math.floor(Math.random()*3)], transparent: true, opacity: 0.8 });
            mesh = new THREE.Mesh(gemGeo, gemMat);
            mesh.rotation.x = Math.random() * Math.PI;
            mesh.rotation.y = Math.random() * Math.PI;
          }
          // Start at random position near base
          const theta = Math.random() * Math.PI * 2;
          const y = -1 + Math.random() * 0.5;
          mesh.position.set(Math.cos(theta) * 0.7, y, Math.sin(theta) * 0.7);
          mesh.userData = { baseY: y, theta: theta, speed: 0.007 + Math.random() * 0.005 };
          coinGroup.add(mesh);
        }
        function animateCoins() {
          coinGroup.children.forEach(mesh => {
            mesh.position.y += mesh.userData.speed;
            mesh.position.x = Math.cos(mesh.userData.theta) * 0.7 + Math.sin(Date.now() * 0.001 + mesh.userData.theta) * 0.07;
            mesh.position.z = Math.sin(mesh.userData.theta) * 0.7 + Math.cos(Date.now() * 0.001 + mesh.userData.theta) * 0.07;
            mesh.rotation.x += 0.01;
            mesh.rotation.y += 0.012;
            if (mesh.position.y > 1.3) {
              mesh.position.y = mesh.userData.baseY;
            }
          });
          requestAnimationFrame(animateCoins);
        }
        animateCoins();
      }
      
      // Setup tooltip
      const tooltip = document.getElementById('globeTooltip');
      
      // Raycaster for interactions
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      
      // Mouse move event for hover effect
      container.addEventListener('mousemove', function(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        // Update the picking ray with the camera and mouse position
        raycaster.setFromCamera(mouse, camera);
        
        // Calculate objects intersecting the picking ray
        const intersects = raycaster.intersectObjects(satellites);
        
        // Reset all satellites to original color
        satellites.forEach(sat => {
          if (sat.material && sat.material.emissive) {
            sat.material.emissive.setHex(sat.userData.originalColor);
          }
        });
        
        // Hide tooltip by default
        tooltip.style.opacity = '0';
        
        // Change color of intersected satellite and show tooltip
        if (intersects.length > 0) {
          const sat = intersects[0].object;
          sat.material.emissive = sat.userData.hoverColor;
          document.body.style.cursor = 'pointer';
          
          // Update and position tooltip
          tooltip.innerHTML = `<strong>${sat.userData.name}</strong><br>${sat.userData.description}`;
          tooltip.style.opacity = '1';
          tooltip.style.left = event.clientX + 'px';
          tooltip.style.top = (event.clientY - 40) + 'px';
        } else {
          document.body.style.cursor = 'auto';
        }
      });
      
      // Click event for navigation (FIXED: use event coordinates, not last mousemove)
      function handleGlobeClick(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        let x, y;
        if (event.type.startsWith('touch')) {
          x = ((event.changedTouches[0].clientX - rect.left) / rect.width) * 2 - 1;
          y = -((event.changedTouches[0].clientY - rect.top) / rect.height) * 2 + 1;
        } else {
          x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }
        mouse.x = x;
        mouse.y = y;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(satellites);
        if (intersects.length > 0) {
          const sat = intersects[0].object;
          if (isUserAuthenticated()) {
            window.location.href = sat.userData.url;
          } else {
            window.location.href = 'login.html';
          }
        }
      }
      // Remove any previous event listeners to avoid duplicates
      container.onclick = null;
      container.ontouchend = null;
      container.addEventListener('click', handleGlobeClick);
      container.addEventListener('touchend', handleGlobeClick);
      
      // --- Persistent Night Sky, Frame Rate Logging, and Real Source Code Backup ---
      let persistentNightSky = [];
      let emittedParticleCount = 0;
      let maxFrameRate = 0;
      let maxParticlesReached = 0;
      let sourceChunks = [];
      // --- Real Source Code Backup Logic ---
      // Embed real code from project files (simulation.js, facetProcessor.js, index.js)
      const realSourceFiles = [
        `// simulation.js\n${`/**\n * Gem Bot Simulation\n * 3D visualization of a laboratory with automated faceting machines and 3D printer farm\n */\n...`}`,
        `// facetProcessor.js\n${`/**\n * Gem Bot Facet Processor\n * Processes facet diagrams and converts them to GCode for the automated faceting machine\n * Enhanced with computer vision capabilities through Python backend\n */\n...`}`,
        `// index.js\n${`// Add login and sign-up buttons with player profile display\nwindow.addEventListener('DOMContentLoaded', () => { ... });`}`
      ];
      function getSourceChunks() {
        const chunkSize = 256;
        let chunks = [];
        for (let file of realSourceFiles) {
          for (let i = 0; i < file.length; i += chunkSize) {
            chunks.push(file.slice(i, i + chunkSize));
          }
        }
        return chunks;
      }
      sourceChunks = getSourceChunks();

      // Save persistent state to localStorage
      function saveNightSkyState() {
        const state = persistentNightSky.map(star => ({
          x: star.position.x,
          y: star.position.y,
          z: star.position.z,
          color: star.material.color.getHex(),
          codeChunk: star.userData.codeChunk || null
        }));
        localStorage.setItem('nightSkyState', JSON.stringify(state));
        localStorage.setItem('emittedParticleCount', emittedParticleCount);
        localStorage.setItem('maxParticlesReached', maxParticlesReached);
        localStorage.setItem('maxFrameRate', maxFrameRate);
      }
      // Load persistent state from localStorage
      function loadNightSkyState() {
        const state = JSON.parse(localStorage.getItem('nightSkyState') || '[]');
        persistentNightSky = [];
        state.forEach(s => {
          const geo = new THREE.SphereGeometry(0.03, 8, 8);
          const mat = new THREE.MeshBasicMaterial({ color: s.color, transparent: true, opacity: 0.7 });
          const star = new THREE.Mesh(geo, mat);
          star.position.set(s.x, s.y, s.z);
          star.userData = { codeChunk: s.codeChunk };
          scene.add(star);
          persistentNightSky.push(star);
        });
        emittedParticleCount = parseInt(localStorage.getItem('emittedParticleCount') || '0', 10);
        maxParticlesReached = parseInt(localStorage.getItem('maxParticlesReached') || '0', 10);
        maxFrameRate = parseFloat(localStorage.getItem('maxFrameRate') || '0');
      }
      // On load, restore persistent night sky
      loadNightSkyState();

      // --- Firework-style Night Sky Backup System ---
      function launchFireworkBurst() {
        // 1. Launch from a random point on the Earth's surface
        const earthRadius = 5.1;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const startX = earthRadius * Math.sin(phi) * Math.cos(theta);
        const startY = earthRadius * Math.sin(phi) * Math.sin(theta);
        const startZ = earthRadius * Math.cos(phi);
        // 2. Create the firework sphere
        const fireworkGeo = new THREE.SphereGeometry(0.12, 12, 12);
        const fireworkMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.95 });
        const firework = new THREE.Mesh(fireworkGeo, fireworkMat);
        firework.position.set(startX, startY, startZ);
        scene.add(firework);
        // 3. Animate ascent
        const burstHeight = 12 + Math.random() * 3;
        const ascentDir = new THREE.Vector3(startX, startY, startZ).normalize();
        const burstTarget = ascentDir.clone().multiplyScalar(burstHeight);
        let t = 0;
        function animateFirework() {
          t += 0.025;
          firework.position.lerpVectors(
            new THREE.Vector3(startX, startY, startZ),
            burstTarget,
            t
          );
          firework.material.opacity = 0.95 - t * 0.5;
          if (t < 1) {
            requestAnimationFrame(animateFirework);
          } else {
            // 4. Burst into multiple stars
            scene.remove(firework);
            burstFirework(burstTarget);
          }
        }
        animateFirework();
      }
      function burstFirework(center) {
        const numStars = 6 + Math.floor(Math.random() * 5); // 6-10 stars
        for (let i = 0; i < numStars; i++) {
          // Random direction
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const dir = new THREE.Vector3(
            Math.sin(phi) * Math.cos(theta),
            Math.sin(phi) * Math.sin(theta),
            Math.cos(phi)
          );
          // Star geometry/material
          const geo = new THREE.SphereGeometry(0.06, 8, 8);
          const mat = new THREE.MeshBasicMaterial({ color: 0x9932cc, transparent: true, opacity: 0.7 });
          const star = new THREE.Mesh(geo, mat);
          star.position.copy(center);
          scene.add(star);
          // Animate outward
          const finalPos = center.clone().add(dir.multiplyScalar(3 + Math.random() * 3));
          let t = 0;
          function animateStar() {
            t += 0.04;
            star.position.lerpVectors(center, finalPos, t);
            if (t < 1) {
              requestAnimationFrame(animateStar);
            } else {
              // addUptimeStar(star); // <-- Commented out to prevent ReferenceError
            }
          }
          animateStar();
        }
      }
      // Replace interval with firework bursts
      setInterval(launchFireworkBurst, 2500);

      // Handle window resize
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      window.addEventListener('resize', onWindowResize);
      
      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        
        // Rotate earth
        earth.rotation.y += 0.001;
        
        // Rotate satellites around the earth
        satellites.forEach((satellite, index) => {
          const speed = 0.0001 * (1 + index * 0.1);
          const angle = (Date.now() * speed) % (Math.PI * 2);
          const radius = 9;
          
          satellite.position.x = Math.cos(angle + index) * radius;
          satellite.position.z = Math.sin(angle + index) * radius;
          
          // Make satellites rotate
          satellite.rotation.y += 0.01;
        });
        
        // Update label positions to match satellites
        labels.forEach(item => {
          item.label.position.x = item.satelliteRef.position.x;
          item.label.position.z = item.satelliteRef.position.z;
          item.label.position.y = item.satelliteRef.position.y + 1.8;
          
          // Make labels always face the camera
          item.label.lookAt(camera.position);
        });
        
        controls.update();
        renderer.render(scene, camera);
      }
      
      animate();

      // --- Globe Satellite Navigation Fix ---
      // Make satellites, camera, raycaster globally accessible for event handlers
      window.satellites = satellites;
      window.camera = camera;
      window.raycaster = raycaster;
      window.mouse = mouse;

      function handleGlobePointer(event) {
        const container = document.getElementById('globe-container');
        const rect = container.getBoundingClientRect();
        let x, y;
        if (event.type.startsWith('touch')) {
          x = ((event.changedTouches[0].clientX - rect.left) / rect.width) * 2 - 1;
          y = -((event.changedTouches[0].clientY - rect.top) / rect.height) * 2 + 1;
        } else {
          x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }
        window.mouse.x = x;
        window.mouse.y = y;
        window.raycaster.setFromCamera(window.mouse, window.camera);
        const intersects = window.raycaster.intersectObjects(window.satellites);
        if (intersects.length > 0) {
          const sat = intersects[0].object;
          if (isUserAuthenticated()) {
            window.location.href = sat.userData.url;
          } else {
            window.location.href = 'login.html';
          }
        }
      }
      // Remove any previous event listeners to avoid duplicates
      const globeContainer = document.getElementById('globe-container');
      globeContainer.onclick = null;
      globeContainer.ontouchend = null;
      globeContainer.addEventListener('click', handleGlobePointer);
      globeContainer.addEventListener('touchend', handleGlobePointer);
    }

    // --- Location Logs UI ---
    // Add a section to display user location logs
    function renderLocationLogs(logs) {
      let html = '<h3>Location Logs</h3>';
      if (!logs || logs.length === 0) {
        html += '<p>No location logs found.</p>';
      } else {
        html += '<ul style="max-height:200px;overflow-y:auto;padding-left:1em;">';
        logs.forEach(log => {
          html += `<li><b>${log.location}</b> <span style='color:#888;font-size:0.9em;'>(${new Date(log.timestamp).toLocaleString()})</span></li>`;
        });
        html += '</ul>';
      }
      let logDiv = document.getElementById('locationLogs');
      if (!logDiv) {
        logDiv = document.createElement('div');
        logDiv.id = 'locationLogs';
        logDiv.style.margin = '1em 0';
        const postLoginContent = document.getElementById('postLoginContent');
        postLoginContent.insertBefore(logDiv, postLoginContent.firstChild);
      }
      logDiv.innerHTML = html;
    }

    // Fetch and display logs for the current user
    async function fetchAndShowLocationLogs() {
      const user = JSON.parse(localStorage.getItem('userProfile') || '{}');
      if (!user.walletAddress) return;
      try {
        const res = await fetch(`/api/location-logs/${user.walletAddress}`);
        if (!res.ok) throw new Error('Failed to fetch logs');
        const logs = await res.json();
        renderLocationLogs(logs);
      } catch (e) {
        renderLocationLogs([]);
      }
    }

    // Call this after login
    if (isUserAuthenticated()) {
      fetchAndShowLocationLogs();
      updateAuthButton();
    }

    async function fetchLeaderboardFromServer() {
        const tbody = document.getElementById('allAgentsTable').querySelector('tbody');
        try {
            const res = await fetch('/api/players/leaderboard?limit=50', { cache: 'no-store' });
            if (res.ok) {
                const players = await res.json();
                renderAllAgentsTableFromUsers(players);
            } else {
                // Use fallback data instead of showing error
                console.log('‚ö†Ô∏è Leaderboard API not available, using fallback data');
                const fallbackData = getFallbackLeaderboardData();
                renderAllAgentsTableFromUsers(fallbackData);
            }
        } catch (e) {
            // Use fallback data instead of showing error
            console.log('‚ö†Ô∏è Leaderboard API failed, using fallback data');
            const fallbackData = getFallbackLeaderboardData();
            renderAllAgentsTableFromUsers(fallbackData);
        }
    }

    function getFallbackLeaderboardData() {
        return {
            players: [
                { id: 1, name: 'Mandem.OS Player 1', score: 1000, level: 10, walletAddress: '0x1234...5678' },
                { id: 2, name: 'Mandem.OS Player 2', score: 950, level: 9, walletAddress: '0x2345...6789' },
                { id: 3, name: 'Mandem.OS Player 3', score: 900, level: 8, walletAddress: '0x3456...7890' },
                { id: 4, name: 'Mandem.OS Player 4', score: 850, level: 7, walletAddress: '0x4567...8901' },
                { id: 5, name: 'Mandem.OS Player 5', score: 800, level: 6, walletAddress: '0x5678...9012' }
            ]
        };
    }

    async function updatePlayerOnServer() {
      if (!isUserAuthenticated()) return;
      const user = JSON.parse(localStorage.getItem('currentUser') || 'null');
      if (!user || !user.walletAddress) return;
      
      const profile = JSON.parse(localStorage.getItem('userProfile') || '{}');
      const playerData = {
        walletAddress: user.walletAddress,
        displayName: user.displayName || `Player ${user.walletAddress.slice(0, 4)}`,
        maskEmoji: 'üíé',
        mgcBalance: profile.inGameMGC || 0,
        status: 'Active',
        role: 'Player',
        uptimeMinutes: 0
      };
      
      try {
        await fetch('/api/players/update', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(playerData)
        });
        console.log('[Leaderboard] Player registered:', playerData.walletAddress);
      } catch (e) {
        console.warn('[Leaderboard] Server not available');
      }
    }

    async function sendPlayerHeartbeat() {
      if (!isUserAuthenticated()) return;
      const user = JSON.parse(localStorage.getItem('currentUser') || 'null');
      if (!user || !user.walletAddress) return;
      
      try {
        await fetch('/api/players/heartbeat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ walletAddress: user.walletAddress })
        });
      } catch (e) {
        // Server offline, ignore
      }
    }

    function startPlayerTracking() {
      // Register player
      updatePlayerOnServer();
      
      // Send heartbeat every 60 seconds
      if (playerHeartbeatInterval) clearInterval(playerHeartbeatInterval);
      playerHeartbeatInterval = setInterval(sendPlayerHeartbeat, 60000);
      
      console.log('[Leaderboard] Player tracking started');
    }

    function stopPlayerTracking() {
      if (playerHeartbeatInterval) {
        clearInterval(playerHeartbeatInterval);
        playerHeartbeatInterval = null;
      }
    }

    function startLeaderboardRefresh() {
      // Initial fetch
      fetchLeaderboardFromServer();
      
      // Refresh every 10 seconds
      if (leaderboardRefreshInterval) clearInterval(leaderboardRefreshInterval);
      leaderboardRefreshInterval = setInterval(fetchLeaderboardFromServer, 10000);
      
      console.log('[Leaderboard] Auto-refresh started');
    }

    function stopLeaderboardRefresh() {
      if (leaderboardRefreshInterval) {
        clearInterval(leaderboardRefreshInterval);
        leaderboardRefreshInterval = null;
      }
    }

    document.addEventListener('DOMContentLoaded', function() {
      // Start leaderboard system
      startLeaderboardRefresh();
      
      // Start player tracking if logged in
      if (isUserAuthenticated()) {
        startPlayerTracking();
      }
      
      // Agent log panel toggle
      const agentLogPanel = document.getElementById('agentLogPanel');
      const showAgentLogBtn = document.getElementById('showAgentLogBtn');
      const toggleAgentLog = document.getElementById('toggleAgentLog');
      showAgentLogBtn.onclick = function() {
        agentLogPanel.style.display = 'block';
        showAgentLogBtn.style.display = 'none';
      };
      toggleAgentLog.onclick = function() {
        agentLogPanel.style.display = 'none';
        showAgentLogBtn.style.display = 'none';
      };
      
      // Cleanup on page unload
      window.addEventListener('beforeunload', function() {
        stopPlayerTracking();
        stopLeaderboardRefresh();
      });
    });

    // Glowing blue box toggles All Players panel
    const glowingBox = document.getElementById('allPlayersGlowingBox');
    const agentLogPanel = document.getElementById('agentLogPanel');
    glowingBox.onclick = function() {
      agentLogPanel.style.display = 'block';
    };
    // Hide panel button already works
    // Make usernames in All Players table clickable for admin access
    function makeUsernamesAdminClickable() {
      const tbody = document.getElementById('allAgentsTable').querySelector('tbody');
      Array.from(tbody.querySelectorAll('tr')).forEach(row => {
        const usernameCell = row.children[1];
        if (usernameCell && !usernameCell.classList.contains('admin-link')) {
          usernameCell.classList.add('admin-link');
          usernameCell.style.cursor = 'pointer';
          usernameCell.style.textDecoration = 'underline';
          usernameCell.onclick = function(e) {
            e.stopPropagation();
            // Wallet-based admin authentication
            const ADMIN_VAULT = '6HTjfgWZYMbENnMAJJFhxWR2VZDxdze3qV7zznSAsfk';
            const user = JSON.parse(localStorage.getItem('currentUser') || 'null');
            if (user && user.walletAddress === ADMIN_VAULT) {
              localStorage.setItem('admin_authenticated', 'true');
              localStorage.setItem('admin_wallet', user.walletAddress);
              window.location.href = 'admin.html';
            } else {
              alert('Access denied. Admin vault wallet required.');
            }
          };
        }
      });
    }
    // Patch into table update
    const origRenderAllAgents = renderAllAgentsTableFromUsers;
    renderAllAgentsTableFromUsers = function(users) {
      origRenderAllAgents(users);
      makeUsernamesAdminClickable();
    };

    // --- Auto-logout on session end or inactivity (home page) ---
    function logoutAndRedirect() {
      localStorage.removeItem('currentUser');
      localStorage.removeItem('userProfile');
      localStorage.removeItem('userLoggedIn');
      localStorage.removeItem('lastWalletAuth');
      window.location.href = 'login.html';
    }

    // Logout on page refresh (session end)
    window.addEventListener('beforeunload', () => {
      logoutAndRedirect();
    });

    // Logout after 5 minutes of inactivity
    let inactivityTimeout;
    function resetInactivityTimer() {
      if (inactivityTimeout) clearTimeout(inactivityTimeout);
      inactivityTimeout = setTimeout(() => {
        logoutAndRedirect();
      }, 5 * 60 * 1000); // 5 minutes
    }
    ['mousemove', 'keydown', 'mousedown', 'touchstart'].forEach(evt => {
      window.addEventListener(evt, resetInactivityTimer);
    });
    resetInactivityTimer();

    // Active Users Tracking
    let activeAgentsCount = 8; // Total tester agents
    let realUsersCount = 1; // Current session
    let realUserSessions = JSON.parse(localStorage.getItem('realUserSessions') || '{}');

    function updateActiveUsersDisplay() {
        const agentsElement = document.getElementById('activeAgentsCount');
        const usersElement = document.getElementById('realUsersCount');
        if (agentsElement) agentsElement.textContent = activeAgentsCount;
        if (usersElement) usersElement.textContent = realUsersCount;
    }

    function trackRealUserSession() {
        const sessionId = generateSessionId();
        const now = Date.now();
        
        // Clean old sessions (older than 24 hours)
        Object.keys(realUserSessions).forEach(key => {
            if (now - realUserSessions[key] > 24 * 60 * 60 * 1000) {
                delete realUserSessions[key];
            }
        });
        
        // Add current session
        realUserSessions[sessionId] = now;
        localStorage.setItem('realUserSessions', JSON.stringify(realUserSessions));
        
        // Count active sessions (within last 5 minutes)
        const activeSessions = Object.values(realUserSessions).filter(timestamp => 
            now - timestamp < 5 * 60 * 1000
        ).length;
        
        realUsersCount = activeSessions;
        updateActiveUsersDisplay();
        
        logSessionEvent('info', 'Real user session tracked', { sessionId, activeUsers: realUsersCount });
    }

    function generateSessionId() {
        return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    function simulateAgentActivity() {
        // Agents are always active in this simulation
        activeAgentsCount = 8; // Fixed for demo, but could be dynamic
        
        // Update display
        updateActiveUsersDisplay();
        
        // Log agent activity
        logSessionEvent('info', 'Agent activity updated', { activeAgents: activeAgentsCount });
    }

    // Initialize tracking
    trackRealUserSession();
    simulateAgentActivity();
    
    // Update every 30 seconds
    setInterval(() => {
        trackRealUserSession();
        simulateAgentActivity();
    }, 30000);

    // Utility: detect mobile
    function isMobile() {
      return /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }
    // Hide chat for mobile
    if (isMobile()) {
      const hideChat = () => {
        const chat = document.getElementById('global-chat-container');
        const chatBtn = document.getElementById('chat-minimized-button');
        if (chat) chat.style.display = 'none';
        if (chatBtn) chatBtn.style.display = 'none';
      };
      // Try immediately and after DOMContentLoaded
      hideChat();
      document.addEventListener('DOMContentLoaded', hideChat);
    }
    // Globe: make satellites navigable on mobile tap
    function enableMobileGlobeLinks() {
      const container = document.getElementById('globe-container');
      if (!container) return;
      container.addEventListener('touchend', function(event) {
        // Use the same raycasting logic as click
        if (typeof THREE === 'undefined') return;
        const rect = container.getBoundingClientRect();
        const x = ((event.changedTouches[0].clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((event.changedTouches[0].clientY - rect.top) / rect.height) * 2 + 1;
        if (window.camera && window.raycaster && window.satellites) {
          window.mouse = window.mouse || new THREE.Vector2();
          window.mouse.x = x;
          window.mouse.y = y;
          window.raycaster.setFromCamera(window.mouse, window.camera);
          const intersects = window.raycaster.intersectObjects(window.satellites);
          if (intersects.length > 0) {
            const sat = intersects[0].object;
            if (isUserAuthenticated()) {
              window.location.href = sat.userData.url;
            } else {
              window.location.href = 'login.html';
            }
          }
        }
      });
    }
    document.addEventListener('DOMContentLoaded', enableMobileGlobeLinks);
    console.log('Page loaded at', new Date().toLocaleTimeString());
    window.addEventListener('DOMContentLoaded', () => {
      console.log('DOM fully loaded at', new Date().toLocaleTimeString());
    });

    // Command Center toggle button
    const contentToggleBtn = document.getElementById('contentToggleBtn');
    const syncDropdown = document.getElementById('sync-status-dropdown');
    let syncDropdownVisible = false;

    // Show/hide sync dropdown on button click
    contentToggleBtn.addEventListener('click', function() {
      // ...existing code for toggling Mission Control...
      syncDropdownVisible = !syncDropdownVisible;
      syncDropdown.style.display = syncDropdownVisible ? 'block' : 'none';
      if (syncDropdownVisible) updateSyncDropdown();
    });

    // Hide dropdown if user clicks outside (mobile friendly)
    document.addEventListener('click', function(e) {
      if (syncDropdownVisible && !syncDropdown.contains(e.target) && e.target !== contentToggleBtn) {
        syncDropdown.style.display = 'none';
        syncDropdownVisible = false;
      }
    });

    // Poll sync status and update dropdown
    async function updateSyncDropdown() {
      try {
        const res = await fetch('/api/sync-status');
        if (!res.ok) throw new Error('Failed to fetch sync status');
        const data = await res.json();
        const main = document.getElementById('sync-status-main');
        const times = document.getElementById('sync-status-times');
        if (data.isSyncing) {
          main.textContent = 'Servers are syncing... Real-time player data may be delayed.';
        } else {
          main.textContent = 'Servers are in sync.';
        }
        if (data.lastSyncTime && data.nextSyncTime) {
          times.textContent = `Last sync: ${new Date(data.lastSyncTime).toLocaleTimeString()} | Next sync: ${new Date(data.nextSyncTime).toLocaleTimeString()}`;
        } else {
          times.textContent = '';
        }
      } catch (e) {
        document.getElementById('sync-status-main').textContent = 'Unable to fetch sync status.';
        document.getElementById('sync-status-times').textContent = '';
      }
    }
    // Update dropdown every 5s if visible
    setInterval(() => { if (syncDropdownVisible) updateSyncDropdown(); }, 5000);
  </script>         
        <script src="public/facetProcessor.js"></script>
        <script src="public/simulation.js"></script>
        <script src="public/phantomLogin.js"></script>         
        <!-- Add login simulation code -->         
        <script>
    // Simulate login functionality
    document.getElementById('loginBtn').addEventListener('click', function(e) {
      e.preventDefault();
      // Redirect to login page without setting any flag
      window.location.href = 'login.html';
    });
    
    // Add a "logged in" indicator if user is logged in
    if (isUserAuthenticated()) {
      const loginBtn = document.getElementById('loginBtn');
      loginBtn.textContent = 'Logged In';
      loginBtn.style.backgroundColor = '#4CAF50';
      
      // Show toggle controls button and update UI
      updateUIForLoginState();
      updateAuthButton();
    }
  </script>         
        <!-- Register Service Worker -->         
        <script>
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", function () {
        navigator.serviceWorker.register("service-worker.js").then(function (registration) {
          console.log("Service Worker registered with scope:", registration.scope);
        }, function (err) {
          console.log("Service Worker registration failed:", err);
        });
      });
    }
  </script>         
        <script>
console.log('[DEBUG] index.html loaded');
console.log('[DEBUG] currentUser:', localStorage.getItem('currentUser'));
console.log('[DEBUG] userProfile:', localStorage.getItem('userProfile'));
console.log('[DEBUG] userLoggedIn:', localStorage.getItem('userLoggedIn'));
console.log('[DEBUG] lastWalletAuth:', localStorage.getItem('lastWalletAuth'));

// Modal button handlers
document.addEventListener('DOMContentLoaded', () => {
  const modalLoginBtn = document.getElementById('modalLoginBtn');
  const modalCloseBtn = document.getElementById('modalCloseBtn');
  const loginModal = document.getElementById('loginModal');
  
  if (modalLoginBtn) {
    modalLoginBtn.addEventListener('click', async () => {
      const success = await quickConnectWallet();
      if (success && loginModal) {
        loginModal.style.display = 'none';
      }
    });
  }
  
  if (modalCloseBtn) {
    modalCloseBtn.addEventListener('click', () => {
      if (loginModal) loginModal.style.display = 'none';
    });
  }
  
  // Close modal on background click
  if (loginModal) {
    loginModal.addEventListener('click', (e) => {
      if (e.target === loginModal) {
        loginModal.style.display = 'none';
      }
    });
  }
});

    async function updateStatusMessage() {
        const statusMessage = document.getElementById('statusMessage');
        if (!statusMessage) return;
        
        let text = '';
        let lastServerError = '';
        try {
            const res = await fetch('/api/ping', { cache: 'no-store', signal: AbortSignal.timeout(2000) });
            if (res.ok) {
                text = '‚úì Online';
                lastServerError = '';
                statusMessage.style.background = 'rgba(0, 200, 0, 0.8)';
                statusMessage.style.display = 'block';
                logSessionEvent('info', 'Server connection successful');
            } else {
                text = '‚úó Offline';
                lastServerError = `(${res.status})`;
                statusMessage.style.background = 'rgba(200, 0, 0, 0.8)';
                logSessionEvent('warning', 'Server returned error', { status: res.status });
            }
        } catch (e) {
            // Server offline is normal - hide status to avoid clutter
            statusMessage.style.display = 'none';
            logSessionEvent('info', 'Server connection failed (expected offline)', { error: e.message });
            return;
        }
        statusMessage.textContent = `Server: ${text}${lastServerError ? ' ' + lastServerError : ''}`;
    }

// Server start button - graceful failure
const statusMsg = document.getElementById('statusMessage');
if (statusMsg) {
  statusMsg.onclick = async function() {
    statusMsg.textContent = 'Server: Retrying...';
    statusMsg.style.background = 'rgba(255, 165, 0, 0.8)';
    try {
      const res = await fetch('/api/start-server', { method: 'POST', signal: AbortSignal.timeout(5000) });
      if (res.ok) {
        statusMsg.textContent = 'Server: Reconnecting...';
        setTimeout(updateStatusMessage, 3000);
      } else if (res.status === 404) {
        statusMsg.textContent = 'Server: Optional (Offline Mode)';
        statusMsg.style.background = 'rgba(100, 100, 100, 0.7)';
        setTimeout(() => statusMsg.style.display = 'none', 3000);
      } else {
        throw new Error('Failed to start server');
      }
    } catch (e) {
      statusMsg.textContent = 'Server: Optional (Offline Mode)';
      statusMsg.style.background = 'rgba(100, 100, 100, 0.7)';
      setTimeout(() => statusMsg.style.display = 'none', 3000);
    }
  };
}
setInterval(updateStatusMessage, 5000);
updateStatusMessage();
</script>
<script>
// Dynamic server port and route detection
const POSSIBLE_PORTS = [3000, 5500, 8080, 5000];
const POSSIBLE_ROUTES = ['/api/ping', '/api/health', '/api/status', '/api/user/profile'];
let detectedApiBaseUrl = null;
let detectedApiRoute = null;

async function detectApiPortAndRoute() {
  for (const port of POSSIBLE_PORTS) {
    for (const route of POSSIBLE_ROUTES) {
      const url = `${window.location.protocol}//${window.location.hostname}:${port}${route}`;
      try {
        const res = await fetch(url, { cache: 'no-store', mode: 'cors' });
        if (res.ok) {
          detectedApiBaseUrl = `${window.location.protocol}//${window.location.hostname}:${port}`;
          detectedApiRoute = route;
          console.log(`[Server Detection] API detected at: ${detectedApiBaseUrl}${detectedApiRoute}`);
          return { baseUrl: detectedApiBaseUrl, route: detectedApiRoute };
        }
      } catch (e) {
        // Ignore failed ports/routes
      }
    }
  }
  detectedApiBaseUrl = null;
  detectedApiRoute = null;
  return null;
}

function getApiBaseUrl() {
  return detectedApiBaseUrl || window.location.origin;
}
function getApiHealthRoute() {
  return detectedApiRoute || '/api/ping';
}

// On page load, detect the API port and route
(async function() {
  await detectApiPortAndRoute();
})();

// Sketchfab integration logic
const sketchfabBrowseBtn = document.getElementById('sketchfabBrowseBtn');
sketchfabBrowseBtn.onclick = () => {
  window.open('https://sketchfab.com/3d-models?date=week&features=downloadable+animated&sort_by=-likeCount', '_blank');
};
const sketchfabEmbedBtn = document.getElementById('sketchfabEmbedBtn');
const sketchfabModal = document.getElementById('sketchfabModal');
const closeSketchfabModal = document.getElementById('closeSketchfabModal');
const embedSketchfabModel = document.getElementById('embedSketchfabModel');
const sketchfabInput = document.getElementById('sketchfabInput');
const sketchfabEmbedContainer = document.getElementById('sketchfabEmbedContainer');

sketchfabEmbedBtn.onclick = () => {
  sketchfabModal.style.display = 'flex';
  sketchfabEmbedContainer.innerHTML = '';
  sketchfabInput.value = '';
};
closeSketchfabModal.onclick = () => {
  sketchfabModal.style.display = 'none';
};
embedSketchfabModel.onclick = () => {
  let val = sketchfabInput.value.trim();
  let modelUid = '';
  if (val.match(/^https?:\/\//)) {
    // Extract UID from URL
    const match = val.match(/3d-models\/.*-(\w{32})/);
    if (match) modelUid = match[1];
  } else if (val.match(/^\w{32}$/)) {
    modelUid = val;
  }
  if (modelUid) {
    sketchfabEmbedContainer.innerHTML = `<iframe title="Sketchfab" width="100%" height="320" allowfullscreen webkitallowfullscreen mozallowfullscreen src="https://sketchfab.com/models/${modelUid}/embed"></iframe>`;
  } else {
    sketchfabEmbedContainer.innerHTML = '<div style="color:#f66;">Invalid Sketchfab URL or Model UID.</div>';
  }
};
// Close modal on outside click
sketchfabModal.addEventListener('click', e => {
  if (e.target === sketchfabModal) sketchfabModal.style.display = 'none';
});

// 3D Model Gallery logic
async function fetchModelMetadata() {
  try {
    const res = await fetch('/api/models');
    if (!res.ok) {
      console.log('‚ö†Ô∏è Model API not available, using fallback data');
      return getFallbackModelData();
    }
    return await res.json();
  } catch (error) {
    console.log('‚ö†Ô∏è Model API failed, using fallback data');
    return getFallbackModelData();
  }
}

function getFallbackModelData() {
  return [
    {
      name: 'Mandem.OS Globe',
      author: 'Mandem.OS Team',
      preview: './images/globe-preview.jpg',
      filename: 'globe.glb',
      description: 'Interactive 3D globe for Mandem.OS'
    },
    {
      name: 'Investment Dashboard',
      author: 'Mandem.OS Team',
      preview: './images/dashboard-preview.jpg',
      filename: 'dashboard.glb',
      description: '3D investment portfolio visualization'
    }
  ];
}
function renderModelGallery(models) {
  const grid = document.getElementById('modelGalleryGrid');
  grid.innerHTML = '';
  models.forEach(model => {
    const div = document.createElement('div');
    div.style.width = '140px';
    div.style.background = '#222';
    div.style.borderRadius = '10px';
    div.style.padding = '8px';
    div.style.cursor = 'pointer';
    div.style.boxShadow = '0 2px 8px #0004';
    div.innerHTML = `
      <img src="${model.preview || ''}" alt="preview" style="width:100%;height:90px;object-fit:cover;border-radius:6px;"/>
      <div style="font-size:15px;font-weight:bold;margin:6px 0 2px 0;">${model.name}</div>
      <div style="font-size:12px;color:#aaa;">${model.author || ''}</div>
    `;
    div.onclick = () => showModelPreview(model);
    grid.appendChild(div);
  });
}
function filterModels(models, query) {
  query = query.toLowerCase();
  return models.filter(m =>
    m.name.toLowerCase().includes(query) ||
    (m.description && m.description.toLowerCase().includes(query)) ||
    (m.author && m.author.toLowerCase().includes(query))
  );
}
let allModels = [];
async function loadModelGallery() {
  allModels = await fetchModelMetadata();
  renderModelGallery(allModels);
}
document.getElementById('modelSearchInput').addEventListener('input', function() {
  const filtered = filterModels(allModels, this.value);
  renderModelGallery(filtered);
});
// Model preview modal logic
const modelPreviewModal = document.getElementById('modelPreviewModal');
const closeModelPreview = document.getElementById('closeModelPreview');
function showModelPreview(model) {
  document.getElementById('previewModelName').textContent = model.name;
  document.getElementById('previewModelMeta').innerHTML = `By: ${model.author || 'Unknown'}<br>${model.description || ''}`;
  // Load and display the .glb model in Three.js
  const viewer = document.getElementById('previewModelViewer');
  viewer.innerHTML = '';
  // Dynamically load Three.js GLTFLoader if not present
  if (!window.THREE || !window.THREE.GLTFLoader) {
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js';
    script.onload = () => renderGLBModel(model.filename, viewer);
    document.body.appendChild(script);
  } else {
    renderGLBModel(model.filename, viewer);
  }
  modelPreviewModal.style.display = 'flex';
}
closeModelPreview.onclick = () => { modelPreviewModal.style.display = 'none'; };
modelPreviewModal.addEventListener('click', e => {
  if (e.target === modelPreviewModal) modelPreviewModal.style.display = 'none';
});
function renderGLBModel(filename, container) {
  container.innerHTML = '';
  const width = container.offsetWidth || 420;
  const height = container.offsetHeight || 320;
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, width/height, 0.1, 100);
  camera.position.set(0, 1, 2.5);
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(width, height);
  container.appendChild(renderer.domElement);
  const light = new THREE.HemisphereLight(0xffffff, 0x222233, 1.2);
  scene.add(light);
  const loader = new THREE.GLTFLoader();
  loader.load(`/3DModels/${filename}`, function(gltf) {
    const model = gltf.scene;
    scene.add(model);
    animate();
  }, undefined, function(error) {
    container.innerHTML = '<div style="color:#f66;">Failed to load model.</div>';
  });
  function animate() {
    requestAnimationFrame(animate);
    scene.rotation.y += 0.008;
    renderer.render(scene, camera);
  }
}
// Load gallery on page load
loadModelGallery();
</script>
<button id="startBrainCellBtn" style="display:none;margin:2em auto;">Start Brain Cell Server</button>
<script>
// ...existing code...
async function checkServerAndShowBrainCellBtn() {
  try {
    const res = await fetch('/api/ping', {cache:'no-store'});
    if (res.ok) {
      document.getElementById('startBrainCellBtn').style.display = 'none';
      return;
    }
  } catch {
    // Server is down
  }
  document.getElementById('startBrainCellBtn').style.display = 'block';
}
document.getElementById('startBrainCellBtn').onclick = function() {
  // Try to launch EXE (user must download and run it manually)
  window.open('start-braincell-server.exe', '_blank');
  alert('If prompted, please run the Brain Cell EXE to start your local server.');
};
window.addEventListener('DOMContentLoaded', checkServerAndShowBrainCellBtn);
// ...existing code...
</script>

<!-- Mandem.OS Universal Auth Integration -->
<script>
// Initialize wallet authentication for Mandem.OS
window.addEventListener('DOMContentLoaded', async () => {
    console.log('üåê Mandem.OS - Initializing Universal Auth...');
    
    try {
        // Initialize universal auth with custom integration
        await window.authIntegration.init({
            showUI: false,  // Use existing login UI
            onAuthSuccess: (authInfo) => {
                console.log('‚úÖ Mandem.OS - Wallet authenticated:', authInfo.address);
                updateMandemAuthUI(authInfo);
            },
            onAuthFail: () => {
                console.log('‚ö†Ô∏è Mandem.OS - Wallet not connected');
            }
        });
    } catch (error) {
        console.error('‚ùå Mandem.OS - Auth init failed:', error);
    }
});

// Update Mandem.OS auth UI
function updateMandemAuthUI(authInfo) {
    const loginBtn = document.getElementById('loginBtn');
    const profileBtn = document.getElementById('profileBtn');
    
    if (authInfo && authInfo.authenticated) {
        // User is authenticated
        if (loginBtn) loginBtn.style.display = 'none';
        if (profileBtn) {
            profileBtn.style.display = 'inline-block';
            profileBtn.textContent = `üë§ ${authInfo.shortAddress}`;
        }
        
        // Show work time if available
        if (authInfo.workTimeMinutes > 0) {
            const hours = Math.floor(authInfo.workTimeMinutes / 60);
            const mins = authInfo.workTimeMinutes % 60;
            console.log(`‚è±Ô∏è Work time: ${hours}h ${mins}m`);
        }
    } else {
        // User is not authenticated
        if (loginBtn) loginBtn.style.display = 'inline-block';
        if (profileBtn) profileBtn.style.display = 'none';
    }
}

// Enhance login button to use universal auth
const originalLoginBtn = document.getElementById('loginBtn');
if (originalLoginBtn) {
    originalLoginBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        
        try {
            const authInfo = await window.universalWalletAuth.connect();
            if (authInfo) {
                console.log('‚úÖ Mandem.OS wallet connected:', authInfo);
                updateMandemAuthUI(authInfo);
            }
        } catch (error) {
            console.error('‚ùå Mandem.OS wallet connection error:', error);
            alert('Wallet connection failed: ' + error.message);
        }
    });
}

// Listen for auth events
window.addEventListener('authSuccess', (event) => {
    console.log('üéâ Mandem.OS - Auth success event:', event.detail);
    updateMandemAuthUI(event.detail);
});

window.addEventListener('authLogout', () => {
    console.log('üëã Mandem.OS - Auth logout event');
    updateMandemAuthUI(null);
    // Reset GBPT balance on logout
    const gbptSpan = document.getElementById('mndmBalance');
    if (gbptSpan) gbptSpan.textContent = '0';
});

// Update GBPT Token Balance (GBPT) in header
async function updateGBPTBalance() {
    try {
        const gbptSpan = document.getElementById('mndmBalance');
        if (!gbptSpan) return;
        
        // Get connected wallet address
        const walletAddress = window.universalWalletAuth && window.universalWalletAuth.getAddress();
        
        if (!walletAddress) {
            // No wallet connected - show 0
            gbptSpan.textContent = '0';
            return;
        }
        
        // Fetch GBPT token balance
        const balance = await window.getTokenBalance(walletAddress);
        
        // Update display
        const formattedBalance = window.formatTokenAmount(balance, 2);
        gbptSpan.textContent = formattedBalance;
        
        console.log('üî• Mandem.OS - GBPT Balance Updated:', formattedBalance);
    } catch (error) {
        console.error('‚ùå Mandem.OS - Failed to update GBPT balance:', error);
        const gbptSpan = document.getElementById('mndmBalance');
        if (gbptSpan) gbptSpan.textContent = '0';
    }
}

// Update GBPT balance when wallet connects
window.addEventListener('authSuccess', (event) => {
    console.log('üéâ Mandem.OS - Auth success, updating GBPT balance...');
    updateGBPTBalance();
});

// Initial GBPT balance update on page load
setTimeout(() => {
    updateGBPTBalance();
}, 1500); // Wait 1.5 seconds for auth to initialize

console.log('‚úÖ Mandem.OS - Wallet integration loaded');
console.log('üî• GBPT Token tracking enabled');
console.log('üíé MGC Promotion System loaded');
</script>

    </body>     
</html>
